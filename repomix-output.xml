This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.env.example
.gitattributes
.gitignore
build-errors-fix-summary.md
components.json
docs/01-overview/README.md
docs/02-architecture/architecture-details.md
docs/02-architecture/logging-architecture.md
docs/02-architecture/logging-implementation.md
docs/02-architecture/README.md
docs/03-authentication/01-authentication-overview.md
docs/03-authentication/auth-components.md
docs/03-authentication/auth-flow.md
docs/03-authentication/auth-system.md
docs/03-authentication/developer-permission-guide.md
docs/03-authentication/permission-system.md
docs/03-authentication/README.md
docs/04-features/features-details.md
docs/04-features/mcq-data-model.md
docs/04-features/mcq-practice-platform.md
docs/04-features/mcq-progress-update.md
docs/04-features/README.md
docs/05-development/development-guide.md
docs/05-development/logging-usage-guide.md
docs/05-development/README.md
docs/06-deployment/README.md
docs/07-assets/image-requirements.md
docs/07-assets/README.md
docs/api-client-architecture.md
docs/api-client-pattern.md
docs/auth-debugging.md
docs/auth-feature-refactoring.md
docs/auth-refactoring-cleanup.md
docs/authentication-integration.md
docs/code-cleanup.md
docs/DEBUG_NOTES.md
docs/documentation-guide.md
docs/EXAM_API_INTEGRATION_GUIDE.md
docs/EXAM_API_INTEGRATION.md
docs/EXAM_FEATURE_DIAGNOSIS.md
docs/EXAM_FEATURE_ENHANCEMENT_PLAN.md
docs/EXAM_FEATURE_FOLDER_STRUCTURE.md
docs/EXAM_FEATURE_SOLUTION.md
docs/EXAM_FEATURE_STRUCTURE.md
docs/exam-feature-fix.md
docs/exam-feature-implementation-details.md
docs/exam-feature-implementation.md
docs/exams-feature-cleanup.md
docs/plan/documentation-roadmap.md
docs/plan/exams-ui-enhancement.md
docs/PR_NOTES.md
docs/project-architecture.md
docs/README.md
docs/TOKEN_FLOW.md
eslint.config.mjs
final-build-fixes-summary.md
final-eslint-webpack-fixes.md
final-fixes-summary.md
jest.config.js
jest.setup.js
mutations.ts.fixed
next.config.ts
package.json
pharmacyhub-frontend.iml
pharmacyhub-next.iml
postcss.config.mjs
proposed-jwt-enhancement.java
proposed-user-profile-controller.java
proposed-user-profile-dto.java
public/file.svg
public/globe.svg
public/next.svg
public/vercel.svg
public/window.svg
queries.ts.fixed
README.md
scripts/finalize-entities.bat
scripts/migrate-frontend.bat
scripts/move-connections-pages.bat
scripts/move-remaining-pages.bat
scripts/move-requests-pages.bat
scripts/reorganize-pages.bat
scripts/setup_structure.bat
scripts/update-and-move-pages.bat
scripts/verify-structure.bat
src/app/(auth)/forgot-password/page.tsx
src/app/(auth)/index.ts
src/app/(auth)/layout.tsx
src/app/(auth)/loading.tsx
src/app/(auth)/login/page.tsx
src/app/(auth)/register/page.tsx
src/app/(auth)/reset-password/[token]/page.tsx
src/app/(auth)/reset-password/page.tsx
src/app/(auth)/verify-email/[token]/loading.tsx
src/app/(auth)/verify-email/[token]/page.tsx
src/app/(dashboard)/dashboard/page.tsx
src/app/(dashboard)/layout.tsx
src/app/(dashboard)/settings/page.tsx
src/app/(exams)/exam/[id]/page.tsx
src/app/(exams)/exam/mock/mockData.ts
src/app/(exams)/exam/page.tsx
src/app/(exams)/exam/results/page.tsx
src/app/(exams)/exam/review/[id]/page.tsx
src/app/(exams)/layout.tsx
src/app/exam/dashboard/page.tsx
src/app/exam/model-papers/page.tsx
src/app/exam/past-papers/page.tsx
src/app/exam/subject-papers/page.tsx
src/app/globals.css
src/app/layout.tsx
src/app/page.module.css
src/app/page.tsx
src/app/providers/AuthProvider.tsx
src/app/providers/QueryProvider.tsx
src/app/providers/ToastProvider.tsx
src/app/unauthorized/page.tsx
src/components/auth/index.ts
src/components/auth/PermissionGuard.tsx
src/components/common/ErrorBoundary.tsx
src/components/dashboard/Breadcrumbs.tsx
src/components/dashboard/ExamsSidebar.tsx
src/components/dashboard/MobileSidebar.tsx
src/components/dashboard/Sidebar.tsx
src/components/dashboard/UserMenu.tsx
src/components/layout/container.tsx
src/components/ui/accordion.tsx
src/components/ui/alert-dialog.tsx
src/components/ui/alert.tsx
src/components/ui/aspect-ratio.tsx
src/components/ui/avatar.tsx
src/components/ui/badge.tsx
src/components/ui/breadcrumb.tsx
src/components/ui/button.tsx
src/components/ui/calendar.tsx
src/components/ui/card.tsx
src/components/ui/carousel.tsx
src/components/ui/chart.tsx
src/components/ui/checkbox.tsx
src/components/ui/collapsible.tsx
src/components/ui/command.tsx
src/components/ui/confirm-dialog.tsx
src/components/ui/context-menu.tsx
src/components/ui/dialog.tsx
src/components/ui/drawer.tsx
src/components/ui/dropdown-menu.tsx
src/components/ui/form.tsx
src/components/ui/hover-card.tsx
src/components/ui/icons.tsx
src/components/ui/input-otp.tsx
src/components/ui/input.tsx
src/components/ui/label.tsx
src/components/ui/loading-spinner.tsx
src/components/ui/menubar.tsx
src/components/ui/navigation-menu.tsx
src/components/ui/pagination.tsx
src/components/ui/popover.tsx
src/components/ui/progress.tsx
src/components/ui/radio-group.tsx
src/components/ui/resizable.tsx
src/components/ui/scroll-area.tsx
src/components/ui/select.tsx
src/components/ui/separator.tsx
src/components/ui/sheet.tsx
src/components/ui/sidebar.tsx
src/components/ui/skeleton.tsx
src/components/ui/slider.tsx
src/components/ui/sonner.tsx
src/components/ui/switch.tsx
src/components/ui/table.tsx
src/components/ui/tabs.tsx
src/components/ui/textarea.tsx
src/components/ui/toast-context.tsx
src/components/ui/toast.tsx
src/components/ui/toaster.tsx
src/components/ui/toggle-group.tsx
src/components/ui/toggle.tsx
src/components/ui/tooltip.tsx
src/components/ui/use-toast.ts
src/features/auth/api/apiConfig.ts
src/features/auth/api/hooks/index.ts
src/features/auth/api/hooks/mutations.ts
src/features/auth/api/hooks/queries.ts
src/features/auth/api/index.ts
src/features/auth/api/mutations/index.ts
src/features/auth/api/queryKeys.ts
src/features/auth/api/services/auth.service.ts
src/features/auth/api/services/authService.ts
src/features/auth/api/services/index.ts
src/features/auth/api/services/userService.ts
src/features/auth/config/auth.ts
src/features/auth/constants/config.ts
src/features/auth/constants/flags/index.ts
src/features/auth/constants/index.ts
src/features/auth/constants/permissions/index.ts
src/features/auth/constants/roles/index.ts
src/features/auth/constants/routes.ts
src/features/auth/core/AuthContext.tsx
src/features/auth/core/index.ts
src/features/auth/core/tokenManager.ts
src/features/auth/core/types.ts
src/features/auth/hooks/index.ts
src/features/auth/hooks/useAuth.ts
src/features/auth/hooks/useAuthWithQuery.ts
src/features/auth/hooks/useSession.ts
src/features/auth/index.ts
src/features/auth/lib/validation.ts
src/features/auth/model/authState.ts
src/features/auth/model/guards.ts
src/features/auth/model/store.ts
src/features/auth/model/types.ts
src/features/auth/types/index.ts
src/features/auth/ui/auth-flow/AuthDebug.tsx
src/features/auth/ui/auth-flow/index.ts
src/features/auth/ui/feedback/AuthLoading.tsx
src/features/auth/ui/feedback/index.ts
src/features/auth/ui/feedback/Unauthorized.tsx
src/features/auth/ui/index.ts
src/features/auth/ui/layout/AuthLayout.tsx
src/features/auth/ui/layout/index.ts
src/features/auth/ui/login/index.ts
src/features/auth/ui/login/LoginForm.tsx
src/features/auth/ui/password-recovery/ForgotPasswordForm.tsx
src/features/auth/ui/password-recovery/ResetPasswordForm.tsx
src/features/auth/ui/protection/AuthGuard.tsx
src/features/auth/ui/protection/index.ts
src/features/auth/ui/protection/RequireAuth.tsx
src/features/auth/ui/protection/types.ts
src/features/auth/ui/rbac/index.ts
src/features/auth/ui/register/RegisterForm.tsx
src/features/auth/ui/verification/EmailVerificationView.tsx
src/features/auth/ui/verification/index.ts
src/features/auth/utils.ts
src/features/dashboard/api/dashboardApi.ts
src/features/exams/api/adapter.ts
src/features/exams/api/core/examService.ts
src/features/exams/api/core/index.ts
src/features/exams/api/core/queryKeys.ts
src/features/exams/api/hooks/index.ts
src/features/exams/api/hooks/useExamMutations.ts
src/features/exams/api/hooks/useExamQueries.ts
src/features/exams/api/index.ts
src/features/exams/constants/flags/index.ts
src/features/exams/constants/index.ts
src/features/exams/constants/permissions/index.ts
src/features/exams/constants/roles/index.ts
src/features/exams/hooks/index.ts
src/features/exams/hooks/useExamQueries.ts
src/features/exams/index.ts
src/features/exams/lib/analysis.ts
src/features/exams/mock/mockData.ts
src/features/exams/model/index.ts
src/features/exams/model/mcqTypes.ts
src/features/exams/model/types.ts
src/features/exams/progress/api/progressApi.ts
src/features/exams/progress/hooks/useProgressQueries.ts
src/features/exams/store/examPaperStore.ts
src/features/exams/store/examStore.ts
src/features/exams/store/index.ts
src/features/exams/store/mcqExamStore.ts
src/features/exams/types/index.ts
src/features/exams/ui/components/ExamProgress.tsx
src/features/exams/ui/components/ExamResults.tsx
src/features/exams/ui/components/ExamSummary.tsx
src/features/exams/ui/components/ExamTimer.tsx
src/features/exams/ui/components/QuestionDisplay.tsx
src/features/exams/ui/components/QuestionNavigation.tsx
src/features/exams/ui/ExamContainer.tsx
src/features/exams/ui/ExamLanding.tsx
src/features/exams/ui/ExamList.tsx
src/features/exams/ui/ExamPaperCard.tsx
src/features/exams/ui/index.ts
src/features/exams/ui/mcq/index.ts
src/features/exams/ui/mcq/McqExamLayout.tsx
src/features/exams/ui/mcq/McqExamList.tsx
src/features/exams/ui/mcq/McqExamResults.tsx
src/features/exams/ui/mcq/McqQuestionCard.tsx
src/features/exams/ui/mcq/McqQuestionNavigation.tsx
src/features/exams/ui/quiz/ExamLayout.tsx
src/features/exams/ui/quiz/ExamSettings.tsx
src/features/exams/ui/quiz/ExamTimer.tsx
src/features/exams/ui/quiz/QuestionCard.tsx
src/features/exams/ui/quiz/QuestionNavigation.tsx
src/features/exams/ui/results/PerformanceCharts.tsx
src/features/exams/ui/results/ResultsView.tsx
src/features/exams/ui/review/ReviewMode.tsx
src/features/home/ui/FeatureCardSection.tsx
src/features/home/ui/Footer.tsx
src/features/progress/hooks/useProgressQueries.ts
src/features/rbac/api/hooks/useRbacQueries.ts
src/features/rbac/api/index.ts
src/features/rbac/api/queryKeys.ts
src/features/rbac/api/services/rbacService.ts
src/features/rbac/constants/permissions.ts
src/features/rbac/constants/roles.ts
src/features/rbac/contexts/FeatureContext.tsx
src/features/rbac/hooks/index.ts
src/features/rbac/hooks/useAccess.ts
src/features/rbac/hooks/useFeatureAccess.ts
src/features/rbac/hooks/usePermissions.ts
src/features/rbac/index.ts
src/features/rbac/MIGRATION.md
src/features/rbac/README.md
src/features/rbac/registry/featureRegistry.ts
src/features/rbac/registry/index.ts
src/features/rbac/registry/rbacRegistry.ts
src/features/rbac/services/featureFlagService.ts
src/features/rbac/types/index.ts
src/features/rbac/ui/FeatureGuard.tsx
src/features/rbac/ui/index.ts
src/features/rbac/ui/PermissionCheck.tsx
src/features/rbac/ui/PermissionGuard.tsx
src/features/rbac/ui/RoleGuards.tsx
src/features/shared/config/menuItems.ts
src/features/shared/types/index.ts
src/features/tanstack-query-api/components/QueryProvider.tsx
src/features/tanstack-query-api/CONSOLIDATION_PLAN.md
src/features/tanstack-query-api/core/apiClient.ts
src/features/tanstack-query-api/core/apiTypes.ts
src/features/tanstack-query-api/core/queryClient.ts
src/features/tanstack-query-api/core/types.ts
src/features/tanstack-query-api/hooks/useApi.ts
src/features/tanstack-query-api/index.ts
src/features/tanstack-query-api/README.md
src/features/tanstack-query-api/services/createService.ts
src/features/tanstack-query-api/utils/types.ts
src/features/ui/hooks/index.ts
src/features/ui/hooks/use-mobile.ts
src/features/ui/index.ts
src/lib/utils.ts
src/shared/auth/index.ts
src/shared/config/logger.ts
src/shared/index.ts
src/shared/lib/logger.ts
src/shared/ui/cards/interactive-card.tsx
src/shared/ui/CarouselImage.tsx
src/shared/ui/DebouncedSelect.tsx
src/shared/ui/DialogContentField.tsx
src/shared/ui/DialogHeaderField.tsx
src/shared/ui/dialogs/adaptive-dialog.tsx
src/shared/ui/FormField.tsx
src/shared/ui/forms/adaptive-form.tsx
src/shared/ui/forms/adaptive-input.tsx
src/shared/ui/forms/adaptive-select.tsx
src/shared/ui/images/adaptive-image.tsx
src/shared/ui/InputField.tsx
src/shared/ui/layouts/responsive-container.tsx
src/shared/ui/layouts/responsive-grid.tsx
src/shared/ui/logo/ModernMinimalistLogo.tsx
src/shared/ui/navigation/adaptive-nav.tsx
src/shared/ui/navigation/adaptive-pagination.tsx
src/shared/ui/navigation/bottom-nav.tsx
src/shared/ui/navigation/Header.tsx
src/shared/ui/navigation/MobileNavItem.tsx
src/shared/ui/navigation/NavItem.tsx
src/shared/ui/navigation/UserMenu.tsx
src/shared/ui/RadioButtonField.tsx
src/shared/ui/search/adaptive-search.tsx
src/shared/ui/SelectField.tsx
src/shared/ui/sidebar/app-sidebar.tsx
src/shared/ui/sidebar/nav-main.tsx
src/shared/ui/sidebar/nav-projects.tsx
src/shared/ui/sidebar/nav-tabs.tsx
src/shared/ui/sidebar/nav-user.tsx
src/shared/ui/sidebar/sidebar-header.tsx
src/shared/ui/sidebar/SideBarLayout.tsx
src/shared/ui/tables/adaptive-table.tsx
src/shared/ui/UserCard.tsx
src/utils/password.ts
tailwind.config.ts
ts-errors-fix-summary.md
tsconfig.json
wiki/architecture/README.md
wiki/contributing/README.md
wiki/decisions/README.md
wiki/deployment/README.md
wiki/development/README.md
wiki/features/README.md
wiki/guides/advanced-patterns.md
wiki/guides/ddd-fsd-patterns.md
wiki/guides/detailed-feature-guide.md
wiki/guides/feature-implementation.md
wiki/guides/feature-specific-implementations.md
wiki/guides/feature-workflow.md
wiki/performance/README.md
wiki/README.md
wiki/security/README.md
wiki/standards/README.md
wiki/testing/README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.example">
# App Environment
NODE_ENV=development
APP_ENV=local

# Next Auth
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=your-secret-key-min-32-chars-long

# Backend API Configuration
API_BASE_URL=http://localhost:8080
API_AUTH_SECRET=your-api-auth-secret

# Frontend URLs
NEXT_PUBLIC_APP_URL=http://localhost:3000
NEXT_PUBLIC_API_URL=http://localhost:8080/api

# Security Settings
SESSION_MAX_AGE=86400
REFRESH_TOKEN_ROTATION=true
LOGIN_ATTEMPTS_LIMIT=5
LOGIN_ATTEMPTS_WINDOW=900

# Feature Flags
ENABLE_REGISTRATION=true
ENABLE_EMAIL_VERIFICATION=true
ENABLE_SOCIAL_LOGIN=false
MAINTENANCE_MODE=false

# Optional Email Configuration
# SMTP_HOST=smtp.example.com
# SMTP_PORT=587
# SMTP_USER=user@example.com
# SMTP_PASSWORD=your-smtp-password
# SMTP_FROM=noreply@example.com
</file>

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
# .env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

logs
</file>

<file path="build-errors-fix-summary.md">
# PharmacyHub - Fixed Build Errors

## Summary

Successfully fixed the remaining TypeScript build errors by implementing the following solutions:

### 1. Fixed Import Paths in Dashboard Pages

Updated imports in dashboard pages to use the feature-based structure:
- Updated `usePermissions` and `useAccess` imports to point to `@/features/rbac/hooks`
- Updated `useSession` imports to point to `@/features/auth/hooks`
- Updated `useAuth` imports to point to `@/features/auth/hooks`
- Updated component imports to use the correct feature modules

### 2. Created Missing Components for Email Verification

Added the missing `EmailVerificationView` component:
- Created the verification directory structure in the auth feature
- Implemented a comprehensive email verification component
- Connected it properly to the auth service
- Updated exports in the feature to include the verification components

### 3. Fixed Query Provider Import

Updated the QueryProvider import to use the tanstack-query-api feature:
- Changed from shared library to feature-specific implementation
- Ensured exam features continue to work correctly

### 4. Feature Exports Enhancement

Updated feature exports for better maintainability:
- Added exports to make components available at the feature level
- Maintained the proper organization within features

## Benefits

1. **Improved Feature Organization**: All functionality is now correctly organized within its respective feature
2. **Reduced Maintenance Overhead**: No bridging components or compatibility layers needed
3. **Type Safety**: All components now have proper TypeScript typing
4. **Build Success**: Resolved all webpack build errors

The application now follows a consistent feature-based architecture, making it more maintainable and easier to extend in the future.
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="docs/01-overview/README.md">
# PharmacyHub Overview

## Introduction

PharmacyHub is a comprehensive pharmacy management and licensing platform designed to streamline pharmacy operations, licensing processes, and exam preparation for pharmacists. The application provides a modern, secure, and intuitive interface for pharmacy professionals, regulatory bodies, and educational institutions.

## System Purpose

PharmacyHub serves multiple purposes:

1. **Licensing Management**: Simplifies the process of applying for and managing pharmacy licenses
2. **Professional Development**: Provides exam preparation tools for pharmacy professionals
3. **Regulatory Compliance**: Ensures pharmacies meet regulatory requirements
4. **Operational Efficiency**: Streamlines day-to-day pharmacy operations
5. **Educational Resources**: Offers learning materials for pharmacy students and professionals

## Key Stakeholders

- **Pharmacists**: Licensed professionals managing medication dispensing
- **Pharmacy Managers**: Responsible for pharmacy operations
- **Proprietors**: Pharmacy owners
- **Regulatory Bodies**: Government agencies that oversee pharmacy licensing
- **Educational Institutions**: Organizations providing pharmacy education
- **Pharmacy Staff**: Other employees working in pharmacies

## System Requirements

### Functional Requirements

1. **User Registration and Authentication**
   - Multi-role user registration
   - Secure authentication with Keycloak
   - Role-based access control

2. **Licensing Management**
   - License application submission
   - License renewal
   - Regulatory compliance tracking
   - Inspection scheduling

3. **Exam Preparation**
   - Practice tests and quizzes
   - Mock exams
   - Performance tracking
   - Study materials

4. **Pharmacy Management**
   - Staff management
   - Inventory control
   - Reporting and analytics
   - Operational workflows

### Non-Functional Requirements

1. **Security**
   - Role-based access control (RBAC)
   - Data encryption
   - Secure authentication
   - Audit logging

2. **Performance**
   - Response time < 2 seconds
   - Support for up to 10,000 concurrent users
   - 99.9% uptime

3. **Scalability**
   - Horizontal scaling capability
   - Microservices architecture
   - Cloud-native deployment

4. **Usability**
   - Intuitive user interface
   - Mobile responsiveness
   - Accessibility compliance (WCAG 2.1)

## Technical Stack

### Frontend
- **Framework**: Next.js 15 (React)
- **Language**: TypeScript
- **Styling**: Tailwind CSS
- **UI Components**: ShadCN UI
- **State Management**: Zustand, React Query
- **Testing**: Jest, React Testing Library, Playwright

### Backend
- **Framework**: Spring Boot
- **Language**: Java
- **Database**: PostgreSQL
- **API**: RESTful with OpenAPI specification
- **Authentication**: Keycloak 25.0.2
- **Message Queue**: RabbitMQ (for asynchronous processing)

### DevOps
- **Containerization**: Docker
- **Orchestration**: Kubernetes
- **CI/CD**: GitHub Actions
- **Monitoring**: Prometheus, Grafana
- **Logging**: ELK Stack

## System Architecture Overview

PharmacyHub follows a modern, scalable architecture:

1. **Frontend**: Single-Page Application (SPA) built with Next.js
2. **Backend**: Microservices built with Spring Boot
3. **Authentication**: Keycloak for identity and access management
4. **Database**: PostgreSQL for relational data
5. **Caching**: Redis for performance optimization
6. **API Gateway**: For routing and load balancing
7. **Message Queue**: For asynchronous processing

For more detailed architecture information, see the [Architecture Documentation](../02-architecture/README.md).

## Getting Started

### Prerequisites
- Node.js 18.0+
- npm 9.0+
- Docker and Docker Compose
- Java 17+ (for backend)

### Development Setup
```bash
# Clone the repository
git clone https://github.com/your-org/pharmacyhub-frontend.git

# Navigate to the project directory
cd pharmacyhub-frontend

# Install dependencies
npm install

# Set up environment variables
cp .env.example .env.local

# Start the development server
npm run dev
```

### Running with Docker
```bash
# Build and start containers
docker-compose up -d

# View logs
docker-compose logs -f
```

## Project Timeline

- **Phase 1** (Q1 2023): Core authentication and user management
- **Phase 2** (Q2 2023): Licensing management features
- **Phase 3** (Q3 2023): Exam preparation modules
- **Phase 4** (Q4 2023): Pharmacy operations management
- **Phase 5** (Q1 2024): Reporting and analytics
- **Phase 6** (Q2 2024): Mobile applications

## Additional Resources

- [Project Roadmap](./roadmap.md)
- [System Architecture](../02-architecture/README.md)
- [Feature Documentation](../04-features/README.md)
- [Development Guide](../05-development/README.md)
</file>

<file path="docs/02-architecture/architecture-details.md">
# PharmacyHub Frontend Architecture

## Overview

PharmacyHub is built using a modern, scalable architecture following Feature-Sliced Design (FSD) principles with Next.js
15. The application is designed to handle pharmacy management, licensing, and exam preparation features.

## Architectural Patterns

### 1. Feature-Sliced Design (FSD)

The application follows a layered architecture with clear boundaries:

```
/src/
├── entities/       # Business entities
├── features/       # Feature modules
├── shared/         # Shared utilities
└── app/           # Application layer (Next.js)
```

### 2. Domain-Driven Design (DDD)

- Clear separation of domain entities
- Rich domain models with business logic
- Aggregates for complex domain relationships

### 3. State Management

- Zustand for global state management
- React Query for server state management
- Local component state where appropriate

## Directory Structure

### 1. Entities Layer (/src/entities/)

Domain models and business logic:

```
/entities/
├── user/
│   ├── model.ts    # User entity definition
│   └── types.ts    # User-related types
├── pharmacy/
│   ├── model.ts    # Pharmacy entity
│   └── types.ts    # Pharmacy-related types
└── license/
    ├── model.ts    # License entity
    └── types.ts    # License-related types
```

### 2. Features Layer (/src/features/)

Feature-specific modules:

```
/features/
├── licensing/
│   ├── ui/        # Feature-specific components
│   │   ├── forms/
│   │   ├── pages/
│   │   └── components/
│   ├── model/     # Feature domain logic
│   ├── api/       # API integration
│   └── lib/       # Feature utilities
└── exams/
    ├── ui/
    ├── model/
    ├── api/
    └── lib/
```

### 3. Shared Layer (/src/shared/)

Common utilities and components:

```
/shared/
├── ui/            # Reusable UI components
├── api/           # API utilities
├── config/        # Configuration
├── lib/           # Shared utilities
└── types/         # Common types
```

### 4. App Layer (/src/app/)

Next.js app router structure:

```
/app/
├── (auth)/        # Authentication routes
├── (licensing)/   # Licensing feature routes
├── (exams)/       # Exam feature routes
└── api/           # API routes
```

## Key Features

### 1. Licensing Management

- Pharmacist registration and licensing
- Pharmacy manager management
- Proprietor management
- Salesman management
- Connection requests handling

### 2. Exam Preparation

- MCQ-based practice tests
- Mock exams
- Progress tracking
- Result analysis

## Technical Stack

### Frontend Technologies

- Next.js 15 (App Router)
- TypeScript
- Tailwind CSS
- ShadCN UI Components

### State Management

- Zustand for global state
- React Query for server state
- TanStack Table for data tables

### Testing Tools

- Jest for unit testing
- React Testing Library for component testing
- Playwright for E2E testing

## Authentication & Authorization

- JWT-based authentication
- Role-Based Access Control (RBAC)
- Protected routes and API endpoints
- OAuth2 integration

## Performance Optimizations

- Code splitting and lazy loading
- Static Site Generation (SSG)
- Incremental Static Regeneration (ISR)
- API response caching
- Image optimization

## Development Workflow

### 1. Project Structure

- Feature-based organization
- Clear separation of concerns
- Modular component design

### 2. Code Quality

- TypeScript for type safety
- ESLint for code quality
- Prettier for code formatting
- Husky for pre-commit hooks

### 3. CI/CD Pipeline

- GitHub Actions for automation
- Automated testing
- Docker containerization
- Kubernetes deployment

## Future Considerations

1. Microservices Architecture
    - Service decomposition
    - API Gateway integration
    - Message queue implementation

2. Performance Monitoring
    - Real-time analytics
    - Error tracking
    - Performance metrics

3. Scalability
    - Horizontal scaling
    - Load balancing
    - Cache optimization

## Documentation

- API documentation using Swagger/OpenAPI
- Component documentation using Storybook
- Inline code documentation
- User guides and tutorials
</file>

<file path="docs/02-architecture/logging-architecture.md">
# Logging Architecture

## Overview
This document outlines the logging architecture for the PharmacyHub Next.js application, designed to provide comprehensive logging capabilities across both frontend and API components.

## Core Components

### 1. Logger Service (`@shared/lib/logger`)
- Centralized logging service built on Winston
- Supports multiple logging levels (error, warn, info, debug)
- Provides structured logging with metadata
- Timestamp and log rotation functionality

### 2. Configuration (`@shared/config/logger`)
```typescript
interface LoggerConfig {
  level: 'error' | 'warn' | 'info' | 'debug';
  directory: string;
  maxSize: string;
  maxFiles: string;
  format: string;
}
```

### 3. Log Storage
- Location: `/logs` directory in project root
- Rotation: Daily rotation with date-based naming
- Retention: 14-day retention policy
- Maximum file size: 10MB per file

## Log Categories

1. **Application Logs**
   - System startup/shutdown
   - Configuration changes
   - Feature flags/toggles
   - Performance metrics

2. **Error Logs**
   - Unhandled exceptions
   - API failures
   - Authentication errors
   - Validation errors

3. **User Activity Logs**
   - Authentication events
   - Important user actions
   - Session management

4. **API Logs**
   - Request/Response details
   - API performance metrics
   - External service interactions

## Implementation Guidelines

### 1. Logging Levels Usage
- **ERROR**: Application errors that need immediate attention
- **WARN**: Potentially harmful situations
- **INFO**: General operational information
- **DEBUG**: Detailed information for debugging

### 2. Best Practices
- Always include contextual information
- Use structured logging format
- Avoid logging sensitive information
- Include correlation IDs for request tracing
- Use appropriate log levels

### 3. Example Usage

```typescript
// Component logging
logger.info('User action completed', {
  userId: user.id,
  action: 'exam_submission',
  timestamp: new Date()
});

// API route logging
logger.error('API error occurred', {
  path: req.path,
  method: req.method,
  statusCode: err.statusCode,
  errorMessage: err.message
});
```

## Security Considerations

1. **Data Privacy**
   - No PII in logs
   - Mask sensitive data
   - Comply with data protection regulations

2. **Access Control**
   - Restricted log file permissions
   - Secure log storage
   - Audit trail for log access

## Integration Points

1. **Application Entry Points**
   - Next.js middleware
   - API routes
   - Page components
   - Error boundaries

2. **External Services**
   - Backend API calls
   - Authentication service
   - Third-party integrations

## Required Dependencies

```json
{
  "winston": "^3.11.0",
  "winston-daily-rotate-file": "^4.7.1"
}
```

## Implementation Steps

1. Install required dependencies
2. Create logger configuration
3. Implement logger service
4. Set up log rotation
5. Create middleware for API logging
6. Add error boundary logging
7. Integrate with existing components

## Monitoring & Maintenance

1. **Log Analysis**
   - Regular log review
   - Error pattern detection
   - Performance monitoring

2. **Maintenance Tasks**
   - Log rotation verification
   - Storage space monitoring
   - Regular cleanup of old logs

## Future Enhancements

1. **Potential Improvements**
   - Centralized log aggregation
   - Real-time log streaming
   - Advanced log analytics
   - Integration with monitoring tools

2. **Scalability Considerations**
   - Distributed logging
   - Log compression
   - Log shipping to external services
</file>

<file path="docs/02-architecture/logging-implementation.md">
# PharmacyHub Logging Implementation

## Overview

PharmacyHub implements a comprehensive logging system that provides structured logging across different parts of the application. The logging system is built using Winston and provides consistent logging patterns for both frontend and API operations.

## Core Components

### 1. Logger Service (`@shared/lib/logger.ts`)
- Singleton logger instance using Winston
- Multiple log levels (error, warn, info, debug)
- File rotation with retention policies
- Structured JSON logging
- Development console output

### 2. API Logger Middleware (`@shared/lib/api-logger.ts`)
- Automatic request/response logging for API routes
- Error tracking and formatting
- Performance timing
- Route parameter logging
- Query parameter logging
- Headers logging (safe headers only)

### 3. Logging Configuration (`@shared/config/logger.ts`)
- Environment-based log levels
- File rotation settings
- Log format configuration
- Retention policies

## Feature-specific Logging

### 1. Authentication System
- Login attempts and results
- Token refresh operations
- Authentication failures
- Development fallback usage
- Health check status

### 2. Exam System
- Paper listing operations
- Exam session lifecycle
- Answer submissions
- Exam completion
- Performance metrics

### 3. Licensing System
- User listing operations
- Connection requests
- Status changes
- Entity relationships

## Log Types and Locations

### 1. API Logs (`/logs/api-%DATE%.log`)
```json
{
  "timestamp": "2024-02-21T02:00:00.000Z",
  "level": "info",
  "message": "API Request: GET /api/licensing/pharmacist",
  "method": "GET",
  "path": "/api/licensing/pharmacist",
  "params": {"type": "pharmacist"},
  "responseTime": "123ms"
}
```

### 2. Error Logs (`/logs/error-%DATE%.log`)
```json
{
  "timestamp": "2024-02-21T02:00:00.000Z",
  "level": "error",
  "message": "Authentication failed",
  "error": "Invalid credentials",
  "stack": "Error: Invalid credentials...",
  "path": "/api/auth/login"
}
```

### 3. Combined Logs (`/logs/combined-%DATE%.log`)
- Contains all log levels
- Includes application startup/shutdown
- System-wide events

## Best Practices

### 1. API Route Logging
```typescript
// Use the withApiLogger middleware
export const GET = withApiLogger(handler);
```

### 2. Service-level Logging
```typescript
logger.info('Operation description', {
  entityType: 'type',
  operationId: 'id',
  metadata: 'contextual data'
});
```

### 3. Error Logging
```typescript
try {
  // Operation
} catch (error) {
  logger.error('Operation failed', {
    error: error instanceof Error ? error.message : 'Unknown error',
    stack: error instanceof Error ? error.stack : undefined,
    context: 'additional context'
  });
}
```

### 4. Performance Logging
```typescript
const startTime = Date.now();
// Operation
logger.info('Operation completed', {
  responseTime: `${Date.now() - startTime}ms`
});
```

## Log Retention and Rotation

- Log files are rotated daily
- 14-day retention period
- 10MB maximum file size
- Compressed archives for historical logs

## Security Considerations

1. **Sensitive Data**
   - No passwords or tokens in logs
   - Masked sensitive user information
   - No complete request bodies in production

2. **Access Control**
   - Log files have restricted permissions
   - Production logs accessible only to authorized personnel

3. **Compliance**
   - GDPR-compliant logging practices
   - No PII in logs
   - Data retention policies enforced

## Monitoring and Alerts

1. **Error Monitoring**
   - All error-level logs should be monitored
   - Critical errors require immediate attention
   - Error patterns should be analyzed

2. **Performance Monitoring**
   - Response times are logged for all API calls
   - Slow operations are tagged for investigation
   - Resource usage patterns are tracked

## Development Guidelines

1. **Adding New Logs**
   - Use appropriate log levels
   - Include relevant context
   - Follow existing patterns
   - Document new log types

2. **Log Levels Usage**
   - ERROR: Application errors requiring attention
   - WARN: Potential issues or edge cases
   - INFO: Normal operation information
   - DEBUG: Detailed debugging information

3. **Context Requirements**
   - Include operation identifiers
   - Add user context when available
   - Provide timing information
   - Reference related entities

## Future Enhancements

1. **Planned Improvements**
   - Centralized log aggregation
   - Real-time log streaming
   - Advanced log analytics
   - Automated alerting system

2. **Integration Opportunities**
   - APM integration
   - Error tracking services
   - Monitoring dashboards
   - Analytics platforms
</file>

<file path="docs/02-architecture/README.md">
# PharmacyHub Architecture

## Overview

PharmacyHub implements a modern, scalable architecture following Feature-Sliced Design (FSD) principles with Next.js 15. The application architecture is designed to handle pharmacy management, licensing, and exam preparation features while maintaining high performance, security, and maintainability.

## Architectural Principles

1. **Separation of Concerns**: Clear boundaries between different parts of the application
2. **Domain-Driven Design**: Focus on the core domain model and business logic
3. **Component-Based Architecture**: Modular, reusable components
4. **Single Responsibility**: Each module has a single, well-defined purpose
5. **Progressive Enhancement**: Core functionality works without JavaScript, enhanced with JS
6. **Mobile-First Design**: Optimized for mobile devices first, then enhanced for larger screens

## Architectural Patterns

### 1. Feature-Sliced Design (FSD)

The application follows a layered architecture with clear boundaries:

```
/src/
├── entities/       # Business entities
├── features/       # Feature modules
├── shared/         # Shared utilities
└── app/            # Application layer (Next.js)
```

Key principles of FSD:
- **Namespaces**: Code is organized by business domains
- **Layers**: Code is divided into vertical layers (shared, entities, features, widgets, pages)
- **Slices**: Each layer is divided into slices (authentication, profiles, etc.)
- **Segments**: Each slice is divided into segments (ui, model, api, etc.)

### 2. Domain-Driven Design (DDD)

- **Bounded Contexts**: Clear separation between different parts of the system
- **Ubiquitous Language**: Consistent terminology throughout the codebase
- **Aggregates**: Objects that are treated as a single unit 
- **Entities**: Objects with identity that persist over time
- **Value Objects**: Objects without identity, defined by their attributes
- **Domain Services**: Business operations that don't belong to entities
- **Repositories**: Abstractions over data access

### 3. Client-Side State Management

- **Zustand**: For global application state
- **React Query**: For server state and data fetching
- **Local Component State**: For UI-specific state

## High-Level Architecture

```
┌─────────────────────────────────┐           ┌─────────────────────────┐
│         Client Application       │           │     Authentication      │
│  ┌─────────────┐ ┌─────────────┐ │           │                         │
│  │   Next.js   │ │    React    │ │           │        Keycloak         │
│  └─────────────┘ └─────────────┘ │           │                         │
│  ┌─────────────┐ ┌─────────────┐ │           └─────────────────────────┘
│  │   Zustand   │ │React Query  │ │                       │
│  └─────────────┘ └─────────────┘ │                       ▼
└────────────────┬────────────────┘           ┌─────────────────────────┐
                 │                            │     API Gateway         │
                 ▼                            │                         │
┌─────────────────────────────────┐           └────────────┬────────────┘
│         API Layer               │                        │
└────────────────┬────────────────┘                        ▼
                 │                            ┌─────────────────────────┐
                 ▼                            │   Microservices         │
┌─────────────────────────────────┐           │  ┌─────────────────┐    │
│       Backend Services           │           │  │Licensing Service│    │
│                                 │◄──────────┼──┤                 │    │
│                                 │           │  └─────────────────┘    │
└─────────────────────────────────┘           │  ┌─────────────────┐    │
                                             │  │  Exam Service   │    │
                                             │  │                 │    │
                                             │  └─────────────────┘    │
                                             │  ┌─────────────────┐    │
                                             │  │ User Service    │    │
                                             │  │                 │    │
                                             │  └─────────────────┘    │
                                             └─────────────────────────┘
```

## Directory Structure

### 1. Entities Layer (`/src/entities/`)

Domain models and business logic:

```
/entities/
├── user/
│   ├── model.ts    # User entity definition
│   └── types.ts    # User-related types
├── pharmacy/
│   ├── model.ts    # Pharmacy entity
│   └── types.ts    # Pharmacy-related types
└── license/
    ├── model.ts    # License entity
    └── types.ts    # License-related types
```

### 2. Features Layer (`/src/features/`)

Feature-specific modules:

```
/features/
├── licensing/
│   ├── ui/        # Feature-specific components
│   │   ├── forms/
│   │   ├── pages/
│   │   └── components/
│   ├── model/     # Feature domain logic
│   ├── api/       # API integration
│   └── lib/       # Feature utilities
├── exams/
│   ├── ui/
│   ├── model/
│   ├── api/
│   └── lib/
└── auth/
    ├── ui/
    │   ├── login/
    │   ├── register/
    │   └── reset-password/
    ├── model/
    └── api/
```

### 3. Shared Layer (`/src/shared/`)

Common utilities and components:

```
/shared/
├── ui/            # Reusable UI components
│   ├── button/
│   ├── input/
│   ├── modal/
│   ├── table/
│   └── layout/
├── api/           # API utilities
│   ├── client.ts
│   ├── hooks/
│   └── endpoints/
├── auth/          # Authentication utilities
│   ├── permissions.ts
│   ├── keycloakService.ts
│   └── PermissionGuard.tsx
├── config/        # Configuration
├── lib/           # Shared utilities
│   ├── validation/
│   ├── formatting/
│   └── helpers/
└── types/         # Common types
```

### 4. App Layer (`/src/app/`)

Next.js app router structure:

```
/app/
├── (auth)/        # Authentication routes
│   ├── login/
│   ├── register/
│   └── reset-password/
├── (licensing)/   # Licensing feature routes
│   ├── pharmacy/
│   ├── applications/
│   └── renewals/
├── (exams)/       # Exam feature routes
│   ├── practice/
│   ├── mock-tests/
│   └── results/
├── (dashboard)/   # Dashboard routes
│   ├── overview/
│   ├── analytics/
│   └── settings/
├── api/           # API routes
│   ├── auth/
│   ├── licensing/
│   └── exams/
└── layout.tsx     # Root layout
```

## Authentication Architecture

The authentication system is built around Keycloak 25.0.2:

```
┌─────────────────────────┐    ┌───────────────────┐    ┌─────────────────┐
│                         │    │                   │    │                 │
│    Frontend App         │    │  Identity         │    │  Spring Boot    │
│    (Next.js)            │◄───┤  Provider         ├───►│  Backend        │
│                         │    │  (Keycloak)       │    │                 │
│                         │    │                   │    │                 │
└─────────────────────────┘    └───────────────────┘    └─────────────────┘
         │                            ▲                        │
         │                            │                        │
         │                            │                        │
         │                     Token  │                        │
         │                   Validation                        │
         │                            │                        │
         ▼                            │                        ▼
┌─────────────────────────┐    ┌───────────────────┐    ┌─────────────────┐
│                         │    │                   │    │                 │
│    Auth Context         │    │  JWT Tokens       │    │  Resource       │
│    Permission Guards    │    │  - Access Token   │    │  Server         │
│                         │    │  - Refresh Token  │    │                 │
│                         │    │                   │    │                 │
└─────────────────────────┘    └───────────────────┘    └─────────────────┘
```

Key components:
1. **Keycloak Server**: Central authentication and authorization server
2. **Auth Context**: React context providing authentication state
3. **KeycloakService**: Service handling token management and API calls
4. **Permission Guards**: React components for permission-based rendering
5. **JWT Token**: Used for authentication and authorization

For more details on the authentication architecture, see the [Authentication Documentation](../03-authentication/README.md).

## State Management

### Global State (Zustand)

Zustand provides lightweight global state management:

```typescript
// Example Zustand store
import { create } from 'zustand';

interface ThemeStore {
  isDarkMode: boolean;
  toggleTheme: () => void;
}

export const useThemeStore = create<ThemeStore>((set) => ({
  isDarkMode: false,
  toggleTheme: () => set((state) => ({ isDarkMode: !state.isDarkMode })),
}));
```

### Server State (React Query)

React Query handles server-side state and caching:

```typescript
// Example React Query hooks
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { fetchPharmacies, createPharmacy } from '@/api/pharmacies';

export const usePharmacies = () => {
  return useQuery({
    queryKey: ['pharmacies'],
    queryFn: fetchPharmacies,
  });
};

export const useCreatePharmacy = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: createPharmacy,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['pharmacies'] });
    },
  });
};
```

## Performance Optimizations

### Next.js Optimizations

1. **Static Site Generation (SSG)**
   ```typescript
   // Example SSG
   export async function generateStaticParams() {
     const pharmacies = await fetchPharmacies();
     return pharmacies.map((pharmacy) => ({
       id: pharmacy.id,
     }));
   }
   ```

2. **Incremental Static Regeneration (ISR)**
   ```typescript
   // Example ISR
   export const revalidate = 3600; // Revalidate every hour
   ```

3. **Server Components**
   ```typescript
   // Example server component
   export default async function PharmacyList() {
     const pharmacies = await fetchPharmacies();
     return (
       <ul>
         {pharmacies.map((pharmacy) => (
           <li key={pharmacy.id}>{pharmacy.name}</li>
         ))}
       </ul>
     );
   }
   ```

### Additional Optimizations

1. **Code Splitting**: Automatic code splitting by route
2. **Image Optimization**: Using Next.js Image component
3. **Font Optimization**: Using Next.js Font optimization
4. **Bundle Analysis**: Regular analysis and optimization
5. **Service Worker**: For offline support and caching
6. **Memoization**: Using React.memo, useMemo, and useCallback

## Security Architecture

Security is implemented at multiple levels:

1. **Authentication**: Keycloak provides robust authentication
2. **Authorization**: Permission-based access control 
3. **Data Protection**: HTTPS, secure cookies, CSRF protection
4. **Input Validation**: Client and server-side validation
5. **API Security**: Rate limiting, CORS, authentication middleware
6. **Content Security Policy**: Preventing XSS attacks

## Deployment Architecture

The application is deployed using containerization and orchestration:

```
┌─────────────────────────┐      ┌─────────────────────────┐
│                         │      │                         │
│    CI/CD Pipeline       │      │   Container Registry    │
│    (GitHub Actions)     │      │   (Docker Hub)          │
│                         │      │                         │
└──────────┬──────────────┘      └───────────┬─────────────┘
           │                                 │
           │                                 │
           ▼                                 ▼
┌─────────────────────────────────────────────────────────┐
│                                                         │
│                  Kubernetes Cluster                     │
│                                                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │
│  │ Frontend    │  │ Backend     │  │ Keycloak    │      │
│  │ Pods        │  │ Pods        │  │ Pods        │      │
│  └─────────────┘  └─────────────┘  └─────────────┘      │
│                                                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │
│  │ Database    │  │ Redis       │  │ Monitoring  │      │
│  │ Stateful Set│  │ Cluster     │  │ Stack       │      │
│  └─────────────┘  └─────────────┘  └─────────────┘      │
│                                                         │
└─────────────────────────────────────────────────────────┘
           │                                 │
           │                                 │
           ▼                                 ▼
┌─────────────────────────┐      ┌─────────────────────────┐
│                         │      │                         │
│    Load Balancer        │      │   CDN                   │
│    (Nginx/Traefik)      │      │   (Cloudflare)          │
│                         │      │                         │
└─────────────────────────┘      └─────────────────────────┘
```

## Technical Debt Management

The project follows these practices to manage technical debt:

1. **Regular Refactoring**: Scheduled refactoring sprints
2. **Code Reviews**: Mandatory reviews before merging
3. **Test Coverage**: Maintaining high test coverage
4. **Dependency Management**: Regular updates of dependencies
5. **Architecture Reviews**: Quarterly architecture reviews
6. **Documentation**: Keeping documentation up-to-date

## Future Architecture Considerations

1. **Micro-Frontends**
   - Independent deployment of frontend modules
   - Team-specific ownership of features
   - Technology-agnostic architecture

2. **Edge Computing**
   - Moving computation closer to users
   - Reduced latency
   - Improved global performance

3. **Server Components Evolution**
   - More sophisticated SSR/SSG strategies
   - Hybrid rendering approaches
   - Streaming server components

4. **WebAssembly Integration**
   - Performance-critical components in WASM
   - Cross-language component development
   - Near-native performance for complex calculations

## Additional Architecture Documentation

- [Authentication Architecture](../03-authentication/architecture.md)
- [API Integration](./api-integration.md)
- [State Management](./state-management.md)
- [Performance Strategy](./performance.md)
- [Security Architecture](./security.md)
</file>

<file path="docs/03-authentication/01-authentication-overview.md">
# Authentication System Overview

## Introduction

The PharmacyHub frontend implements a robust authentication system using Keycloak as the Identity and Access Management (IAM) solution. This document provides a comprehensive overview of the authentication implementation.

## Authentication Architecture

### Core Components

1. **Keycloak Integration**
   - Implementation: `src/lib/auth/keycloak`
   - Configuration: `keycloak-realm/`
   - Environment Variables: `.env`

2. **Authentication Provider**
   - Location: `src/providers/AuthProvider`
   - Purpose: Manages authentication state and provides context
   - Features:
     - Token management
     - Session handling
     - Role-based access control
     - Auto-refresh mechanism

### Authentication Flow

1. **Initial Authentication**
```typescript
// src/lib/auth/keycloak/config.ts
export const keycloakConfig = {
  realm: process.env.NEXT_PUBLIC_KEYCLOAK_REALM,
  clientId: process.env.NEXT_PUBLIC_KEYCLOAK_CLIENT_ID,
  url: process.env.NEXT_PUBLIC_KEYCLOAK_URL
};
```

2. **Token Management**
```typescript
// Example token refresh implementation
const refreshToken = async () => {
  try {
    const response = await keycloak.updateToken(70);
    return response;
  } catch (error) {
    await keycloak.login();
  }
};
```

### RBAC Implementation

1. **Role Definition**
```typescript
// src/types/auth.ts
export enum UserRole {
  ADMIN = 'admin',
  PHARMACIST = 'pharmacist',
  TECHNICIAN = 'technician',
  STUDENT = 'student'
}
```

2. **Permission Guards**
```typescript
// src/components/guards/RoleGuard.tsx
export const RoleGuard: FC<RoleGuardProps> = ({
  children,
  requiredRoles
}) => {
  const { hasRoles } = useAuth();
  return hasRoles(requiredRoles) ? children : null;
};
```

## Security Measures

### Token Security
- JWT token storage in memory only
- Refresh token rotation
- Automatic token refresh before expiration
- Secure token transmission using HttpOnly cookies

### Session Management
- Configurable session timeouts
- Automatic session extension on activity
- Secure session termination
- Cross-tab session synchronization

### API Security
- Bearer token authentication
- CORS configuration
- CSP implementation
- Rate limiting

## Error Handling

### Authentication Errors
```typescript
// src/lib/auth/errors.ts
export class AuthenticationError extends Error {
  constructor(
    message: string,
    public code: string,
    public action?: () => void
  ) {
    super(message);
  }
}
```

### Error Recovery
1. Token expiration handling
2. Network error recovery
3. Session recovery
4. Invalid token handling

## Testing Strategy

### Unit Tests
- Authentication hook tests
- Guard component tests
- Token management tests
- Error handling tests

### Integration Tests
- Login flow tests
- Session management tests
- Role-based access tests
- API authentication tests

## Configuration Guide

### Environment Variables
```env
NEXT_PUBLIC_KEYCLOAK_URL=https://auth.pharmacyhub.com
NEXT_PUBLIC_KEYCLOAK_REALM=pharmacyhub
NEXT_PUBLIC_KEYCLOAK_CLIENT_ID=frontend-client
```

### Keycloak Realm Configuration
- Client configuration
- Role mapping
- Protocol mappers
- Authentication flows

## Usage Examples

### Protected Route Implementation
```typescript
// src/app/dashboard/page.tsx
export default function DashboardPage() {
  return (
    <RoleGuard requiredRoles={[UserRole.PHARMACIST]}>
      <Dashboard />
    </RoleGuard>
  );
}
```

### Authentication Hook Usage
```typescript
// Component example
const UserProfile = () => {
  const { user, isAuthenticated, logout } = useAuth();

  if (!isAuthenticated) {
    return <LoginRedirect />;
  }

  return (
    <div>
      <h1>Welcome, {user.name}</h1>
      <button onClick={logout}>Logout</button>
    </div>
  );
};
```

## Maintenance Guidelines

### Regular Tasks
1. Token signing key rotation
2. Session cleanup
3. Permission audit
4. Security patch updates

### Monitoring
1. Failed authentication attempts
2. Token refresh patterns
3. Session duration metrics
4. Role assignment changes

## Known Limitations

1. Single sign-on limitations with certain browsers
2. Token size constraints
3. Refresh token lifecycle management
4. Cross-origin authentication challenges

## Best Practices

1. Always use type-safe role checks
2. Implement
</file>

<file path="docs/03-authentication/auth-components.md">
# Authentication Components

## Overview

The PharmacyHub authentication system follows Feature-Sliced Design principles and offers a comprehensive set of user flows:

1. User Login/Logout
2. User Registration
3. Password Recovery
4. Email Verification

## Architecture

Authentication components follow the FSD architecture with clear layer separation:

```
/features/auth/
├── ui/               # User interface components
│   ├── login/
│   ├── register/
│   ├── password-recovery/
│   ├── verification/
│   └── layout/
├── model/            # Domain models and state
│   ├── types.ts
│   └── store.ts
├── api/              # API integration
│   ├── authService.ts
│   └── mutations.ts
└── lib/              # Utilities
    └── validation.ts
```

## Authentication Flows

### 1. Login Flow

The login flow supports:
- Email/password authentication
- "Remember me" functionality
- Social authentication providers (Google, Microsoft)
- Admin access mode
- Success animation on login

```typescript
// Usage example
const { login } = useAuthStore();
const loginMutation = useLogin();

// After successful authentication
login(result.token);
router.push(ROUTES.DASHBOARD);
```

### 2. Registration Flow

A multi-step registration process:
1. Account setup (email/password)
2. Personal information
3. Terms acceptance and confirmation

Features:
- Password strength visualization
- Step-by-step guidance
- Validation at each step
- Summary confirmation

### 3. Password Recovery

Two main components:
1. **Forgot Password** - Request password reset via email
2. **Reset Password** - Set new password with token validation

Features:
- Email verification
- Secure token handling
- Password strength guidance
- Multiple state handling (validating, success, error)

### 4. Email Verification

Secure email verification process:
- Automatic token validation
- Success/failure visualization
- Option to resend verification emails
- Clear guidance on next steps

## State Management

Authentication uses Zustand for global state:

```typescript
interface AuthState {
  token: string | null;
  user: User | null;
  isAuthenticated: boolean;
  login: (token: string) => void;
  logout: () => void;
  setUser: (user: User) => void;
}
```

## API Integration

Authentication components use React Query for API interactions:

```typescript
// Example mutation
export const useLogin = () => {
  return useMutation({
    mutationFn: (credentials: LoginCredentials) => 
      AuthService.login(credentials.email, credentials.password),
  });
};
```

## Key UI Components

1. **LoginForm** - Handles user authentication
2. **RegisterForm** - Multi-step registration
3. **ForgotPasswordForm** - Password recovery request
4. **ResetPasswordForm** - New password creation
5. **EmailVerificationView** - Email verification
6. **AuthLayout** - Shared layout with animated background

## Styling Approach

Authentication components use:
- ShadCN UI components
- Tailwind CSS for styling
- Consistent visual language
- Animated gradients and transitions
- Responsive design for all devices

## Security Considerations

1. **Token Management**
   - Secure token storage
   - Automatic token validation
   - Token expiration handling

2. **Password Security**
   - Strong password requirements
   - Password strength visualization
   - Secure reset process

3. **API Security**
   - Protected endpoints
   - Rate limiting
   - CSRF protection

## Future Enhancements

Planned enhancements for authentication:
1. Two-factor authentication
2. Device management
3. OAuth2 provider expansion
4. Session management improvements
</file>

<file path="docs/03-authentication/auth-flow.md">
# Authentication Flow Details

## Overview

This document describes the authentication flow in PharmacyHub, which uses JWT-based authentication with a custom backend service.

## Authentication Flows

### 1. Login Flow

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant AuthService
    participant Backend
    
    User->>Frontend: Enter credentials
    Frontend->>AuthService: login(username, password)
    AuthService->>Backend: POST /api/auth/login
    Backend->>Backend: Validate credentials
    Backend->>Backend: Generate JWT tokens
    Backend->>AuthService: Return tokens + user profile
    AuthService->>AuthService: Store tokens
    AuthService->>Frontend: Return user profile
    Frontend->>User: Show dashboard
```

### 2. Token Refresh Flow

```mermaid
sequenceDiagram
    participant AuthService
    participant Backend
    
    AuthService->>AuthService: Check token expiry
    AuthService->>Backend: POST /api/auth/token/refresh
    Backend->>Backend: Validate refresh token
    Backend->>Backend: Generate new tokens
    Backend->>AuthService: Return new tokens
    AuthService->>AuthService: Update stored tokens
```

### 3. Registration Flow

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant AuthService
    participant Backend
    
    User->>Frontend: Fill registration form
    Frontend->>AuthService: register(userData)
    AuthService->>Backend: POST /api/auth/signup
    Backend->>Backend: Validate data
    Backend->>Backend: Create user
    Backend->>AuthService: Return success
    AuthService->>Frontend: Registration complete
    Frontend->>User: Show login page
```

## Token Storage

Tokens are stored securely in the browser's localStorage:

```typescript
TOKEN_CONFIG = {
  ACCESS_TOKEN_KEY: 'pharmacyhub_access_token',
  REFRESH_TOKEN_KEY: 'pharmacyhub_refresh_token',
  TOKEN_EXPIRY_KEY: 'pharmacyhub_token_expiry',
  USER_PROFILE_KEY: 'pharmacyhub_user_profile'
}
```

## Security Measures

1. **Token Expiry**: Access tokens expire after a short period
2. **Automatic Refresh**: Tokens are automatically refreshed before expiry
3. **Secure Storage**: Tokens are stored with appropriate security measures
4. **CORS Protection**: API requests are protected by CORS policies
5. **Rate Limiting**: Login attempts are rate-limited

## Error Handling

The authentication system handles various error scenarios:

```typescript
try {
  await authService.login(username, password);
} catch (error) {
  if (error.status === 401) {
    // Invalid credentials
  } else if (error.status === 429) {
    // Rate limit exceeded
  } else {
    // Other errors
  }
}
```

## Session Management

Sessions are managed through:

1. Token-based authentication
2. Automatic token refresh
3. Session expiry tracking
4. Secure logout process

## API Endpoints

| Endpoint | Method | Description |
|----------|---------|-------------|
| /api/auth/login | POST | User login |
| /api/auth/signup | POST | User registration |
| /api/auth/logout | POST | User logout |
| /api/auth/token/refresh | POST | Refresh access token |
| /api/auth/reset-password | POST | Reset password |

## Configuration

Configure authentication behavior through environment variables:

```env
# Session Configuration
SESSION_MAX_AGE=86400 # 24 hours
REFRESH_TOKEN_ROTATION=true
LOGIN_ATTEMPTS_LIMIT=5
LOGIN_ATTEMPTS_WINDOW=900 # 15 minutes

# API Configuration
API_BASE_URL=http://localhost:8080
API_AUTH_SECRET=your-secret-here
```

## Related Documentation

- [API Documentation](../api/auth.md)
- [Security Best Practices](../security/README.md)
- [Environment Configuration](../configuration/env-vars.md)
</file>

<file path="docs/03-authentication/auth-system.md">
# Authentication System Design

## Overview
This document outlines the secure authentication system implementation using Keycloak for PharmacyHub.

## Architecture

### Components
1. **Keycloak Server**
   - Handles authentication & authorization
   - Manages user sessions
   - Provides token services
   - Implements security policies

2. **Frontend Integration (Next.js)**
   - Protected routes
   - Token management
   - User context
   - Role-based access control

3. **Backend Integration (Spring Boot)**
   - Resource server configuration
   - API protection
   - Token validation
   - Role-based endpoints

## Implementation Details

### 1. AuthContext Enhancement
```typescript
interface AuthState {
  user: {
    id: string;
    email: string;
    roles: string[];
    permissions: string[];
    profile: {
      firstName: string;
      lastName: string;
      phoneNumber?: string;
    };
  } | null;
  isAuthenticated: boolean;
  token: {
    access: string | null;
    refresh: string | null;
    expires: number;
  };
}

interface AuthContextType extends AuthState {
  login: () => Promise<void>;
  logout: () => Promise<void>;
  refreshToken: () => Promise<void>;
  hasPermission: (permission: string) => boolean;
  hasRole: (role: string) => boolean;
}
```

### 2. Security Measures

#### Token Handling
- Access tokens: 15-minute lifespan
- Refresh tokens: 24-hour lifespan with rotation
- Secure storage in HTTP-only cookies
- CSRF protection implementation

#### Session Management
```typescript
interface SessionConfig {
  maxAge: 3600,  // 1 hour
  cookieOptions: {
    httpOnly: true,
    secure: true,
    sameSite: 'strict'
  }
}
```

### 3. Role-Based Access Control (RBAC)

#### Role Hierarchy
```json
{
  "roles": {
    "SUPER_ADMIN": {
      "inherits": ["ADMIN"],
      "permissions": ["manage_system", "manage_users"]
    },
    "ADMIN": {
      "inherits": ["MANAGER"],
      "permissions": ["manage_staff", "view_reports"]
    },
    "MANAGER": {
      "inherits": ["USER"],
      "permissions": ["approve_orders", "manage_inventory"]
    },
    "USER": {
      "permissions": ["view_products", "place_orders"]
    }
  }
}
```

### 4. Protected Routes Implementation

#### Frontend Route Protection
```typescript
// Middleware configuration
export const config = {
  matcher: [
    '/dashboard/:path*',
    '/admin/:path*',
    '/profile/:path*'
  ]
};
```

#### Backend Endpoint Protection
```java
@PreAuthorize("hasRole('ADMIN') and hasAuthority('manage_users')")
@GetMapping("/admin/users")
public List<User> getUsers() {
    // Implementation
}
```

### 5. Error Handling & Security Events

#### Error Responses
```typescript
interface AuthError {
  code: string;
  message: string;
  action?: 'REFRESH_TOKEN' | 'LOGOUT' | 'RETRY';
}
```

#### Security Event Logging
- Failed login attempts
- Token refreshes
- Permission changes
- Role assignments
- Session terminations

## Security Best Practices

1. **Token Security**
   - Never store tokens in localStorage
   - Implement token refresh mechanism
   - Use secure HTTP-only cookies
   - Implement proper CORS policies

2. **API Security**
   - Rate limiting
   - Request validation
   - Error obscurity
   - Audit logging

3. **User Security**
   - Password policies
   - MFA support
   - Session management
   - Account lockout

4. **Infrastructure Security**
   - TLS everywhere
   - Security headers
   - CSRF protection
   - XSS prevention

## Implementation Steps

1. Configure Keycloak realm settings
2. Set up frontend authentication context
3. Implement protected routes
4. Configure backend security
5. Set up role-based access control
6. Implement token management
7. Add security headers and CORS
8. Set up logging and monitoring

## Development Guidelines

1. **Security First**
   - Always validate tokens
   - Implement proper error handling
   - Use secure communication channels
   - Regular security audits

2. **Code Organization**
   - Separate auth logic
   - Clear security boundaries
   - Consistent error handling
   - Comprehensive logging

3. **Testing Requirements**
   - Unit tests for auth logic
   - Integration tests for flows
   - Security penetration tests
   - Performance testing

## Monitoring & Maintenance

1. **Security Monitoring**
   - Failed authentication attempts
   - Token usage patterns
   - Role changes
   - Access patterns

2. **Regular Updates**
   - Security patches
   - Dependency updates
   - Policy reviews
   - Access audits
</file>

<file path="docs/03-authentication/developer-permission-guide.md">
# PharmacyHub Developer Permission Guide

## Introduction

This guide provides practical instructions for developers implementing permission-based access control in PharmacyHub components. Following these guidelines ensures consistent security enforcement and maintainable code.

## Table of Contents
1. [Getting Started](#getting-started)
2. [Frontend Implementation](#frontend-implementation)
3. [Backend Implementation](#backend-implementation)
4. [Testing Permission Logic](#testing-permission-logic)
5. [Common Patterns](#common-patterns)
6. [Best Practices](#best-practices)
7. [Troubleshooting](#troubleshooting)

## Getting Started

### Prerequisites
- Basic understanding of React hooks and components
- Familiarity with Next.js routing
- Knowledge of JWT authentication

### Key Files and Locations

```
/src/
├── shared/
│   └── auth/
│       ├── index.ts                  # Main export file
│       ├── permissions.ts            # Permission constants
│       ├── AuthContext.tsx           # Authentication context
│       ├── keycloakService.ts        # Keycloak integration
│       └── PermissionGuard.tsx       # Permission guard components
└── app/
    └── api/
        └── auth/
            └── [...nextauth]/        # Next Auth configuration
```

### Import Statements

Always import permissions and guard components from the central module:

```typescript
import { 
  PERMISSIONS,
  PermissionGuard,
  RoleGuard,
  usePermission,
  useRole
} from '@/shared/auth';
```

## Frontend Implementation

### Basic Permission Check

Use the `usePermission` hook for basic permission checks:

```tsx
import { usePermission, PERMISSIONS } from '@/shared/auth';

const MyComponent = () => {
  const { canAccess, loading } = usePermission(PERMISSIONS.PHARMACY.CREATE);
  
  if (loading) return <LoadingSpinner />;
  
  return (
    <div>
      {canAccess ? (
        <CreatePharmacyForm />
      ) : (
        <p>You don't have permission to create pharmacies.</p>
      )}
    </div>
  );
};
```

### Permission Guards

Use guard components to conditionally render UI based on permissions:

```tsx
import { PermissionGuard, PERMISSIONS } from '@/shared/auth';

const Dashboard = () => {
  return (
    <div>
      <h1>Dashboard</h1>
      
      {/* Only shown to users with create:pharmacy permission */}
      <PermissionGuard 
        permission={PERMISSIONS.PHARMACY.CREATE}
        fallback={<p>You need pharmacy creation permission</p>}
      >
        <CreatePharmacySection />
      </PermissionGuard>
      
      {/* Only shown to users with any of these permissions */}
      <AnyPermissionGuard
        permissions={[
          PERMISSIONS.PHARMACY.EDIT,
          PERMISSIONS.PHARMACY.MANAGE
        ]}
      >
        <ManagePharmaciesSection />
      </AnyPermissionGuard>
      
      {/* Only shown to users with both permissions */}
      <AllPermissionsGuard
        permissions={[
          PERMISSIONS.REPORTS.VIEW,
          PERMISSIONS.PHARMACY.VIEW
        ]}
      >
        <PharmacyReportsSection />
      </AllPermissionsGuard>
    </div>
  );
};
```

### Role-Based Guards

Use role guards for broader access control:

```tsx
import { RoleGuard } from '@/shared/auth';

const AdminArea = () => {
  return (
    <RoleGuard
      role="ADMIN"
      fallback={<AccessDeniedPage />}
    >
      <AdminDashboard />
    </RoleGuard>
  );
};
```

### Handling Multiple Permissions

For complex permission logic, combine hooks with custom logic:

```tsx
import { usePermission, PERMISSIONS } from '@/shared/auth';

const ComplexPermissionComponent = () => {
  const { canAccess: canCreate } = usePermission(PERMISSIONS.PHARMACY.CREATE);
  const { canAccess: canApprove } = usePermission(PERMISSIONS.PHARMACY.APPROVE);
  const { canAccess: canView } = usePermission(PERMISSIONS.REPORTS.VIEW);
  
  // Custom business logic combining permissions
  const canAccessAdvancedFeatures = (canCreate && canView) || canApprove;
  
  return (
    <div>
      {canAccessAdvancedFeatures && <AdvancedFeatures />}
    </div>
  );
};
```

### UI Element Disabling

Disable UI elements rather than hiding them when appropriate:

```tsx
import { usePermission, PERMISSIONS } from '@/shared/auth';

const ActionButtons = ({ pharmacyId }) => {
  const { canAccess: canEdit } = usePermission(PERMISSIONS.PHARMACY.EDIT);
  const { canAccess: canDelete } = usePermission(PERMISSIONS.PHARMACY.DELETE);
  
  return (
    <div className="button-group">
      <Button
        onClick={() => editPharmacy(pharmacyId)}
        disabled={!canEdit}
        title={!canEdit ? "You don't have permission to edit" : ""}
      >
        Edit
      </Button>
      
      <Button
        onClick={() => deletePharmacy(pharmacyId)}
        disabled={!canDelete}
        title={!canDelete ? "You don't have permission to delete" : ""}
      >
        Delete
      </Button>
    </div>
  );
};
```

### Route Protection

Protect routes with the Next.js middleware:

```typescript
// src/middleware.ts
import { NextRequest, NextResponse } from 'next/server';
import { verifyAuth } from '@/lib/auth';
import { PERMISSIONS } from '@/shared/auth/permissions';

const PERMISSION_ROUTES = {
  '/admin': { requiredRole: 'ADMIN' },
  '/pharmacy/new': { requiredPermission: PERMISSIONS.PHARMACY.CREATE },
  '/reports': { requiredPermission: PERMISSIONS.REPORTS.VIEW },
};

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  // Check route permissions
  for (const [route, requirements] of Object.entries(PERMISSION_ROUTES)) {
    if (pathname.startsWith(route)) {
      const auth = await verifyAuth(request);
      
      if (!auth.isAuthenticated) {
        return redirectToLogin(request);
      }
      
      if (requirements.requiredRole && !auth.hasRole(requirements.requiredRole)) {
        return redirectToAccessDenied(request);
      }
      
      if (requirements.requiredPermission && 
          !auth.hasPermission(requirements.requiredPermission)) {
        return redirectToAccessDenied(request);
      }
    }
  }
  
  return NextResponse.next();
}
```

## Backend Implementation

### Spring Security Configuration

Configure Spring Security to use JWT and check permissions:

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .oauth2ResourceServer(oauth2 -> oauth2.jwt(
                jwt -> jwt.jwtAuthenticationConverter(jwtAuthConverter())
            ))
            .authorizeHttpRequests(authorize -> authorize
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/api/pharmacies").hasAuthority("view:pharmacy")
                .requestMatchers("/api/pharmacies/create").hasAuthority("create:pharmacy")
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            );
        return http.build();
    }
    
    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        grantedAuthoritiesConverter.setAuthoritiesClaimName("permissions");
        grantedAuthoritiesConverter.setAuthorityPrefix("");
        
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);
        return jwtAuthenticationConverter;
    }
}
```

### Method-Level Security

Use Spring method security annotations:

```java
@RestController
@RequestMapping("/api/pharmacies")
public class PharmacyController {

    @GetMapping
    @PreAuthorize("hasAuthority('view:pharmacy')")
    public List<PharmacyDTO> getAllPharmacies() {
        // Implementation
    }
    
    @PostMapping
    @PreAuthorize("hasAuthority('create:pharmacy')")
    public PharmacyDTO createPharmacy(@RequestBody PharmacyRequest request) {
        // Implementation
    }
    
    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('edit:pharmacy')")
    public PharmacyDTO updatePharmacy(@PathVariable Long id, @RequestBody PharmacyRequest request) {
        // Implementation
    }
    
    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('delete:pharmacy')")
    public void deletePharmacy(@PathVariable Long id) {
        // Implementation
    }
}
```

### Custom Permission Evaluation

For complex permission logic, use SpEL expressions:

```java
@Service
public class PharmacyService {

    @PreAuthorize("hasAuthority('view:pharmacy') or @pharmacyPermissionEvaluator.isOwner(#pharmacyId, principal)")
    public PharmacyDTO getPharmacyById(Long pharmacyId) {
        // Implementation
    }
    
    @PreAuthorize("(hasAuthority('manage:pharmacy') and @pharmacyPermissionEvaluator.isInSameRegion(#pharmacyId, principal)) " +
                 "or hasAuthority('admin:pharmacy')")
    public void approvePharmacy(Long pharmacyId) {
        // Implementation
    }
}
```

### Permission Evaluator

Create custom permission evaluators for business-specific logic:

```java
@Component
public class PharmacyPermissionEvaluator {

    private final PharmacyRepository pharmacyRepository;
    private final UserRepository userRepository;
    
    // Constructor injection...
    
    public boolean isOwner(Long pharmacyId, Authentication authentication) {
        String userId = ((KeycloakPrincipal) authentication.getPrincipal()).getName();
        Pharmacy pharmacy = pharmacyRepository.findById(pharmacyId).orElse(null);
        
        if (pharmacy == null) {
            return false;
        }
        
        return pharmacy.getOwnerId().equals(userId);
    }
    
    public boolean isInSameRegion(Long pharmacyId, Authentication authentication) {
        String userId = ((KeycloakPrincipal) authentication.getPrincipal()).getName();
        User user = userRepository.findById(userId).orElse(null);
        Pharmacy pharmacy = pharmacyRepository.findById(pharmacyId).orElse(null);
        
        if (user == null || pharmacy == null) {
            return false;
        }
        
        return user.getRegionId().equals(pharmacy.getRegionId());
    }
}
```

## Testing Permission Logic

### Frontend Testing

Test permission guards with mock authentication context:

```typescript
// AuthContext.test.tsx
import { render, screen } from '@testing-library/react';
import { AuthProvider } from '@/shared/auth/AuthContext';
import { PermissionGuard, PERMISSIONS } from '@/shared/auth';

// Mock Keycloak service
jest.mock('@/shared/auth/keycloakService', () => ({
  keycloakService: {
    hasPermission: jest.fn(),
    hasRole: jest.fn(),
    // other methods...
  }
}));

describe('PermissionGuard', () => {
  it('renders children when user has permission', async () => {
    // Setup mock implementation
    keycloakService.hasPermission.mockResolvedValue(true);
    
    render(
      <AuthProvider>
        <PermissionGuard permission={PERMISSIONS.PHARMACY.CREATE}>
          <div data-testid="protected-content">Protected Content</div>
        </PermissionGuard>
      </AuthProvider>
    );
    
    // Wait for async permission check
    const content = await screen.findByTestId('protected-content');
    expect(content).toBeInTheDocument();
  });
  
  it('renders fallback when user lacks permission', async () => {
    // Setup mock implementation
    keycloakService.hasPermission.mockResolvedValue(false);
    
    render(
      <AuthProvider>
        <PermissionGuard 
          permission={PERMISSIONS.PHARMACY.CREATE}
          fallback={<div data-testid="fallback-content">Access Denied</div>}
        >
          <div data-testid="protected-content">Protected Content</div>
        </PermissionGuard>
      </AuthProvider>
    );
    
    // Wait for async permission check
    const fallback = await screen.findByTestId('fallback-content');
    expect(fallback).toBeInTheDocument();
    expect(screen.queryByTestId('protected-content')).not.toBeInTheDocument();
  });
});
```

### Backend Testing

Test method security with Spring Security test helpers:

```java
@WebMvcTest(PharmacyController.class)
@Import(SecurityConfig.class)
public class PharmacyControllerTest {

    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private PharmacyService pharmacyService;
    
    @Test
    @WithMockUser(authorities = "view:pharmacy")
    public void getAllPharmacies_WithViewPermission_ReturnsPharmacies() throws Exception {
        // Given
        when(pharmacyService.getAllPharmacies()).thenReturn(List.of(new PharmacyDTO()));
        
        // When/Then
        mockMvc.perform(get("/api/pharmacies"))
               .andExpect(status().isOk());
    }
    
    @Test
    @WithMockUser(authorities = "wrong:permission")
    public void getAllPharmacies_WithoutViewPermission_ReturnsForbidden() throws Exception {
        // When/Then
        mockMvc.perform(get("/api/pharmacies"))
               .andExpect(status().isForbidden());
    }
    
    @Test
    @WithMockUser(authorities = "create:pharmacy")
    public void createPharmacy_WithCreatePermission_ReturnsCreated() throws Exception {
        // Given
        PharmacyRequest request = new PharmacyRequest();
        request.setName("Test Pharmacy");
        
        when(pharmacyService.createPharmacy(any())).thenReturn(new PharmacyDTO());
        
        // When/Then
        mockMvc.perform(post("/api/pharmacies")
               .contentType(MediaType.APPLICATION_JSON)
               .content(new ObjectMapper().writeValueAsString(request)))
               .andExpect(status().isCreated());
    }
}
```

## Common Patterns

### Feature Flag with Permissions

Combine feature flags with permissions:

```tsx
import { usePermission, PERMISSIONS } from '@/shared/auth';
import { useFeatureFlag } from '@/shared/features';

const NewFeatureComponent = () => {
  const { canAccess } = usePermission(PERMISSIONS.PHARMACY.CREATE);
  const { isEnabled: betaFeaturesEnabled } = useFeatureFlag('BETA_FEATURES');
  
  const showNewFeature = canAccess && betaFeaturesEnabled;
  
  return (
    <div>
      {showNewFeature && <NewFeatureUI />}
    </div>
  );
};
```

### Contextual Permissions

Handle permissions based on data context:

```tsx
import { usePermission, PERMISSIONS } from '@/shared/auth';

const PharmacyActions = ({ pharmacy }) => {
  const { canAccess: canEdit } = usePermission(PERMISSIONS.PHARMACY.EDIT);
  const { canAccess: canManage } = usePermission(PERMISSIONS.PHARMACY.MANAGE);
  const { user } = useAuth();
  
  // Contextual permission - user can edit their own pharmacies
  const isOwner = pharmacy.ownerId === user?.id;
  const canEditThisPharmacy = canEdit || (isOwner && pharmacy.status !== 'APPROVED');
  
  return (
    <div>
      <Button 
        disabled={!canEditThisPharmacy}
        onClick={() => editPharmacy(pharmacy.id)}
      >
        Edit
      </Button>
      
      {canManage && pharmacy.status === 'PENDING' && (
        <Button onClick={() => approvePharmacy(pharmacy.id)}>
          Approve
        </Button>
      )}
    </div>
  );
};
```

### Permission Inheritance

Leverage role inheritance for cleaner code:

```tsx
import { RoleGuard } from '@/shared/auth';

// Since ADMIN inherits from MANAGER, this will allow both roles
const ManagementArea = () => {
  return (
    <RoleGuard role="MANAGER">
      <h1>Management Dashboard</h1>
      <ManagementTools />
      
      {/* No need for extra guards - role inheritance handles this */}
      <AdminOnlySection />
    </RoleGuard>
  );
};

// This component internally checks for ADMIN role
const AdminOnlySection = () => {
  const { hasRole } = useAuth();
  const isAdmin = hasRole('ADMIN');
  
  return isAdmin ? <AdminTools /> : null;
};
```

## Best Practices

### 1. Use Constants for Permissions

Always use the centralized permission constants:

```typescript
// CORRECT
import { PERMISSIONS } from '@/shared/auth';
const hasAccess = await hasPermission(PERMISSIONS.PHARMACY.CREATE);

// INCORRECT - avoid hardcoded strings
const hasAccess = await hasPermission('create:pharmacy');
```

### 2. Follow Principle of Least Privilege

Start with minimal permissions and add as needed:

```typescript
// Incorrect: Using broader permission than needed
<PermissionGuard permission={PERMISSIONS.PHARMACY.MANAGE}>
  <ViewPharmacyDetails pharmacyId={id} />
</PermissionGuard>

// Correct: Using specific permission
<PermissionGuard permission={PERMISSIONS.PHARMACY.VIEW}>
  <ViewPharmacyDetails pharmacyId={id} />
</PermissionGuard>
```

### 3. Graceful Degradation

Provide fallbacks and partial functionality:

```tsx
<PermissionGuard 
  permission={PERMISSIONS.REPORTS.MANAGE}
  fallback={
    <PermissionGuard 
      permission={PERMISSIONS.REPORTS.VIEW}
      fallback={<AccessDeniedMessage feature="reports" />}
    >
      <ReadOnlyReports />
    </PermissionGuard>
  }
>
  <FullReportDashboard />
</PermissionGuard>
```

### 4. Permission Documentation

Document permissions in component JSDocs:

```tsx
/**
 * Pharmacy management component
 * 
 * Required permissions:
 * - PERMISSIONS.PHARMACY.VIEW (base functionality)
 * - PERMISSIONS.PHARMACY.EDIT (to modify pharmacy details)
 * - PERMISSIONS.PHARMACY.DELETE (to remove pharmacies)
 */
const PharmacyManagement = () => {
  // Implementation
};
```

### 5. Error Handling

Provide clear feedback for permission errors:

```tsx
const PharmacyActions = () => {
  const { hasPermission } = useAuth();
  
  const handleDelete = async (id) => {
    try {
      await deletePharmacy(id);
    } catch (error) {
      if (error.code === 'PERMISSION_DENIED') {
        toast.error(
          "You don't have permission to delete this pharmacy. " +
          "Please contact your administrator if you need this access."
        );
      } else {
        toast.error("Failed to delete pharmacy");
      }
    }
  };
  
  // Implementation
};
```

## Troubleshooting

### Permission Not Working

If permission checks aren't working as expected:

1. **Verify Token Content**:
   ```typescript
   // Debug token content
   const token = localStorage.getItem('pharmacyhub_access_token');
   const decoded = JSON.parse(atob(token.split('.')[1]));
   console.log('Token permissions:', decoded.permissions);
   console.log('Token roles:', decoded.roles);
   ```

2. **Check Keycloak Configuration**:
   - Ensure role attributes contain the correct permissions
   - Verify protocol mappers are configured correctly
   - Check that token includes permissions claim

3. **Permission Guard Debugging**:
   ```typescript
   <PermissionGuard
     permission={PERMISSIONS.PHARMACY.CREATE}
     fallback={<div>Missing Permission: {PERMISSIONS.PHARMACY.CREATE}</div>}
   >
     <CreatePharmacyForm />
   </PermissionGuard>
   ```

### Role Inheritance Issues

If role inheritance doesn't work as expected:

1. **Verify Keycloak Role Composition**:
   - Check composite roles in Keycloak admin console
   - Ensure parent roles properly include child roles

2. **Test Individual Roles**:
   ```typescript
   // Test each role individually
   const { hasRole } = useAuth();
   const isAdmin = await hasRole('ADMIN');
   const isManager = await hasRole('MANAGER');
   console.log({ isAdmin, isManager });
   ```

### Token Refresh Problems

If users are unexpectedly logged out:

1. **Monitor Token Expiration**:
   ```typescript
   // Debug token expiration
   const expiry = localStorage.getItem('pharmacyhub_token_expiry');
   const remainingTime = parseInt(expiry) - Date.now();
   console.log('Token expires in:', remainingTime / 1000, 'seconds');
   ```

2. **Check Refresh Logic**:
   - Ensure refresh token is properly stored
   - Verify refresh token hasn't expired
   - Check network requests for token refresh calls

### Backend Permission Denial

If backend denies access unexpectedly:

1. **Inspect Request Headers**:
   - Verify Authorization header is correctly formatted
   - Check that token is not expired or malformed

2. **Review Spring Security Logs**:
   - Enable debug logging for Spring Security
   - Look for access denied reasons in logs

3. **Test with Direct API Calls**:
   ```bash
   # Test API directly with token
   curl -H "Authorization: Bearer $TOKEN" http://localhost:8080/api/pharmacies
   ```
</file>

<file path="docs/03-authentication/permission-system.md">
# PharmacyHub Permission System

## Overview

The PharmacyHub permission system provides a centralized, type-safe approach to access control. It integrates with Keycloak to enforce a hierarchical permission model across both frontend and backend components.

## Table of Contents

1. [Design Principles](#design-principles)
2. [Permission Structure](#permission-structure)
3. [Hierarchical Model](#hierarchical-model)
4. [Implementation Details](#implementation-details)
5. [Usage Examples](#usage-examples)
6. [Security Considerations](#security-considerations)
7. [Maintenance Guidelines](#maintenance-guidelines)

## Design Principles

The permission system follows these core principles:

1. **Single Source of Truth**: All permissions are defined in one central location
2. **Type Safety**: TypeScript ensures compile-time validation of permission strings
3. **Hierarchical Organization**: Permissions follow a logical group > role > permission hierarchy
4. **Separation of Concerns**: Authentication logic is separate from permission logic
5. **Scalability**: Easy to add new permissions without changing existing code
6. **Maintainability**: Clear organization making future modifications straightforward

## Permission Structure

### Permission Format

Permissions follow a `domain:action` format:
- `domain` - The resource or feature area (e.g., `pharmacy`, `user`, `exam`)
- `action` - The specific operation (e.g., `create`, `view`, `manage`)

Examples:
- `pharmacy:create` - Permission to create new pharmacies
- `users:manage` - Permission to manage user accounts
- `inventory:view` - Permission to view inventory items

### Permission Categories

Permissions are organized into logical categories:

```typescript
export const PERMISSIONS = {
  // System-level permissions
  SYSTEM: {
    MANAGE: 'manage:system',
    AUDIT: 'audit:system',
    SECURITY: 'manage:security',
  },
  
  // User management permissions
  USER: {
    MANAGE: 'manage:users',
    VIEW: 'view:users',
    PROFILE: 'manage:profile',
  },
  
  // Role management permissions
  ROLE: {
    MANAGE: 'manage:roles',
  },
  
  // Pharmacy-related permissions
  PHARMACY: {
    CREATE: 'create:pharmacy',
    EDIT: 'edit:pharmacy',
    DELETE: 'delete:pharmacy',
    VIEW: 'view:pharmacy',
    APPROVE: 'approve:pharmacy',
    OWN: 'own:pharmacy',
    MANAGE: 'manage:pharmacy',
  },
  
  // ... additional categories ...
}
```

## Hierarchical Model

### Groups > Roles > Permissions

The system follows a three-level hierarchy:

1. **Groups** contain users with similar functions
   - Example: `/Pharmacy Staff/Pharmacists`

2. **Roles** define sets of responsibilities
   - Example: `PHARMACIST`

3. **Permissions** grant specific actions
   - Example: `create:pharmacy`

### Role Inheritance

Roles can inherit permissions from other roles:

```
SUPER_ADMIN
 └── ADMIN
      └── MANAGER
           └── USER
```

In this example:
- `SUPER_ADMIN` inherits all permissions from `ADMIN`
- `ADMIN` inherits all permissions from `MANAGER`
- `MANAGER` inherits all permissions from `USER`

### Permission Mapping

Roles map to specific permission sets:

```typescript
export const ROLE_PERMISSIONS = {
  SUPER_ADMIN: [
    ...Object.values(PERMISSIONS.SYSTEM),
    ...Object.values(PERMISSIONS.USER),
    // ...
  ],
  
  ADMIN: [
    PERMISSIONS.USER.MANAGE,
    PERMISSIONS.USER.VIEW,
    PERMISSIONS.ROLE.MANAGE,
    // ...
  ],
  
  // ... additional role mappings ...
}
```

### User Type Mapping

User types map to roles and permissions:

```typescript
export const USER_TYPE_PERMISSIONS = {
  PHARMACIST: ROLE_PERMISSIONS.PHARMACIST,
  PROPRIETOR: ROLE_PERMISSIONS.PROPRIETOR,
  // ... additional user types ...
}
```

## Implementation Details

### Central Permission File

The centralized permission definitions are in `src/shared/auth/permissions.ts`:

```typescript
// Permissions
export const PERMISSIONS = { ... };

// Role to permission mapping
export const ROLE_PERMISSIONS = { ... };

// User type to permission mapping
export const USER_TYPE_PERMISSIONS = { ... };

// Group paths
export const GROUP_PATHS = { ... };

// Helper types for type safety
export type Permission = typeof PERMISSIONS[keyof typeof PERMISSIONS][keyof typeof PERMISSIONS[keyof typeof PERMISSIONS]];
export type Role = keyof typeof ROLE_PERMISSIONS;
export type UserType = keyof typeof USER_TYPE_PERMISSIONS;
export type GroupPath = typeof GROUP_PATHS[keyof typeof GROUP_PATHS];
```

### Keycloak Integration

Permissions are stored in Keycloak:

1. **Role Attributes**: Roles contain permission arrays
   ```json
   {
     "name": "PHARMACIST",
     "attributes": {
       "permissions": [
         "create:pharmacy",
         "edit:pharmacy",
         "view:pharmacy",
         "manage:inventory",
         "take:exams",
         "view:certification"
       ]
     }
   }
   ```

2. **Group Attributes**: Groups inherit permissions
   ```json
   {
     "name": "Pharmacists",
     "path": "/Pharmacy Staff/Pharmacists",
     "attributes": {
       "permissions": [
         "create:pharmacy",
         "edit:pharmacy",
         "view:pharmacy",
         "manage:inventory",
         "take:exams",
         "view:certification"
       ]
     },
     "realmRoles": ["PHARMACIST"]
   }
   ```

3. **Token Claims**: Permissions are included in tokens
   ```json
   {
     "sub": "user-123",
     "roles": ["PHARMACIST"],
     "permissions": [
       "create:pharmacy",
       "edit:pharmacy",
       "view:pharmacy",
       "manage:inventory",
       "take:exams",
       "view:certification"
     ],
     "groups": ["/Pharmacy Staff/Pharmacists"]
   }
   ```

### Permission Checking

Authentication context provides permission checking:

```typescript
const { hasPermission, hasRole } = useAuth();

// Check single permission
const canCreatePharmacy = await hasPermission(PERMISSIONS.PHARMACY.CREATE);

// Check role
const isPharmacist = await hasRole('PHARMACIST');
```

### Guard Components

React components for conditional rendering:

```typescript
// Single permission guard
<PermissionGuard 
  permission={PERMISSIONS.PHARMACY.CREATE}
  fallback={<AccessDeniedMessage />}
>
  <CreatePharmacyForm />
</PermissionGuard>

// Multiple permission guard (any)
<AnyPermissionGuard
  permissions={[PERMISSIONS.PHARMACY.EDIT, PERMISSIONS.PHARMACY.OWN]}
  fallback={<AccessDeniedMessage />}
>
  <EditPharmacyForm />
</AnyPermissionGuard>

// Role guard
<RoleGuard
  role="ADMIN"
  fallback={<AccessDeniedMessage />}
>
  <AdminDashboard />
</RoleGuard>
```

## Usage Examples

### Frontend Components

```tsx
import { 
  PermissionGuard, 
  PERMISSIONS 
} from '@/shared/auth';

// Dashboard.tsx
export default function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      
      {/* Only visible to pharmacy creators */}
      <PermissionGuard permission={PERMISSIONS.PHARMACY.CREATE}>
        <section>
          <h2>Create New Pharmacy</h2>
          <CreatePharmacyButton />
        </section>
      </PermissionGuard>
      
      {/* Only visible to inventory managers */}
      <PermissionGuard permission={PERMISSIONS.INVENTORY.MANAGE}>
        <section>
          <h2>Inventory Management</h2>
          <InventoryManagementPanel />
        </section>
      </PermissionGuard>
    </div>
  );
}
```

### Custom Hooks

```tsx
import { usePermission, PERMISSIONS } from '@/shared/auth';

// PharmacyActions.tsx
export default function PharmacyActions({ pharmacyId }) {
  const { canAccess: canEdit } = usePermission(PERMISSIONS.PHARMACY.EDIT);
  const { canAccess: canDelete } = usePermission(PERMISSIONS.PHARMACY.DELETE);
  
  return (
    <div className="actions">
      {canEdit && (
        <button onClick={() => editPharmacy(pharmacyId)}>
          Edit
        </button>
      )}
      
      {canDelete && (
        <button onClick={() => deletePharmacy(pharmacyId)}>
          Delete
        </button>
      )}
    </div>
  );
}
```

### Backend Integration

Spring Security configuration:

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .oauth2ResourceServer(oauth2 -> oauth2.jwt())
            .authorizeHttpRequests(authorize -> authorize
                .requestMatchers("/api/pharmacies/create").hasAuthority("create:pharmacy")
                .requestMatchers("/api/pharmacies/*/edit").hasAuthority("edit:pharmacy")
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                // ...
                .anyRequest().authenticated()
            );
        return http.build();
    }
}
```

## Security Considerations

### Token-Based Permission Verification

Permission claims in JWTs must be verified:

1. **Frontend**: Permissions are extracted from tokens and cached
2. **Backend**: JWT signature is verified before trusting permission claims
3. **Refresh**: Permissions are updated when tokens are refreshed

### Permission Elevation Prevention

Measures to prevent permission elevation:

1. **Read-only Permission Lists**: Permission constants are immutable
2. **Server-side Verification**: Backend independently verifies permissions
3. **Token Signing**: Keycloak signs tokens to prevent tampering

### Least Privilege Principle

The system enforces least privilege:

1. **Default User Role**: New users get minimal permissions
2. **Explicit Grants**: Permissions must be explicitly assigned
3. **Fine-grained Control**: Permissions are specific rather than broad

## Maintenance Guidelines

### Adding New Permissions

To add a new permission:

1. Add the permission to the `PERMISSIONS` object in appropriate category
2. Update `ROLE_PERMISSIONS` mappings for affected roles
3. Update Keycloak realm configuration with new permission
4. Deploy updated realm configuration

Example:
```typescript
// Adding a new permission
PERMISSIONS.PHARMACY.TRANSFER = 'transfer:pharmacy';

// Updating role mappings
ROLE_PERMISSIONS.ADMIN.push(PERMISSIONS.PHARMACY.TRANSFER);
ROLE_PERMISSIONS.MANAGER.push(PERMISSIONS.PHARMACY.TRANSFER);
```

### Adding New Roles

To add a new role:

1. Add role to `ROLE_PERMISSIONS` with appropriate permissions
2. Update Keycloak realm configuration with new role
3. Create appropriate groups if needed
4. Update registration flow if needed

Example:
```typescript
// Adding a new role
ROLE_PERMISSIONS.AUDITOR = [
  PERMISSIONS.PHARMACY.VIEW,
  PERMISSIONS.REPORTS.VIEW,
  PERMISSIONS.SYSTEM.AUDIT
];

// Adding group path
GROUP_PATHS.AUDITOR = '/System Administration/Auditors';
```

### Permission Auditing

Regular permission auditing should:

1. Verify permission consistency between code and Keycloak
2. Review permission assignments for appropriateness
3. Check for unused or redundant permissions
4. Ensure new features have proper permission checks

### Evolution Strategy

As the application evolves:

1. Prefer adding new permissions over modifying existing ones
2. Use permission categories to keep organization clean
3. Document permission changes in version control
4. Run security reviews when permission structure changes
</file>

<file path="docs/03-authentication/README.md">
# Authentication Module Documentation

## Overview

PharmacyHub implements a robust authentication system using JWT tokens and a custom backend authentication service. The authentication flow is designed to be secure, scalable, and maintainable.

## Table of Contents

1. [Authentication Flow](#authentication-flow)
2. [Auth Service](#auth-service)
3. [Permission System](#permission-system)

## Authentication Flow

1. User submits credentials through login form
2. Credentials are sent to backend auth endpoint
3. Backend validates and returns JWT tokens
4. Frontend stores tokens securely
5. Subsequent requests include token in Authorization header
6. Token refresh happens automatically when needed

## Auth Service

The authentication service provides a centralized way to handle all auth-related operations:

```typescript
// Usage example
import { authService } from '@/shared/auth';

// Login
const userProfile = await authService.login(username, password);

// Check authentication status
const isLoggedIn = authService.isAuthenticated();

// Get current token
const token = localStorage.getItem(TOKEN_CONFIG.ACCESS_TOKEN_KEY);
```

### Key Features

- JWT token management
- Automatic token refresh
- Secure token storage
- Permission-based access control
- Session management

## Permission System

Permissions are managed through a role-based access control (RBAC) system:

```typescript
// Check if user has specific permission
const hasPermission = await authService.hasPermission('create:pharmacy');
console.log('Can create pharmacy:', hasPermission);

// Check if user has role
const hasRole = await authService.hasRole('PHARMACIST');
console.log('Is pharmacist:', hasRole);
```

### Permission Guards

Use permission guards to protect routes and components:

```typescript
import { PermissionGuard } from '@/shared/auth';

function ProtectedComponent() {
  return (
    <PermissionGuard permission="create:pharmacy">
      <CreatePharmacyForm />
    </PermissionGuard>
  );
}
```

## Configuration

Auth-related configuration is managed through environment variables:

```env
# Auth Configuration
API_BASE_URL=http://localhost:8080
API_AUTH_SECRET=your-secret-here
NEXTAUTH_SECRET=your-nextauth-secret
NEXTAUTH_URL=http://localhost:3000

# Security Settings
SESSION_MAX_AGE=86400
REFRESH_TOKEN_ROTATION=true
LOGIN_ATTEMPTS_LIMIT=5
```

## Related Documentation

- [Permission System Architecture](./permission-system.md)
- [Authentication Flow Details](./auth-flow.md)
- [API Documentation](../api/auth.md)
</file>

<file path="docs/04-features/features-details.md">
# PharmacyHub Features Documentation

## Licensing Feature

### Components Structure

```
/features/licensing/
├── ui/
│   ├── forms/
│   │   ├── PharmacistForm.tsx
│   │   ├── PharmacyManagerForm.tsx
│   │   ├── ProprietorForm.tsx
│   │   └── SalesmanForm.tsx
│   ├── pages/
│   │   ├── connections/
│   │   └── requests/
│   ├── pharmacist/
│   ├── pharmacy-manager/
│   ├── proprietor/
│   └── salesman/
├── model/
│   ├── types.ts
│   └── constants.ts
├── api/
│   └── services/
└── lib/
    └── utils/
```

### Key Features

1. **User Registration**
    - Pharmacist registration
    - Pharmacy Manager registration
    - Proprietor registration
    - Salesman registration

2. **Connection Management**
    - Connection requests
    - Connection approvals
    - Connection listings
    - Request notifications

3. **License Management**
    - License application
    - License renewal
    - License verification
    - Status tracking

## Exam Feature

### Components Structure

```
/features/exams/
├── ui/
│   ├── quiz/
│   ├── mock-test/
│   └── results/
├── model/
│   ├── types.ts
│   └── constants.ts
├── api/
│   └── services/
└── lib/
    └── utils/
```

### Key Features

1. **Practice Tests**
    - MCQ questions
    - Topic-wise practice
    - Progress tracking
    - Score history

2. **Mock Exams**
    - Timed tests
    - Real exam simulation
    - Result analysis
    - Performance metrics

3. **Learning Resources**
    - Study materials
    - Reference guides
    - Practice tips
    - Exam preparation strategies

## Authentication Feature

### Components Structure

```
/features/auth/
├── ui/
│   ├── login/
│   ├── register/
│   └── reset-password/
├── model/
│   └── types.ts
├── api/
│   └── services/
└── lib/
    └── hooks/
```

### Key Features

1. **User Authentication**
    - JWT-based auth
    - OAuth2 integration
    - Session management
    - Secure token storage

2. **Authorization**
    - Role-based access
    - Permission management
    - Protected routes
    - API security

3. **Account Management**
    - Profile updates
    - Password reset
    - Email verification
    - Account recovery
</file>

<file path="docs/04-features/mcq-data-model.md">
# MCQ Practice Platform Data Model

## Overview

This document outlines the recommended data model for the MCQ Practice Platform, designed for scalability, performance, and maintainability.

## JSON Schema

```typescript
interface MCQPaper {
  id: string;                 // Unique identifier for the paper
  type: 'model' | 'past';     // Paper type
  year?: number;              // Year for past papers
  version: string;            // Content version for tracking updates
  title: string;             // Paper title
  description: string;       // Brief description
  timeLimit: number;         // Time limit in minutes
  totalQuestions: number;    // Total number of questions
  passingCriteria: {
    minimumQuestions: number; // Minimum questions required
    passingScore: number;    // Minimum score required
  };
  sections: MCQSection[];    // Organized sections of questions
  metadata: {
    createdAt: string;      // ISO date string
    updatedAt: string;      // ISO date string
    difficulty: 'easy' | 'medium' | 'hard';
    tags: string[];         // Search and filter tags
    category: string;       // Main category
    subCategory?: string;   // Optional sub-category
  };
}

interface MCQSection {
  id: string;               // Section identifier
  title: string;           // Section title
  description?: string;    // Optional section description
  questions: MCQuestion[]; // Questions in this section
}

interface MCQuestion {
  id: string;              // Unique question identifier
  questionNumber: number;  // Sequential number in paper
  question: string;       // Question text
  options: {
    [key: string]: string; // A, B, C, D mapped to option text
  };
  answer: string;         // Correct answer (e.g., "D")
  explanation: string;    // Detailed answer explanation
  metadata: {
    difficulty: 'easy' | 'medium' | 'hard';
    topic: string;        // Specific topic
    subTopic?: string;    // Optional sub-topic
    tags: string[];       // Question-specific tags
    source?: string;      // Reference source
    lastUpdated: string;  // ISO date string
  };
  stats?: {              // Optional performance statistics
    attemptCount: number;
    correctCount: number;
    averageTimeSpent: number;
  };
}
```

## Example Implementation

```json
{
  "id": "model-paper-1",
  "type": "model",
  "version": "1.0.0",
  "title": "Pharmacy Practice Model Paper 1",
  "description": "Comprehensive model paper covering pharmacy laws and regulations",
  "timeLimit": 70,
  "totalQuestions": 100,
  "passingCriteria": {
    "minimumQuestions": 25,
    "passingScore": 50
  },
  "sections": [
    {
      "id": "sec-1",
      "title": "Drug Laws and Regulations",
      "questions": [
        {
          "id": "q-001",
          "questionNumber": 1,
          "question": "\"Spurious drug\" means a drug that:",
          "options": {
            "A": "Purports to be a drug but does not contain the active ingredient",
            "B": "Purports to be the product of a manufacturer, place, or country of which it is not truly a product",
            "C": "Is imported or exported for sale under a particular name while actually being another drug",
            "D": "All of the above"
          },
          "answer": "D",
          "explanation": "A spurious drug includes those that lack the claimed active ingredient, falsely claim a different origin, or are misrepresented for sale. Each statement (A, B, and C) contributes to the legal definition of a spurious drug.",
          "metadata": {
            "difficulty": "medium",
            "topic": "Drug Laws",
            "subTopic": "Drug Classifications",
            "tags": ["spurious drugs", "regulations", "drug safety"],
            "lastUpdated": "2024-02-21T00:00:00Z"
          }
        }
      ]
    }
  ],
  "metadata": {
    "createdAt": "2024-02-21T00:00:00Z",
    "updatedAt": "2024-02-21T00:00:00Z",
    "difficulty": "medium",
    "tags": ["pharmacy law", "regulations", "practice exam"],
    "category": "Pharmacy Practice",
    "subCategory": "Laws and Regulations"
  }
}
```

## Benefits of This Structure

1. **Organized Content**
   - Questions grouped into logical sections
   - Clear metadata for filtering and search
   - Version control for content updates

2. **Enhanced Features**
   - Support for difficulty levels
   - Topic-based organization
   - Detailed statistics tracking
   - Flexible tagging system

3. **Performance Optimization**
   - Structured data for efficient querying
   - Segregated sections for lazy loading
   - Metadata for caching strategies

4. **Analytics Support**
   - Question-level statistics
   - Performance tracking
   - Usage patterns analysis

5. **Content Management**
   - Easy content updates
   - Version tracking
   - Source attribution

## Implementation Guidelines

1. **Storage**
   - Use MongoDB or PostgreSQL JSON fields for flexible schema
   - Implement content versioning
   - Set up efficient indexing on frequently queried fields

2. **API Design**
   ```typescript
   // API Endpoints
   GET /api/papers                    // List all papers with filtering
   GET /api/papers/:id               // Get specific paper
   GET /api/papers/:id/questions     // Get questions (paginated)
   POST /api/papers/:id/submit       // Submit answers
   GET /api/papers/:id/statistics    // Get performance statistics
   ```

3. **Caching Strategy**
   - Cache full papers at CDN level
   - Implement stale-while-revalidate for content updates
   - Use Redis for user progress and session data

4. **Frontend Considerations**
   - Implement progressive loading for questions
   - Cache user answers in localStorage
   - Optimize rendering for large question sets

## Migration Strategy

For existing MCQ data:

1. Create a migration script to transform current format
2. Add missing metadata fields with default values
3. Generate unique IDs for all entities
4. Validate data integrity after migration

## Next Steps

1. Set up automated validation for JSON schema
2. Implement content management system
3. Create API endpoints following RESTful practices
4. Develop frontend components for rendering questions
5. Set up monitoring for content usage and performance
</file>

<file path="docs/04-features/mcq-practice-platform.md">
# Online MCQ Practice Platform Specification

## Overview

The Online MCQ Practice Platform is a comprehensive system for pharmacy students to practice multiple-choice questions through past papers and model papers.

## Key Features

### 1. Landing Page Structure
- Two primary sections:
  - Past Papers
  - Model Papers
- Directory-based navigation for each section
- Authentication-gated access
- Unauthorized users redirected to login/signup

### 2. User Authentication

#### Login System
- Required fields:
  - Email address
  - Password
- Additional features:
  - Password recovery option
  - Sign-up redirect link

#### Registration System
- Required fields:
  - Full Name
  - Email address
  - Password with confirmation
- Registration completion button

### 3. Model Papers Implementation

#### Paper Format
- 100 MCQs per paper
- Each question includes:
  - Question number
  - Question text
  - 4 answer options
- Interactive features:
  - Selected options highlight (light blue)
  - Minimum attempt requirement (25 MCQs)
  - Warning system for insufficient attempts

#### Submission Process
1. Submit button with help icon ('?')
2. Confirmation dialog
3. Results viewing options:
   - Complete paper review
   - Review of attempted questions only

#### Results Display System
- Color-coded answer marking:
  - Correct answers: Green
  - Incorrect answers: Red
- Scoring methodology:
  - Correct answer: +1 point
  - Incorrect answer: -0.25 points
  - Unattempted: 0 points

#### Timer System
- Duration: 70 minutes
- Pre-start instruction page displaying:
  - Time limit information
  - Scoring system rules
  - Start confirmation mechanism

### 4. Past Papers System
- Free access to 2018 paper
- Premium access required for other years
- Features:
  - Immediate results
  - Answer explanations
  - Consistent format with model papers

### 5. Access Control and Pricing Structure

#### Model Papers Access
- Free tier:
  - Two papers accessible without payment
- Premium tier:
  - Additional papers require payment

#### Past Papers Access
- Free content:
  - 2018 paper
- Premium content:
  - Papers from other years
- Access model:
  - Single payment for complete access

#### Payment Integration
- Visual indicators:
  - Lock icons for premium content
- User flow:
  - Payment prompt for locked content
  - Immediate access post-payment

## Technical Considerations

### Performance Optimization
- Implement lazy loading for MCQ content
- Cache user progress and results
- Optimize answer submission process

### Security Measures
- Secure authentication flow
- Protected premium content routes
- Safe payment processing

### User Experience
- Responsive design for all devices
- Clear navigation between papers
- Intuitive MCQ selection interface
- Real-time progress tracking

## Data Structure

The platform uses a structured JSON format for managing MCQ content. This includes comprehensive metadata, versioning, and analytics support. For detailed specifications of the data model, including schema definitions and implementation guidelines, see the [MCQ Data Model Documentation](./mcq-data-model.md).

The data model is designed to support:
- Organized content with sections and topics
- Enhanced features like difficulty levels and tags
- Performance optimization through efficient data structure
- Analytics and statistics tracking


## Implementation Phases

1. Core Platform Development
   - Authentication system
   - Basic MCQ interface
   - Timer functionality

2. Content Integration
   - Past papers upload
   - Model papers creation
   - Answer key integration

3. Premium Features
   - Payment system integration
   - Access control implementation
   - Premium content management

4. Enhancement Phase
   - Performance optimization
   - User feedback integration
   - Analytics implementation
</file>

<file path="docs/04-features/mcq-progress-update.md">
# MCQ Practice Platform Implementation Progress

## Implemented Components

### Core Infrastructure
1. **State Management**
   - ✅ Zustand store for exam state
   - ✅ React Query for API caching
   - ✅ Error handling system
   - ✅ Type-safe API client

2. **Data Models**
   - ✅ MongoDB models for exam, questions, progress
   - ✅ TypeScript interfaces for type safety
   - ✅ Spring Boot repositories and services

### Frontend Components

1. **Core Quiz Interface**
   - ✅ ExamLayout.tsx: Main exam interface with timer and navigation
   - ✅ QuestionCard.tsx: Individual question display with options
   - ✅ ExamTimer.tsx: Countdown timer with auto-submit
   - ✅ QuestionNavigation.tsx: Side navigation with progress tracking
   - ✅ ErrorBoundary.tsx: React error handling

2. **Results & Analysis**
   - ✅ ResultsView.tsx: Comprehensive results display
   - ✅ PerformanceCharts.tsx: Visual analytics with Recharts
   - ✅ ReviewMode.tsx: Question-by-question review interface

3. **API Integration**
   - ✅ Centralized API client
   - ✅ React Query hooks for data fetching
   - ✅ Error handling and loading states
   - ✅ Progress persistence

## In Progress

1. **Enhanced User Experience**
   - [ ] Keyboard navigation support
   - [ ] Question filtering and search
   - [ ] More interactive question types
   - [ ] Save draft answers

2. **Analytics & Insights**
   - [ ] Advanced performance metrics
   - [ ] Learning pattern analysis
   - [ ] Custom recommendation engine
   - [ ] Topic mastery tracking

## Upcoming Tasks

### High Priority
1. **User Progress Features**
   - Implement streak system
   - Add achievement badges
   - Create progress milestone tracking
   - Implement spaced repetition system
   - Add personal notes feature

2. **Question Management**
   - Question tagging system
   - Difficulty auto-adjustment
   - Question feedback system
   - Rich text and image support

3. **Study Tools**
   - Interactive flashcards
   - Study group features
   - Discussion forums
   - Personal study planner

### Performance Improvements
1. **Backend Optimization**
   - Implement Redis caching
   - Add database indexing
   - Optimize query performance
   - Implement server-side pagination

2. **Frontend Optimization**
   - Code splitting
   - Image optimization
   - Prefetching for common paths
   - Service worker for offline mode

### Enhanced Analytics
1. **Learning Analytics**
   - Time spent analysis
   - Performance predictions
   - Learning style detection
   - Custom study plans

2. **Reporting**
   - Progress reports
   - Performance insights
   - Weekly/monthly summaries
   - Export functionality

## Technical Recommendations

### 1. Performance Optimization
- Implement lazy loading for questions
- Use virtual scrolling for long lists
- Add client-side caching
- Optimize API calls with batching

### 2. User Experience
- Add keyboard shortcuts
- Improve accessibility (ARIA)
- Add touch gestures support
- Implement progressive enhancement

### 3. Testing Strategy
- Add E2E tests with Cypress
- Implement unit tests for components
- Add API integration tests
- Performance testing suite

### 4. Security Enhancements
- Implement rate limiting
- Add CSRF protection
- Enhance input validation
- Add audit logging

### 5. Monitoring & Logging
- Add error tracking (Sentry)
- Implement performance monitoring
- Add user behavior analytics
- Setup logging pipeline

## Feature Suggestions

### 1. Social Learning Features
- Study groups
- Leaderboards
- Peer reviews
- Social sharing

### 2. Gamification Elements
- Points system
- Achievement badges
- Daily challenges
- Learning streaks

### 3. Content Enhancement
- Video explanations
- Interactive diagrams
- 3D models for chemistry
- Audio pronunciations

### 4. Mobile Experience
- Native app features
- Offline support
- Push notifications
- Touch optimization

### 5. AI Integration
- Smart question recommendations
- Performance predictions
- Content personalization
- Study pattern analysis

## Implementation Architecture

```typescript
// Suggested folder structure
src/
  ├── components/
  │   ├── exam/           // Exam-related components
  │   ├── analytics/      // Analytics components
  │   ├── common/         // Shared components
  │   └── study/          // Study tools
  ├── hooks/              // Custom hooks
  ├── store/              // State management
  ├── api/                // API integration
  ├── utils/              // Utility functions
  └── types/              // TypeScript types
```

## Next Sprint Focus
1. Implement study tools (flashcards, notes)
2. Add advanced analytics features
3. Enhance mobile experience
4. Implement gamification elements
5. Add social learning features

## Long-term Roadmap
1. **Q2 2025**
   - Mobile app development
   - Advanced analytics
   - Social features

2. **Q3 2025**
   - AI-powered recommendations
   - Video content integration
   - Premium features

3. **Q4 2025**
   - Global leaderboards
   - Expert consultation
   - Community features

## Known Issues & Mitigation
1. Performance with large question sets
   - Implement pagination
   - Use virtual scrolling
   - Optimize database queries

2. Mobile responsiveness
   - Enhance mobile UI
   - Optimize touch interactions
   - Improve navigation

3. Offline capability
   - Implement service workers
   - Add local storage backup
   - Sync when online

## Resource Requirements
1. Development
   - Frontend developer (React/TypeScript)
   - Backend developer (Spring Boot)
   - UX designer

2. Infrastructure
   - MongoDB hosting
   - Redis cache
   - CDN setup

3. Third-party Services
   - Analytics platform
   - Error tracking
   - Email service

## Monitoring Plan
1. Performance Metrics
   - Page load times
   - API response times
   - Cache hit rates

2. User Metrics
   - Engagement rates
   - Completion rates
   - Error rates

3. Business Metrics
   - User growth
   - Premium conversions
   - Feature usage
</file>

<file path="docs/04-features/README.md">
# PharmacyHub Features

## Overview

PharmacyHub provides a comprehensive set of features designed for pharmacy management, licensing, and exam preparation. This documentation outlines the key features, their implementation, and usage.

## Core Feature Areas

1. [Licensing Management](#licensing-management)
2. [Exam Preparation](#exam-preparation) 
3. [Authentication & Authorization](#authentication--authorization)
4. [Pharmacy Operations](#pharmacy-operations)
5. [Reporting & Analytics](#reporting--analytics)

## Licensing Management

The licensing feature enables pharmacy professionals to manage their licenses, registrations, and connections with regulatory bodies.

### Component Structure

```
/features/licensing/
├── ui/
│   ├── forms/
│   │   ├── PharmacistForm.tsx
│   │   ├── PharmacyManagerForm.tsx
│   │   ├── ProprietorForm.tsx
│   │   └── SalesmanForm.tsx
│   ├── pages/
│   │   ├── connections/
│   │   └── requests/
│   ├── pharmacist/
│   ├── pharmacy-manager/
│   ├── proprietor/
│   └── salesman/
├── model/
│   ├── types.ts
│   └── constants.ts
├── api/
│   └── services/
└── lib/
    └── utils/
```

### Key Features

#### 1. User Registration

The system supports registration of different pharmacy professionals:

- **Pharmacist Registration**
  - Professional qualification verification
  - License number validation
  - Employment history tracking
  - Continuing education monitoring

- **Pharmacy Manager Registration**
  - Management qualification verification
  - Pharmacy association
  - Responsibility assignment
  - Staff oversight capabilities

- **Proprietor Registration**
  - Ownership verification
  - Business registration
  - Multiple pharmacy management
  - Compliance tracking

- **Salesman Registration**
  - Certification verification
  - Sales authorization
  - Product knowledge assessment
  - Performance tracking

#### 2. Connection Management

The system facilitates professional connections between entities:

- **Connection Requests**
  - Send/receive connection requests
  - Request categorization
  - Priority management
  - Expiration handling

- **Connection Approvals**
  - Multi-step approval process
  - Document verification
  - Approval workflows
  - Rejection handling

- **Connection Listings**
  - Searchable connection directory
  - Filtering capabilities
  - Relationship visualization
  - Status indicators

- **Request Notifications**
  - Email notifications
  - In-app notifications
  - Status change alerts
  - Reminder system

#### 3. License Management

Comprehensive license lifecycle management:

- **License Application**
  - Step-by-step application process
  - Document upload
  - Fee payment integration
  - Status tracking

- **License Renewal**
  - Renewal reminders
  - Continuing education verification
  - Fast-track renewal for good standing
  - Late renewal handling

- **License Verification**
  - QR code verification
  - Public verification portal
  - Third-party API access
  - Verification history

- **Status Tracking**
  - Real-time status updates
  - Milestone tracking
  - Timeline visualization
  - Automatic notifications

### Implementation Details

For detailed implementation information, see the [Licensing Implementation Guide](./licensing-implementation.md).

## Exam Preparation

The exam feature provides tools for pharmacy professionals to prepare for licensing and certification exams.

### Component Structure

```
/features/exams/
├── ui/
│   ├── quiz/
│   ├── mock-test/
│   └── results/
├── model/
│   ├── types.ts
│   └── constants.ts
├── api/
│   └── services/
└── lib/
    └── utils/
```

### Key Features

#### 1. Practice Tests

Interactive practice tests for exam preparation:

- **MCQ Questions**
  - Categorized question bank
  - Difficulty levels
  - Answer explanations
  - Custom question sets

- **Topic-wise Practice**
  - Subject-specific tests
  - Knowledge gap identification
  - Focused learning paths
  - Topic mastery tracking

- **Progress Tracking**
  - Performance analytics
  - Improvement metrics
  - Study time tracking
  - Learning curve visualization

- **Score History**
  - Historical performance data
  - Comparative analytics
  - Trend analysis
  - Performance predictions

#### 2. Mock Exams

Realistic exam simulation environment:

- **Timed Tests**
  - Full-length exam simulation
  - Sectional timing
  - Adaptive time management
  - Pause/resume functionality

- **Real Exam Simulation**
  - Exam-like interface
  - Realistic question patterns
  - Randomized question order
  - Pressure simulation

- **Result Analysis**
  - Detailed performance breakdown
  - Strength/weakness identification
  - Answer reviews
  - Comparative scoring

- **Performance Metrics**
  - Speed analysis
  - Accuracy metrics
  - Subject-wise performance
  - Percentile ranking

#### 3. Learning Resources

Comprehensive study materials:

- **Study Materials**
  - Textbook integration
  - Video lectures
  - Interactive learning modules
  - Downloadable resources

- **Reference Guides**
  - Quick reference cards
  - Formula sheets
  - Terminology guides
  - Regulatory updates

- **Practice Tips**
  - Expert study strategies
  - Time management techniques
  - Memory aids
  - Exam-day preparation

- **Exam Preparation Strategies**
  - Customized study plans
  - Last-minute revision guides
  - Stress management techniques
  - Group study coordination

### Implementation Details

For detailed implementation information, see the [Exam Module Implementation Guide](./exam-implementation.md).
For MCQ practice platform specifications, see the [MCQ Practice Platform Documentation](./mcq-practice-platform.md).

## Authentication & Authorization

Secure authentication and authorization systems for user access management.

### Component Structure

```
/features/auth/
├── ui/
│   ├── login/
│   ├── register/
│   └── reset-password/
├── model/
│   └── types.ts
├── api/
│   └── services/
└── lib/
    └── hooks/
```

### Key Features

#### 1. User Authentication

Robust authentication mechanisms:

- **JWT-based Authentication**
  - Secure token generation
  - Token validation
  - Signature verification
  - Expiration handling

- **OAuth2 Integration**
  - Social login providers
  - Enterprise SSO support
  - Authorization code flow
  - Token exchange

- **Session Management**
  - Secure session storage
  - Session timeout
  - Active session tracking
  - Force logout capability

- **Secure Token Storage**
  - HTTP-only cookies
  - Token encryption
  - Refresh token rotation
  - XSS protection

#### 2. Authorization

Fine-grained access control system:

- **Role-based Access**
  - Hierarchical roles
  - Role inheritance
  - Dynamic role assignment
  - Role constraints

- **Permission Management**
  - Granular permissions
  - Permission grouping
  - Contextual permissions
  - Permission delegation

- **Protected Routes**
  - Route-level protection
  - Redirect handling
  - Permission-based routing
  - Route meta configuration

- **API Security**
  - Endpoint protection
  - Request validation
  - Rate limiting
  - CORS configuration

#### 3. Account Management

User account lifecycle management:

- **Profile Updates**
  - Personal information management
  - Professional details
  - Contact information
  - Privacy settings

- **Password Reset**
  - Secure reset flow
  - Time-limited tokens
  - Email verification
  - Password strength enforcement

- **Email Verification**
  - Email verification tokens
  - Re-verification flow
  - Multi-email support
  - Verification status tracking

- **Account Recovery**
  - Multi-factor recovery
  - Security questions
  - Recovery codes
  - Admin-assisted recovery

### Implementation Details

For detailed authentication implementation information, see the [Authentication Documentation](../03-authentication/README.md).

## Pharmacy Operations

Comprehensive tools for day-to-day pharmacy operations management.

### Key Features

#### 1. Inventory Management

- **Stock Tracking**
  - Real-time inventory levels
  - Batch tracking
  - Location management
  - Stock alerts

- **Expiration Date Monitoring**
  - Automated expiration alerts
  - Near-expiry reporting
  - FEFO (First Expired, First Out) support
  - Recall management

- **Automated Reordering**
  - Par level management
  - Demand forecasting
  - Purchase order generation
  - Vendor management

- **Supplier Management**
  - Supplier database
  - Performance metrics
  - Contract management
  - Price comparison tools

#### 2. Prescription Processing

- **Digital Prescription Handling**
  - E-prescription receipt
  - Prescription queuing
  - Image capture and OCR
  - Digital signature

- **Drug Interaction Checking**
  - Contraindication detection
  - Drug-drug interaction alerts
  - Allergy verification
  - Dosage validation

- **Patient Medication History**
  - Comprehensive medication records
  - Adherence tracking
  - Refill history
  - Medication synchronization

- **Insurance Processing**
  - Real-time eligibility verification
  - Claim submission
  - Prior authorization tracking
  - Rejection management

#### 3. Point of Sale

- **Sales Processing**
  - Barcode scanning
  - Product lookup
  - Bundle pricing
  - Multi-payment options

- **Receipt Generation**
  - Digital receipts
  - Customizable templates
  - Tax calculation
  - Return policy inclusion

- **Payment Integration**
  - Credit/debit card processing
  - Mobile payments
  - FSA/HSA card support
  - Split payment handling

- **Discount Management**
  - Coupon processing
  - Loyalty program integration
  - Senior/military discounts
  - Employee discounts

#### 4. Staff Management

- **Staff Scheduling**
  - Shift planning
  - Time-off management
  - Pharmacist coverage compliance
  - Mobile schedule access

- **Performance Tracking**
  - KPI monitoring
  - Productivity metrics
  - Quality assurance
  - Goal setting and tracking

- **Credential Monitoring**
  - License expiration alerts
  - CE credit tracking
  - Certification verification
  - Background check management

- **Training Management**
  - Training schedule
  - Compliance training
  - Skill development tracking
  - Training effectiveness assessment

### Implementation Details

For detailed implementation information, see the [Pharmacy Operations Guide](./pharmacy-operations.md).

## Reporting & Analytics

Comprehensive reporting and analytics tools for business intelligence.

### Key Features

#### 1. Business Analytics

- **Sales Trends**
  - Product category analysis
  - Time-based trend analysis
  - Comparative period reporting
  - Revenue forecasting

- **Profitability Analysis**
  - Margin analysis
  - Cost center reporting
  - Contribution margin
  - Break-even analysis

- **Customer Demographics**
  - Age group distribution
  - Geographic analysis
  - Visit frequency patterns
  - Customer lifetime value

- **Seasonal Patterns**
  - Seasonal product demand
  - Weather impact analysis
  - Holiday trend reporting
  - Year-over-year comparisons

#### 2. Compliance Reporting

- **Regulatory Reports**
  - Controlled substance reporting
  - Board of Pharmacy submissions
  - FDA compliance reports
  - HIPAA compliance documentation

- **Audit Preparation**
  - Pre-audit checklists
  - Documentation organization
  - Historical audit results
  - Corrective action tracking

- **Compliance Tracking**
  - Regulatory requirement monitoring
  - Policy adherence metrics
  - Compliance calendar
  - Risk assessment tracking

- **Risk Assessment**
  - Vulnerability identification
  - Mitigation planning
  - Risk level scoring
  - Compliance gap analysis

#### 3. Operational Dashboards

- **Real-time Metrics**
  - Daily transaction volume
  - Wait time monitoring
  - Staff productivity
  - Inventory turnover

- **Performance Indicators**
  - Prescription fill rate
  - Customer satisfaction
  - Error rate tracking
  - Labor efficiency

- **Goal Tracking**
  - Sales targets
  - Service level adherence
  - Quality metrics
  - Cost containment goals

- **Comparative Analysis**
  - Location benchmarking
  - Industry standard comparisons
  - Competitive analysis
  - Historical performance

#### 4. Export Capabilities

- **PDF Reports**
  - Customizable templates
  - Scheduled report generation
  - Interactive PDF elements
  - Digital signature support

- **Excel Exports**
  - Raw data exports
  - Pivot-ready formatting
  - Formula preservation
  - Automatic worksheet organization

- **Data Visualization**
  - Interactive charts
  - Drill-down capabilities
  - Custom visualization creation
  - Mobile-optimized views

- **Integration Options**
  - Business intelligence tools connection
  - ERP system integration
  - Data warehouse connectivity
  - Third-party analytics platforms

### Implementation Details

For detailed implementation information, see the [Reporting & Analytics Guide](./reporting-analytics.md).

## Integration Features

### Third-Party Integrations

- **Insurance Providers**
  - Eligibility verification
  - Claims processing
  - Prior authorization
  - Formulary checking

- **Wholesalers and Suppliers**
  - Automated ordering
  - Inventory synchronization
  - Price updates
  - Product catalog access

- **Clinical Resources**
  - Drug information databases
  - Clinical decision support
  - Medication therapy management
  - Disease state management tools

- **Government Agencies**
  - PDMP (Prescription Drug Monitoring Program)
  - Immunization registries
  - Regulatory reporting
  - Public health initiatives

### API Capabilities

- **External System Integration**
  - RESTful API endpoints
  - GraphQL support
  - Webhook notifications
  - Batch processing capabilities

- **Mobile Application Support**
  - Native app integration
  - Push notification services
  - Offline synchronization
  - Secure mobile authentication

- **Partner Ecosystem**
  - Developer portal
  - API documentation
  - Sandbox testing environment
  - Rate limiting and usage monitoring

## Cross-Cutting Features

### Multi-language Support

- **Interface Translation**
  - 10+ supported languages
  - Context-aware translations
  - Custom terminology support
  - Right-to-left language support

- **Document Generation**
  - Multilingual documents
  - Language preference tracking
  - Translation memory
  - Regulatory compliance across languages

### Accessibility

- **WCAG 2.1 Compliance**
  - Screen reader compatibility
  - Keyboard navigation
  - Color contrast optimization
  - Focus management

- **Adaptive Interfaces**
  - Font size adjustment
  - High contrast mode
  - Reduced motion option
  - Voice command support

### Mobile Responsiveness

- **Adaptive Layouts**
  - Mobile-first design
  - Breakpoint optimization
  - Touch-friendly controls
  - Offline capabilities

- **Native Feature Integration**
  - Camera for barcode scanning
  - Biometric authentication
  - Push notifications
  - Location services

## Feature Roadmap

### Upcoming Features (Q3 2024)

- **Medication Therapy Management**
  - Comprehensive medication reviews
  - Intervention documentation
  - Outcome tracking
  - Billing support

- **Enhanced Analytics**
  - Predictive inventory management
  - Patient adherence prediction
  - Staff scheduling optimization
  - Revenue forecasting

- **Clinical Services Expansion**
  - Vaccination management
  - Point-of-care testing
  - Disease state management
  - Medication synchronization

### Future Considerations (2025)

- **AI-Powered Decision Support**
  - Prescription error detection
  - Drug interaction severity assessment
  - Patient risk stratification
  - Inventory optimization

- **Telemedicine Integration**
  - Virtual consultations
  - Remote monitoring integration
  - Digital therapeutics
  - Care plan management

- **Blockchain for Supply Chain**
  - Drug provenance tracking
  - Counterfeit prevention
  - Recall management
  - Temperature monitoring

For detailed feature specifications and implementation guides, please refer to the specific feature documentation in this section.
</file>

<file path="docs/05-development/development-guide.md">
# PharmacyHub Development Guide

## Development Standards

### 1. TypeScript Configuration

```typescript
// tsconfig.json key settings
{
  "compilerOptions": {
    "strict": true,
    "target": "ES2020",
    "module": "ESNext",
    "jsx": "preserve",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

### 2. State Management Patterns

#### Global State (Zustand)

```typescript
// /src/features/licensing/model/store.ts
import create from 'zustand';

interface LicensingStore {
  licenses: License[];
  setLicenses: (licenses: License[]) => void;
  isLoading: boolean;
  setLoading: (loading: boolean) => void;
}

export const useLicensingStore = create<LicensingStore>((set) => ({
  licenses: [],
  setLicenses: (licenses) => set({ licenses }),
  isLoading: false,
  setLoading: (loading) => set({ isLoading: loading }),
}));
```

#### Server State (React Query)

```typescript
// /src/features/licensing/api/queries.ts
import { useQuery } from '@tanstack/react-query';

export const useLicenses = () => {
  return useQuery({
    queryKey: ['licenses'],
    queryFn: fetchLicenses,
  });
};
```

### 3. Component Patterns

#### Feature Components

```typescript
// /src/features/licensing/ui/pharmacist/PharmacistList.tsx
import { useQuery } from '@tanstack/react-query';
import { DataTable } from '@/shared/ui/data-table';
import { usePharmacists } from '../api/queries';

export const PharmacistList = () => {
  const { data, isLoading } = usePharmacists();

  return (
    <DataTable
      data={data}
      columns={pharmacistColumns}
      isLoading={isLoading}
    />
  );
};
```

#### Shared Components

```typescript
// /src/shared/ui/form/FormField.tsx
import { FC } from 'react';
import { Label } from '@/shared/ui/label';
import { Input } from '@/shared/ui/input';

interface FormFieldProps {
  label: string;
  name: string;
  type?: string;
  error?: string;
}

export const FormField: FC<FormFieldProps> = ({
  label,
  name,
  type = 'text',
  error,
}) => (
  <div className="space-y-2">
    <Label htmlFor={name}>{label}</Label>
    <Input type={type} id={name} name={name} />
    {error && <p className="text-red-500 text-sm">{error}</p>}
  </div>
);
```

### 4. API Integration

#### Service Layer Pattern

```typescript
// /src/shared/api/service.ts
export class ApiService {
  private baseUrl: string;

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }

  async get<T>(endpoint: string): Promise<T> {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      headers: this.getHeaders(),
    });
    return this.handleResponse<T>(response);
  }

  private getHeaders(): HeadersInit {
    return {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${this.getToken()}`,
    };
  }
}
```

### 5. Route Protection

```typescript
// /src/app/(licensing)/layout.tsx
import { withAuth } from '@/shared/auth/withAuth';
import { LicensingLayout } from '@/features/licensing/ui/layout';

export default withAuth(LicensingLayout, ['admin', 'pharmacist']);
```

### 6. Error Handling

```typescript
// /src/shared/lib/error-handling.ts
export class AppError extends Error {
  constructor(
    message: string,
    public code: string,
    public status: number
  ) {
    super(message);
  }
}

export const handleApiError = (error: unknown) => {
  if (error instanceof AppError) {
    // Handle known application errors
    notify.error(error.message);
  } else {
    // Handle unexpected errors
    notify.error('An unexpected error occurred');
    console.error(error);
  }
};
```

## Best Practices

### 1. Component Organization

- Keep components small and focused
- Use composition over inheritance
- Follow Single Responsibility Principle
- Implement proper TypeScript types

### 2. State Management

- Use local state for UI-only state
- Use Zustand for global application state
- Use React Query for server state
- Implement proper loading and error states

### 3. Performance

- Implement proper memoization
- Use React.lazy for code splitting
- Optimize re-renders
- Follow React Query best practices

### 4. Testing

```typescript
// /src/features/licensing/ui/__tests__/PharmacistList.test.tsx
import { render, screen } from '@testing-library/react';
import { PharmacistList } from '../PharmacistList';

describe('PharmacistList', () => {
  it('renders list of pharmacists', async () => {
    render(<PharmacistList />);
    expect(await screen.findByRole('table')).toBeInTheDocument();
  });
});
```

### 5. Documentation

- Document complex business logic
- Add JSDoc comments for components
- Keep README files updated
- Document API integrations

### 6. Code Style

- Follow ESLint rules
- Use Prettier for formatting
- Follow naming conventions
- Write meaningful commit messages
</file>

<file path="docs/05-development/logging-usage-guide.md">
# Logging System Usage Guide

## Overview
PharmacyHub implements a comprehensive logging system that provides structured logging across the application. The system supports different log levels, file rotation, and separate logging for API requests.

## Features
- Multiple log levels (error, warn, info, debug)
- Automatic log rotation and retention
- Structured JSON logging
- API request/response logging
- Development console output
- TypeScript support

## Basic Usage

### 1. Importing the Logger
```typescript
import { logger } from '@/shared/lib/logger';
```

### 2. Using Different Log Levels

```typescript
// Info level for general operational information
logger.info('Operation completed', {
  operation: 'data_sync',
  status: 'success'
});

// Error level for application errors
logger.error('Failed to process request', {
  error: error.message,
  stack: error.stack
});

// Warning level for potential issues
logger.warn('Rate limit approaching', {
  currentRate: '80%',
  endpoint: '/api/data'
});

// Debug level for detailed information
logger.debug('Processing request', {
  requestId: 'req-123',
  payload: requestData
});
```

### 3. API Route Logging

Use the `withApiLogger` middleware to automatically log API requests and responses:

```typescript
import { withApiLogger } from '@/shared/lib/api-logger';
import { NextRequest, NextResponse } from 'next/server';

async function handler(req: NextRequest) {
  // Your handler logic
}

export const GET = withApiLogger(handler);
```

### 4. Component Logging

Example of logging in React components:

```typescript
const MyComponent = () => {
  useEffect(() => {
    logger.info('Component mounted', {
      component: 'MyComponent',
      timestamp: new Date().toISOString()
    });

    return () => {
      logger.debug('Component unmounted', {
        component: 'MyComponent'
      });
    };
  }, []);
};
```

## Best Practices

1. **Use Appropriate Log Levels**
   - ERROR: For errors that need immediate attention
   - WARN: For potentially harmful situations
   - INFO: For general operational information
   - DEBUG: For detailed debugging information

2. **Include Relevant Context**
   ```typescript
   logger.info('User action', {
     userId: user.id,
     action: 'profile_update',
     timestamp: new Date().toISOString()
   });
   ```

3. **Avoid Sensitive Information**
   - Never log passwords or tokens
   - Mask sensitive user data
   - Be careful with error stack traces in production

4. **Structured Logging**
   - Always include relevant metadata
   - Use consistent property names
   - Include correlation IDs for request tracking

## Log File Locations

Logs are stored in the `/logs` directory with the following files:
- `error-%DATE%.log` - Error level logs
- `combined-%DATE%.log` - All log levels
- `api-%DATE%.log` - API-specific logs

## Configuration

The logging system can be configured in `src/shared/config/logger.ts`:

```typescript
export const loggerConfig: LoggerConfig = {
  level: isDevelopment ? 'debug' : 'info',
  directory: path.join(process.cwd(), 'logs'),
  maxSize: '10m',
  maxFiles: '14d',
  format: 'json'
};
```

## Error Handling Example

```typescript
try {
  await processData();
} catch (error) {
  logger.error('Data processing failed', {
    error: error instanceof Error ? error.message : 'Unknown error',
    stack: error instanceof Error ? error.stack : undefined,
    operation: 'processData',
    timestamp: new Date().toISOString()
  });
  
  // Handle the error appropriately
}
```

## Performance Considerations

1. Use debug level logging judiciously
2. Avoid logging large objects in production
3. Use sampling for high-volume logs
4. Consider log aggregation for production environments
</file>

<file path="docs/05-development/README.md">
# PharmacyHub Development Guide

This section provides comprehensive guidelines for developing PharmacyHub components following established patterns and best practices.

## Table of Contents

1. [Development Standards](#development-standards)
2. [State Management Patterns](#state-management-patterns)
3. [Component Patterns](#component-patterns)
4. [API Integration](#api-integration)
5. [Route Protection](#route-protection)
6. [Error Handling](#error-handling)
7. [Best Practices](#best-practices)
8. [Testing Guidelines](#testing-guidelines)

## Development Standards

### TypeScript Configuration

```typescript
// tsconfig.json key settings
{
  "compilerOptions": {
    "strict": true,
    "target": "ES2020",
    "module": "ESNext",
    "jsx": "preserve",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

## State Management Patterns

### Global State (Zustand)

```typescript
// /src/features/licensing/model/store.ts
import create from 'zustand';

interface LicensingStore {
  licenses: License[];
  setLicenses: (licenses: License[]) => void;
  isLoading: boolean;
  setLoading: (loading: boolean) => void;
}

export const useLicensingStore = create<LicensingStore>((set) => ({
  licenses: [],
  setLicenses: (licenses) => set({ licenses }),
  isLoading: false,
  setLoading: (loading) => set({ isLoading: loading }),
}));
```

### Server State (React Query)

```typescript
// /src/features/licensing/api/queries.ts
import { useQuery } from '@tanstack/react-query';

export const useLicenses = () => {
  return useQuery({
    queryKey: ['licenses'],
    queryFn: fetchLicenses,
  });
};
```

## Component Patterns

### Feature Components

```typescript
// /src/features/licensing/ui/pharmacist/PharmacistList.tsx
import { useQuery } from '@tanstack/react-query';
import { DataTable } from '@/shared/ui/data-table';
import { usePharmacists } from '../api/queries';

export const PharmacistList = () => {
  const { data, isLoading } = usePharmacists();

  return (
    <DataTable
      data={data}
      columns={pharmacistColumns}
      isLoading={isLoading}
    />
  );
};
```

### Shared Components

```typescript
// /src/shared/ui/form/FormField.tsx
import { FC } from 'react';
import { Label } from '@/shared/ui/label';
import { Input } from '@/shared/ui/input';

interface FormFieldProps {
  label: string;
  name: string;
  type?: string;
  error?: string;
}

export const FormField: FC<FormFieldProps> = ({
  label,
  name,
  type = 'text',
  error,
}) => (
  <div className="space-y-2">
    <Label htmlFor={name}>{label}</Label>
    <Input type={type} id={name} name={name} />
    {error && <p className="text-red-500 text-sm">{error}</p>}
  </div>
);
```

## API Integration

### Service Layer Pattern

```typescript
// /src/shared/api/service.ts
export class ApiService {
  private baseUrl: string;

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }

  async get<T>(endpoint: string): Promise<T> {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      headers: this.getHeaders(),
    });
    return this.handleResponse<T>(response);
  }

  private getHeaders(): HeadersInit {
    return {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${this.getToken()}`,
    };
  }
}
```

## Route Protection

```typescript
// /src/app/(licensing)/layout.tsx
import { withAuth } from '@/shared/auth/withAuth';
import { LicensingLayout } from '@/features/licensing/ui/layout';

export default withAuth(LicensingLayout, ['admin', 'pharmacist']);
```

## Error Handling

```typescript
// /src/shared/lib/error-handling.ts
export class AppError extends Error {
  constructor(
    message: string,
    public code: string,
    public status: number
  ) {
    super(message);
  }
}

export const handleApiError = (error: unknown) => {
  if (error instanceof AppError) {
    // Handle known application errors
    notify.error(error.message);
  } else {
    // Handle unexpected errors
    notify.error('An unexpected error occurred');
    console.error(error);
  }
};
```

## Best Practices

### 1. Component Organization

- Keep components small and focused
- Use composition over inheritance
- Follow Single Responsibility Principle
- Implement proper TypeScript types

### 2. State Management

- Use local state for UI-only state
- Use Zustand for global application state
- Use React Query for server state
- Implement proper loading and error states

### 3. Performance

- Implement proper memoization
- Use React.lazy for code splitting
- Optimize re-renders
- Follow React Query best practices

## Testing Guidelines

```typescript
// /src/features/licensing/ui/__tests__/PharmacistList.test.tsx
import { render, screen } from '@testing-library/react';
import { PharmacistList } from '../PharmacistList';

describe('PharmacistList', () => {
  it('renders list of pharmacists', async () => {
    render(<PharmacistList />);
    expect(await screen.findByRole('table')).toBeInTheDocument();
  });
});
```

For more detailed guidelines, refer to the full [Development Guide](./development-guide.md).
</file>

<file path="docs/06-deployment/README.md">
# PharmacyHub Deployment Guide

This section provides comprehensive documentation on deploying the PharmacyHub application in various environments.

## Table of Contents

1. [Deployment Architecture](#deployment-architecture)
2. [Environment Setup](#environment-setup)
3. [Containerization](#containerization)
4. [CI/CD Pipeline](#cicd-pipeline)
5. [Kubernetes Deployment](#kubernetes-deployment)
6. [Monitoring & Logging](#monitoring--logging)
7. [Scaling Strategies](#scaling-strategies)
8. [Backup & Disaster Recovery](#backup--disaster-recovery)

## Deployment Architecture

The PharmacyHub application is deployed using a containerized approach with Kubernetes orchestration:

```
┌─────────────────────────┐      ┌─────────────────────────┐
│                         │      │                         │
│    CI/CD Pipeline       │      │   Container Registry    │
│    (GitHub Actions)     │      │   (Docker Hub)          │
│                         │      │                         │
└──────────┬──────────────┘      └───────────┬─────────────┘
           │                                 │
           │                                 │
           ▼                                 ▼
┌─────────────────────────────────────────────────────────┐
│                                                         │
│                  Kubernetes Cluster                     │
│                                                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │
│  │ Frontend    │  │ Backend     │  │ Keycloak    │      │
│  │ Pods        │  │ Pods        │  │ Pods        │      │
│  └─────────────┘  └─────────────┘  └─────────────┘      │
│                                                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │
│  │ Database    │  │ Redis       │  │ Monitoring  │      │
│  │ Stateful Set│  │ Cluster     │  │ Stack       │      │
│  └─────────────┘  └─────────────┘  └─────────────┘      │
│                                                         │
└─────────────────────────────────────────────────────────┘
           │                                 │
           │                                 │
           ▼                                 ▼
┌─────────────────────────┐      ┌─────────────────────────┐
│                         │      │                         │
│    Load Balancer        │      │   CDN                   │
│    (Nginx/Traefik)      │      │   (Cloudflare)          │
│                         │      │                         │
└─────────────────────────┘      └─────────────────────────┘
```

## Environment Setup

### Prerequisites

- Docker and Docker Compose
- Kubernetes cluster (EKS, GKE, AKS, or self-hosted)
- Container registry access
- CI/CD platform (GitHub Actions)
- DNS configuration
- SSL certificates

### Environment Variables

The application requires the following environment variables:

```
# API Configuration
NEXT_PUBLIC_API_URL=https://api.pharmacyhub.example.com

# Authentication
NEXT_PUBLIC_KEYCLOAK_URL=https://auth.pharmacyhub.example.com
NEXT_PUBLIC_KEYCLOAK_REALM=pharmacyhub
NEXT_PUBLIC_KEYCLOAK_CLIENT_ID=frontend-client

# Feature Flags
NEXT_PUBLIC_ENABLE_BETA_FEATURES=false

# Monitoring
NEXT_PUBLIC_SENTRY_DSN=https://sentrydsn.example.com
```

## Containerization

### Docker Configuration

The application is containerized using Docker with the following Dockerfile:

```dockerfile
# Build stage
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Production stage
FROM node:18-alpine AS runner
WORKDIR /app

ENV NODE_ENV production

# Copy necessary files
COPY --from=builder /app/next.config.js ./
COPY --from=builder /app/public ./public
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./package.json

# Create a non-root user
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs
RUN chown -R nextjs:nodejs /app
USER nextjs

EXPOSE 3000

# Start the application
CMD ["npm", "start"]
```

### Docker Compose (Development)

For local development, use Docker Compose:

```yaml
version: '3.8'
services:
  frontend:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    volumes:
      - .:/app
      - /app/node_modules
    environment:
      - NODE_ENV=development
      - NEXT_PUBLIC_API_URL=http://localhost:8080
      - NEXT_PUBLIC_KEYCLOAK_URL=http://localhost:8080
      
  keycloak:
    image: quay.io/keycloak/keycloak:25.0.2
    ports:
      - "8080:8080"
    environment:
      - KEYCLOAK_ADMIN=admin
      - KEYCLOAK_ADMIN_PASSWORD=admin
      - KC_DB=postgres
      - KC_DB_URL=jdbc:postgresql://postgres:5432/keycloak
      - KC_DB_USERNAME=keycloak
      - KC_DB_PASSWORD=password
    depends_on:
      - postgres
      
  postgres:
    image: postgres:15-alpine
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_DB=keycloak
      - POSTGRES_USER=keycloak
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

## CI/CD Pipeline

### GitHub Actions Workflow

The application uses GitHub Actions for CI/CD:

```yaml
name: PharmacyHub Frontend CI/CD

on:
  push:
    branches: [main, staging]
  pull_request:
    branches: [main, staging]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      - run: npm ci
      - run: npm run lint
      - run: npm run test
        
  build-and-push:
    needs: test
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
          
      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          push: true
          tags: pharmacyhub/frontend:${{ github.ref == 'refs/heads/main' && 'latest' || 'staging' }}
          
  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        
      - name: Set K8s context
        uses: azure/k8s-set-context@v3
        with:
          kubeconfig: ${{ secrets.KUBE_CONFIG }}
          
      - name: Deploy to environment
        run: |
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            kubectl apply -f k8s/production/
          else
            kubectl apply -f k8s/staging/
          fi
          
      - name: Verify deployment
        run: |
          kubectl rollout status deployment/pharmacyhub-frontend -n ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
```

## Kubernetes Deployment

### Kubernetes Configuration

The application is deployed to Kubernetes using the following manifests:

#### Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pharmacyhub-frontend
  namespace: production
spec:
  replicas: 3
  selector:
    matchLabels:
      app: pharmacyhub-frontend
  template:
    metadata:
      labels:
        app: pharmacyhub-frontend
    spec:
      containers:
      - name: frontend
        image: pharmacyhub/frontend:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 3000
        resources:
          limits:
            cpu: 500m
            memory: 512Mi
          requests:
            cpu: 200m
            memory: 256Mi
        readinessProbe:
          httpGet:
            path: /api/health
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 5
        livenessProbe:
          httpGet:
            path: /api/health
            port: 3000
          initialDelaySeconds: 20
          periodSeconds: 15
        env:
        - name: NODE_ENV
          value: production
        - name: NEXT_PUBLIC_API_URL
          valueFrom:
            configMapKeyRef:
              name: pharmacyhub-config
              key: api-url
        - name: NEXT_PUBLIC_KEYCLOAK_URL
          valueFrom:
            configMapKeyRef:
              name: pharmacyhub-config
              key: keycloak-url
```

#### Service

```yaml
apiVersion: v1
kind: Service
metadata:
  name: pharmacyhub-frontend
  namespace: production
spec:
  selector:
    app: pharmacyhub-frontend
  ports:
  - port: 80
    targetPort: 3000
  type: ClusterIP
```

#### Ingress

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: pharmacyhub-frontend
  namespace: production
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  tls:
  - hosts:
    - app.pharmacyhub.example.com
    secretName: pharmacyhub-frontend-tls
  rules:
  - host: app.pharmacyhub.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: pharmacyhub-frontend
            port:
              number: 80
```

#### HorizontalPodAutoscaler

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: pharmacyhub-frontend
  namespace: production
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: pharmacyhub-frontend
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

## Monitoring & Logging

### Monitoring Stack

The application is monitored using:

1. **Prometheus** - Metrics collection
2. **Grafana** - Visualization and dashboards
3. **Sentry** - Error tracking
4. **ELK Stack** - Centralized logging
5. **Uptime Robot** - External uptime monitoring

### Key Metrics

The following metrics are tracked:

- Page load time
- API response time
- Error rate
- Memory usage
- CPU utilization
- Request volume
- User session count
- Authentication failures

### Alerting

Alerts are configured for the following conditions:

- Error rate exceeds 1%
- API response time > 500ms
- Pod restarts
- Memory usage > 80%
- CPU usage > 70%
- Failed deployments

## Scaling Strategies

### Horizontal Scaling

The application can scale horizontally based on:
- CPU usage
- Memory consumption
- Request volume

### Vertical Scaling

Guidelines for vertical scaling:
- Increase container resources for memory-intensive operations
- Adjust JVM settings for Keycloak instances
- Optimize Next.js build output

### Global Scaling

For global deployment:
- Use multi-region Kubernetes clusters
- Implement geo-routing via CloudFront/Cloudflare
- Deploy read replicas for databases in each region

## Backup & Disaster Recovery

### Backup Strategy

1. **Database Backups**
   - Daily full backups
   - Hourly incremental backups
   - 30-day retention period

2. **Configuration Backups**
   - GitOps approach with all configuration in git
   - Encrypted secrets in HashiCorp Vault
   - Regular export of Kubernetes resources

### Disaster Recovery

1. **Recovery Time Objective (RTO)**: 1 hour
2. **Recovery Point Objective (RPO)**: 15 minutes
3. **Failover Process**:
   - Automated database failover
   - Multi-region deployment capability 
   - Runbooks for manual intervention

### Business Continuity Plan

1. **High Availability Setup**
   - Multi-AZ deployment
   - Database replication
   - Load balancer redundancy

2. **Incident Response**
   - On-call rotation
   - Escalation procedures
   - Communication templates

## Security Considerations

### Network Security

- All traffic encrypted with TLS 1.3
- Network policies restricting pod-to-pod communication
- Web Application Firewall (WAF) for edge protection
- Regular network penetration testing

### Secret Management

- Kubernetes secrets for sensitive configuration
- HashiCorp Vault integration for dynamic secrets
- Rotation policies for all credentials
- Least privilege principle for service accounts

## Reference Environments

| Environment | Purpose | URL | Access |
|-------------|---------|-----|--------|
| Development | Daily development | dev.pharmacyhub-internal.com | VPN access only |
| Staging | Pre-production testing | staging.pharmacyhub.example.com | Authentication required |
| Production | Live environment | app.pharmacyhub.example.com | Public access |
| DR | Disaster recovery | dr.pharmacyhub.example.com | Failover only |
</file>

<file path="docs/07-assets/image-requirements.md">
# PharmacyHub Image Requirements Documentation

## Directory Structure

### 1. Authentication Section
**Directory**: `public/Images/auth/`

| Image Name | Format | Purpose | Specifications |
|------------|--------|---------|----------------|
| login-background.webp | WebP | Login page background | 1920x1080px, subtle medical theme |
| signup-background.webp | WebP | Signup page background | 1920x1080px, professional pharmacy setting |
| profile-placeholder.webp | WebP | Default user avatar | 256x256px, neutral design |
| forgot-password-bg.webp | WebP | Password reset page background | 1920x1080px, minimal design |
| verification-success.webp | WebP | Email verification success | 512x512px, celebratory design |

### 2. Examination Section
**Directory**: `public/Images/exams/`

| Image Name | Format | Purpose | Specifications |
|------------|--------|---------|----------------|
| mcq-test-icon.webp | WebP | MCQ test identifier | 64x64px, clear test symbol |
| past-paper-icon.webp | WebP | Past papers section | 64x64px, document style |
| model-paper-icon.webp | WebP | Model papers indicator | 64x64px, paper with check mark |
| exam-complete-badge.webp | WebP | Completion indicator | 128x128px, achievement design |
| score-certificate.webp | WebP | Certificate template | 800x600px, professional certificate |
| study-materials-icon.webp | WebP | Study resources | 64x64px, book/study symbol |

### 3. Licensing Section
**Directory**: `public/Images/licensing/`

| Image Name | Format | Purpose | Specifications |
|------------|--------|---------|----------------|
| license-certificate-template.webp | WebP | License certificate | 1000x700px, official design |
| official-stamp.webp | WebP | Verification stamp | 256x256px, transparent background |
| verification-badge.webp | WebP | Verified status | 128x128px, trust indicator |
| document-approved-icon.webp | WebP | Approval status | 64x64px, check mark design |
| license-pending-icon.webp | WebP | Pending status | 64x64px, clock/waiting design |
| renewal-reminder-icon.webp | WebP | Renewal notification | 64x64px, alert design |

### 4. Home Section
**Directory**: `public/Images/home/`

| Image Name | Format | Purpose | Specifications |
|------------|--------|---------|----------------|
| hero-pharmacy-main.webp | WebP | Hero section main image | 2000x1000px, modern pharmacy |
| pharmacist-consulting.webp | WebP | Feature section | 800x600px, consultation scene |
| modern-pharmacy-interior.webp | WebP | About section | 1200x800px, interior view |
| team-pharmacists.webp | WebP | Team section | 1200x800px, professional team |
| testimonial-bg.webp | WebP | Testimonials background | 1920x300px, subtle pattern |
| features-collage.webp | WebP | Features showcase | 1200x800px, feature highlights |

### 5. UI Components
**Directory**: `public/Images/ui/`

| Image Name | Format | Purpose | Specifications |
|------------|--------|---------|----------------|
| default-avatar.webp | WebP | Default user image | 256x256px, neutral design |
| loading-spinner.svg | SVG | Loading indicator | Vector, animatable |
| success-check.svg | SVG | Success indicator | Vector, green theme |
| error-alert.svg | SVG | Error indicator | Vector, red theme |
| info-icon.svg | SVG | Information icon | Vector, blue theme |
| warning-icon.svg | SVG | Warning indicator | Vector, yellow theme |
| dropdown-arrow.svg | SVG | Dropdown indicator | Vector, simple design |
| menu-hamburger.svg | SVG | Mobile menu icon | Vector, 3 lines |
| close-icon.svg | SVG | Close/dismiss icon | Vector, X design |
| search-icon.svg | SVG | Search functionality | Vector, magnifying glass |

### 6. Logo Assets
**Directory**: `public/Images/logos/`

| Image Name | Format | Purpose | Specifications |
|------------|--------|---------|----------------|
| pharmacyhub-main.webp | WebP | Primary logo | 512x512px, full color |
| pharmacyhub-dark.webp | WebP | Dark theme logo | 512x512px, light colors |
| pharmacyhub-light.webp | WebP | Light theme logo | 512x512px, dark colors |
| favicon.ico | ICO | Browser favicon | 16x16px, 32x32px variants |
| app-icon-192.png | PNG | PWA icon small | 192x192px, app icon |
| app-icon-512.png | PNG | PWA icon large | 512x512px, app icon |

## Image Specifications

### General Requirements
- All photographic images should use WebP format for better compression
- Icons should use SVG format for scalability
- Images should be optimized for web delivery
- All images should maintain consistent style and branding
- Responsive image variants should be provided where needed

### Resolution Guidelines
- Photographs: Minimum 2x for retina displays
- Icons: Multiple sizes (24px, 36px, 48px)
- Logos: Multiple resolutions for different use cases
- Background images: Optimal resolution for target display size

### Accessibility Considerations
- Maintain sufficient color contrast ratios
- Provide alt text descriptions in implementation
- Ensure text overlays remain readable
- Consider color-blind friendly design

### Performance Optimization
- Compress all images appropriately
- Use lazy loading for non-critical images
- Implement responsive loading using srcset
- Cache-control headers for optimal delivery

## Implementation Notes

1. All images should be stored in their respective directories as outlined above
2. Use appropriate image optimization tools before deployment
3. Implement lazy loading for images below the fold
4. Ensure proper caching strategies are in place
5. Consider implementing a CDN for better delivery
6. Follow accessibility guidelines when implementing images in the UI

This documentation will help maintain consistent image usage throughout the PharmacyHub application while ensuring optimal performance and accessibility.
</file>

<file path="docs/07-assets/README.md">
# PharmacyHub Assets Guidelines

This section provides comprehensive specifications and guidelines for managing images and other assets in the PharmacyHub application.

## Table of Contents

1. [Directory Structure](#directory-structure)
2. [Image Specifications](#image-specifications)
3. [Icon Guidelines](#icon-guidelines)
4. [Animation Guidelines](#animation-guidelines)
5. [Accessibility Requirements](#accessibility-requirements)
6. [Performance Optimization](#performance-optimization)
7. [Implementation Notes](#implementation-notes)

## Directory Structure

All assets are organized in a structured directory hierarchy:

```
/public/
├── Images/
│   ├── auth/          # Authentication-related images
│   ├── exams/         # Examination-related images
│   ├── licensing/     # Licensing-related images
│   ├── home/          # Homepage assets
│   ├── ui/            # UI component assets
│   └── logos/         # Logo assets
└── fonts/             # Typography assets
```

### 1. Authentication Section
**Directory**: `public/Images/auth/`

| Image Name | Format | Purpose | Specifications |
|------------|--------|---------|----------------|
| login-background.webp | WebP | Login page background | 1920x1080px |
| signup-background.webp | WebP | Signup page background | 1920x1080px |
| profile-placeholder.webp | WebP | Default user avatar | 256x256px |
| forgot-password-bg.webp | WebP | Password reset background | 1920x1080px |
| verification-success.webp | WebP | Email verification success | 512x512px |

### 2. Examination Section
**Directory**: `public/Images/exams/`

| Image Name | Format | Purpose | Specifications |
|------------|--------|---------|----------------|
| mcq-test-icon.webp | WebP | MCQ test identifier | 64x64px |
| past-paper-icon.webp | WebP | Past papers section | 64x64px |
| model-paper-icon.webp | WebP | Model papers indicator | 64x64px |
| exam-complete-badge.webp | WebP | Completion indicator | 128x128px |
| score-certificate.webp | WebP | Certificate template | 800x600px |
| study-materials-icon.webp | WebP | Study resources | 64x64px |

### 3. Licensing Section
**Directory**: `public/Images/licensing/`

| Image Name | Format | Purpose | Specifications |
|------------|--------|---------|----------------|
| license-certificate-template.webp | WebP | License certificate | 1000x700px |
| official-stamp.webp | WebP | Verification stamp | 256x256px |
| verification-badge.webp | WebP | Verified status | 128x128px |
| document-approved-icon.webp | WebP | Approval status | 64x64px |
| license-pending-icon.webp | WebP | Pending status | 64x64px |
| renewal-reminder-icon.webp | WebP | Renewal notification | 64x64px |

### 4. Home Section
**Directory**: `public/Images/home/`

| Image Name | Format | Purpose | Specifications |
|------------|--------|---------|----------------|
| hero-pharmacy-main.webp | WebP | Hero section main image | 2000x1000px |
| pharmacist-consulting.webp | WebP | Feature section | 800x600px |
| modern-pharmacy-interior.webp | WebP | About section | 1200x800px |
| team-pharmacists.webp | WebP | Team section | 1200x800px |
| testimonial-bg.webp | WebP | Testimonials background | 1920x300px |
| features-collage.webp | WebP | Features showcase | 1200x800px |

### 5. UI Components
**Directory**: `public/Images/ui/`

| Image Name | Format | Purpose | Specifications |
|------------|--------|---------|----------------|
| default-avatar.webp | WebP | Default user image | 256x256px |
| loading-spinner.svg | SVG | Loading indicator | Vector, animatable |
| success-check.svg | SVG | Success indicator | Vector, green theme |
| error-alert.svg | SVG | Error indicator | Vector, red theme |
| info-icon.svg | SVG | Information icon | Vector, blue theme |
| warning-icon.svg | SVG | Warning indicator | Vector, yellow theme |
| dropdown-arrow.svg | SVG | Dropdown indicator | Vector, simple design |
| menu-hamburger.svg | SVG | Mobile menu icon | Vector, 3 lines |
| close-icon.svg | SVG | Close/dismiss icon | Vector, X design |
| search-icon.svg | SVG | Search functionality | Vector, magnifying glass |

### 6. Logo Assets
**Directory**: `public/Images/logos/`

| Image Name | Format | Purpose | Specifications |
|------------|--------|---------|----------------|
| pharmacyhub-main.webp | WebP | Primary logo | 512x512px, full color |
| pharmacyhub-dark.webp | WebP | Dark theme logo | 512x512px, light colors |
| pharmacyhub-light.webp | WebP | Light theme logo | 512x512px, dark colors |
| favicon.ico | ICO | Browser favicon | 16x16px, 32x32px variants |
| app-icon-192.png | PNG | PWA icon small | 192x192px, app icon |
| app-icon-512.png | PNG | PWA icon large | 512x512px, app icon |

## Image Specifications

### General Requirements
- All photographic images should use WebP format for better compression
- Icons should use SVG format for scalability
- Images should be optimized for web delivery
- All images should maintain consistent style and branding
- Responsive image variants should be provided where needed

### Resolution Guidelines
- Photographs: Minimum 2x for retina displays
- Icons: Multiple sizes (24px, 36px, 48px)
- Logos: Multiple resolutions for different use cases
- Background images: Optimal resolution for target display size

### Format Selection Guidelines

| Content Type | Preferred Format | Fallback Format | Notes |
|--------------|------------------|-----------------|-------|
| Photographs | WebP | JPEG | Use progressive JPEG for fallback |
| Icons/UI elements | SVG | PNG | Use SVG whenever possible for scalability |
| Logos | SVG | PNG | Include PNG fallbacks for older browsers |
| Illustrations | SVG | PNG | Vector preferred for illustrations |
| Complex images | WebP | PNG | Use when transparency needed |
| Animations | SVG/CSS | GIF | Prefer CSS animations where possible |

## Icon Guidelines

### Icon Design Principles

1. **Consistency**: All icons should follow a consistent style:
   - 2px stroke weight for outlined icons
   - Rounded corners (2px radius)
   - Consistent padding within bounding box
   - Same color palette

2. **Sizing**: 
   - Base size: 24x24px
   - Touch targets: Minimum 44x44px
   - Optional larger variants: 36px, 48px

3. **Color**:
   - Use currentColor for SVG fill/stroke to inherit from text
   - Maintain sufficient contrast (minimum 3:1 ratio)
   - Support both light and dark themes

### Icon Implementation

Use icons as React components with the following pattern:

```tsx
// Example icon component
import { FC, SVGProps } from 'react';

export const SearchIcon: FC<SVGProps<SVGSVGElement>> = (props) => (
  <svg
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
    {...props}
  >
    <circle cx="11" cy="11" r="8" />
    <line x1="21" y1="21" x2="16.65" y2="16.65" />
  </svg>
);
```

## Animation Guidelines

### Animation Principles

1. **Purpose-driven**: Animations should:
   - Guide user attention
   - Provide feedback
   - Express brand personality
   - Improve perceived performance

2. **Performance**:
   - Animate only transform and opacity properties when possible
   - Use CSS animations for simple transitions
   - Use requestAnimationFrame for complex JS animations
   - Consider reducing motion for accessibility

3. **Timing**:
   - Quick feedback: 100-200ms
   - Standard transitions: 200-300ms
   - Expressive animations: 400-600ms
   - Never exceed 1000ms for UI animations

### Animation Implementation

```css
/* Example animation variables */
:root {
  --animation-speed-fast: 100ms;
  --animation-speed-normal: 250ms;
  --animation-speed-slow: 500ms;
  --animation-easing-standard: cubic-bezier(0.4, 0.0, 0.2, 1);
  --animation-easing-decelerate: cubic-bezier(0.0, 0.0, 0.2, 1);
  --animation-easing-accelerate: cubic-bezier(0.4, 0.0, 1, 1);
}

/* Example button hover animation */
.button {
  transition: transform var(--animation-speed-fast) var(--animation-easing-standard),
              background-color var(--animation-speed-normal) var(--animation-easing-standard);
}

.button:hover {
  transform: translateY(-2px);
}
```

## Accessibility Requirements

### Image Accessibility

1. **Alt Text**:
   - All images must have appropriate alt text
   - Decorative images should use empty alt (`alt=""`)
   - Complex images should have detailed descriptions
   - Icons should have aria-label when used alone

2. **Color Contrast**:
   - All visual elements must maintain 4.5:1 contrast ratio
   - UI controls and graphics require 3:1 minimum contrast
   - Test all elements in both light and dark themes

3. **Motion Sensitivity**:
   - Respect `prefers-reduced-motion` media query
   - Provide non-animated alternatives
   - Avoid flashing content (3 flashes or below per second)

### Implementation Example

```tsx
// Accessible image component
const AccessibleImage = ({ src, alt, isDecorative, ...props }) => {
  return (
    <img 
      src={src} 
      alt={isDecorative ? "" : alt}
      aria-hidden={isDecorative}
      {...props}
    />
  );
};

// Respecting reduced motion
const MotionSafeAnimation = ({ children }) => {
  return (
    <div className="animate-fade-in motion-safe:animate-bounce">
      {children}
    </div>
  );
};
```

## Performance Optimization

### Image Optimization Guidelines

1. **Responsive Images**:
   - Use `<picture>` element with multiple sources
   - Provide WebP with fallbacks
   - Implement srcset for different viewport sizes
   - Use appropriate sizes attribute

2. **Lazy Loading**:
   - Implement native lazy loading (`loading="lazy"`)
   - Use intersection observer for custom implementations
   - Prioritize above-the-fold images

3. **Optimization Tools**:
   - Use Next.js Image component when possible
   - Implement automated image optimization in build pipeline
   - Target WebP format with quality 75-85
   - Strip metadata from production images

### Implementation Example

```tsx
// Next.js Image component usage
import Image from 'next/image';

const ResponsiveHero = () => {
  return (
    <Image
      src="/Images/home/hero-pharmacy-main.webp"
      alt="Modern pharmacy interior with pharmacist helping customer"
      width={2000}
      height={1000}
      priority={true}
      quality={85}
      sizes="(max-width: 768px) 100vw, (max-width: 1200px) 80vw, 1200px"
    />
  );
};

// Fallback for custom elements
const ResponsiveImageFallback = ({ src, alt, ...props }) => {
  return (
    <picture>
      <source 
        srcSet={`${src}.webp`} 
        type="image/webp" 
      />
      <source 
        srcSet={`${src}.jpg`} 
        type="image/jpeg" 
      />
      <img 
        src={`${src}.jpg`} 
        alt={alt}
        loading="lazy"
        {...props}
      />
    </picture>
  );
};
```

## Implementation Notes

1. **Asset Management**
   - All new assets should be added to the appropriate directory
   - Assets should be optimized before committing to repository
   - Use descriptive, kebab-case filenames
   - Include image dimensions in filename when appropriate

2. **Version Control**
   - Store optimized assets in git repository
   - Use LFS for large binary files
   - Document significant asset changes in commit messages

3. **Build Pipeline**
   - Automate WebP conversion in build process
   - Generate responsive image sizes automatically
   - Include image hashes in filenames for cache busting

For detailed image specifications, see the [Image Requirements Guide](./image-requirements.md).
</file>

<file path="docs/api-client-architecture.md">
# PharmacyHub API Client Architecture

This document outlines the architecture of the centralized API client implementation for the PharmacyHub frontend application. The API client is designed to provide a consistent, type-safe, and maintainable approach to handling backend communication.

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Key Components](#key-components)
3. [API Client](#api-client)
4. [React Query Integration](#react-query-integration)
5. [API Services](#api-services)
6. [Usage Examples](#usage-examples)
7. [Best Practices](#best-practices)

## Architecture Overview

The API client architecture is built with the following principles in mind:

- **Centralization**: All API communication is consolidated in a single location.
- **Type Safety**: Strong TypeScript typing throughout the entire API layer.
- **Consistency**: Standard patterns for error handling, authentication, and data transformation.
- **Maintainability**: Modular architecture that's easy to extend and update.
- **Performance**: Optimized data fetching with caching, deduplication, and error handling.

The architecture consists of several layers:

1. **Core API Client**: Low-level fetch wrapper with error handling, authentication, and request/response processing.
2. **TanStack Query Integration**: React hooks for data fetching with caching, refetching, and state management.
3. **Service Layer**: Domain-specific services that encapsulate API endpoints for different entities.
4. **Feature-specific API Modules**: API functionality scoped to specific application features.

## Key Components

### Core Libraries

- **TanStack Query (React Query)**: Library for fetching, caching, and updating server state in React applications.
- **Fetch API**: Native browser API for making HTTP requests.

### Project Components

- `/lib/api/apiClient.ts`: Core API client implementation.
- `/lib/query/queryClient.ts`: TanStack Query client configuration.
- `/lib/api/hooks.ts`: React hooks for API communication.
- `/lib/api/createService.ts`: Factory functions for creating API services.
- `/lib/api/services/*`: Domain-specific API services.
- `/features/*/api/*`: Feature-specific API modules.

## API Client

The API client (`apiClient.ts`) provides a consistent interface for making HTTP requests with the following features:

- **Authentication**: Automatic token inclusion and refresh.
- **Error Handling**: Consistent error processing and reporting.
- **Request Deduplication**: Prevents duplicate concurrent requests.
- **Timeout Handling**: Configurable request timeouts.
- **Retry Logic**: Automatic retries for failed requests.
- **TypeScript Integration**: Full type safety for requests and responses.

### Key Methods

```typescript
// Basic HTTP methods
get<T>(endpoint: string, options?: RequestOptions): Promise<ApiResponse<T>>
post<T>(endpoint: string, data?: unknown, options?: RequestOptions): Promise<ApiResponse<T>>
put<T>(endpoint: string, data?: unknown, options?: RequestOptions): Promise<ApiResponse<T>>
patch<T>(endpoint: string, data?: unknown, options?: RequestOptions): Promise<ApiResponse<T>>
delete<T>(endpoint: string, options?: RequestOptions): Promise<ApiResponse<T>>

// Core request method
request<T>(endpoint: string, options?: RequestOptions): Promise<ApiResponse<T>>
```

### Response Structure

All API responses follow a consistent structure:

```typescript
interface ApiResponse<T> {
  data: T | null;       // Response data (if successful)
  error: ApiError | null; // Error object (if failed)
  status: number;       // HTTP status code
}
```

## React Query Integration

The React Query integration provides hooks for data fetching with the following features:

- **Caching**: Automatic caching of query results.
- **Background Refetching**: Updates data in the background.
- **Stale-While-Revalidate**: Shows stale data while fetching fresh data.
- **Pagination**: Support for paginated queries.
- **Infinite Queries**: Support for "load more" patterns.
- **Optimistic Updates**: Update UI before server confirmation.
- **Prefetching**: Load data before it's needed.

### Key Hooks

```typescript
// Data fetching hooks
useApiQuery<TData>(queryKey, endpoint, options)
useApiPaginatedQuery<TData>(queryKey, endpoint, paginationParams, options)
useApiInfiniteQuery<TData>(queryKey, endpoint, options)

// Data mutation hooks
useApiMutation<TData, TVariables>(endpoint, options)
useApiPut<TData, TVariables>(endpoint, options)
useApiPatch<TData, TVariables>(endpoint, options)
useApiDelete<TData>(endpoint, options)
```

## API Services

The service layer provides domain-specific services for different entities:

- **User Service**: User profile and account management.
- **Auth Service**: Authentication and authorization.
- **Exam Service**: Exam management and submission.
- **Progress Service**: Progress tracking and statistics.

Each service provides type-safe methods for interacting with specific API endpoints.

### Service Factory

The `createApiService` function creates standardized CRUD operations for any entity:

```typescript
const userService = createApiService<User>('/users');

// Generated methods:
userService.getAll()
userService.getById(id)
userService.create(data)
userService.update(id, data)
userService.patch(id, data)
userService.remove(id)
```

For more complex services, the `createExtendedApiService` function allows adding custom methods:

```typescript
const authService = createExtendedApiService<User, {
  login: (credentials: LoginCredentials) => Promise<ApiResponse<AuthResponse>>;
}>('/auth', {
  login: async (credentials) => {
    return apiClient.post<AuthResponse>('/auth/login', credentials);
  }
});
```

## Usage Examples

### Basic Data Fetching

```tsx
import { useApiQuery } from '@/lib/api';
import { User } from '@/lib/api/services';

function UserProfile({ userId }) {
  const { data, isLoading, error } = useApiQuery<User>(
    ['users', userId],
    `/users/${userId}`
  );

  if (isLoading) return <Loading />;
  if (error) return <ErrorMessage error={error} />;
  
  return <UserProfileDisplay user={data} />;
}
```

### Using Services

```tsx
import { userService } from '@/lib/api/services';
import { useQuery } from '@tanstack/react-query';

function UserList() {
  const { data, isLoading } = useQuery(['users'], () => 
    userService.getAll().then(response => {
      if (response.error) throw response.error;
      return response.data;
    })
  );

  // ...
}
```

### Data Mutations

```tsx
import { useApiMutation } from '@/lib/api';

function CreateUserForm() {
  const { mutate, isLoading } = useApiMutation<User, NewUserData>(
    '/users',
    {
      onSuccess: (data) => {
        // Handle successful creation
      }
    }
  );

  const handleSubmit = (formData) => {
    mutate(formData);
  };

  // ...
}
```

### Using Query Keys

```tsx
import { apiQueryKeys, useApiQuery } from '@/lib/api';

function ExamDetail({ examId }) {
  const { data } = useApiQuery(
    apiQueryKeys.exams.detail(examId),
    `/exams/${examId}`
  );

  // ...
}
```

## Best Practices

1. **Use Query Keys Consistently**:
   - Leverage the `apiQueryKeys` object for consistent query keys.
   - Structure keys hierarchically (e.g., `['users', userId, 'posts']`).

2. **Handle Errors Properly**:
   - Check for `response.error` before using `response.data`.
   - Use error boundaries for top-level error handling.

3. **Optimize Refetching**:
   - Configure appropriate `staleTime` and `cacheTime` for each query.
   - Use `refetchOnWindowFocus` and `refetchOnMount` based on data freshness requirements.

4. **Leverage Type Safety**:
   - Define interfaces for all request/response data.
   - Use generics with API hooks for type inference.

5. **Structure API Modules**:
   - Keep domain-specific logic in service files.
   - Organize feature-specific API code within feature directories.

6. **Use Optimistic Updates**:
   - Update the UI immediately before server confirmation.
   - Handle rollback if the server request fails.

7. **Implement Authentication Properly**:
   - Use the `requiresAuth` option for endpoints that need authentication.
   - Handle token refresh transparently.

By following these principles and best practices, the PharmacyHub API client architecture provides a robust foundation for interacting with the backend services in a consistent, type-safe, and maintainable way.
</file>

<file path="docs/api-client-pattern.md">
# API Client Design Pattern with React Query

This document outlines the recommended design pattern for implementing API client functionality with React Query in the PharmacyHub frontend application.

## Core Architecture

The API client implementation follows a layered architecture:

1. **Base API Client**: A generic client that handles HTTP requests, authentication, and error handling
2. **Feature-specific API Services**: Domain-specific wrappers around the base client
3. **React Query Hooks**: Custom hooks that expose data fetching and mutations with proper caching

## Base API Client

Located at `src/shared/api/apiClient.ts`, this class provides:

- Request handling with proper error management
- Authentication token management
- Standard response formatting
- Convenience methods for different HTTP methods (GET, POST, etc.)

```typescript
// Example base client method
async get<T>(endpoint: string, options?: RequestOptions): Promise<ApiResponse<T>> {
  return this.request<T>(endpoint, { ...options, method: 'GET' });
}
```

## Feature-specific API Services

Each feature should have its own API service that:

- Uses the base API client for network requests
- Defines feature-specific endpoints
- Handles data transformation if needed
- Provides type safety with proper interfaces

```typescript
// Example from examApi.ts
const examApi = {
  getExamById: async (examId: number): Promise<Exam> => {
    const response = await apiClient.get<Exam>(`/exams/${examId}`);
    if (response.error) throw response.error;
    if (!response.data) throw new Error('Exam not found');
    return response.data;
  },
  // ...other methods
}
```

## React Query Hooks Layer

The React Query hooks layer:

- Defines query keys for proper caching
- Encapsulates API calls using React Query's `useQuery` and `useMutation`
- Provides loading, error, and data states
- Handles cache invalidation and updates

```typescript
// Example query keys
export const EXAM_KEYS = {
  all: ['exams'] as const,
  lists: () => [...EXAM_KEYS.all, 'list'] as const,
  detail: (id: number) => [...EXAM_KEYS.all, 'detail', id] as const,
  // ...other keys
};

// Example hook
export function useExam(examId: number | undefined) {
  return useQuery({
    queryKey: EXAM_KEYS.detail(examId as number),
    queryFn: () => examApi.getExamById(examId as number),
    enabled: !!examId,
  });
}
```

## Best Practices

### 1. Query Key Structure

Use structured, predictable query keys that:

- Are organized hierarchically (from general to specific)
- Include relevant parameters that affect the query result
- Support proper cache invalidation

```typescript
// Good pattern for query keys
const KEYS = {
  all: ['resource'] as const,
  lists: () => [...KEYS.all, 'list'] as const,
  list: (filters: object) => [...KEYS.lists(), { filters }] as const,
  details: () => [...KEYS.all, 'detail'] as const,
  detail: (id: string | number) => [...KEYS.details(), id] as const,
};
```

### 2. Error Handling

Throw errors from the API layer and handle them in components:

```typescript
// In API service
getResource: async (id: number): Promise<Resource> => {
  const response = await apiClient.get<Resource>(`/resources/${id}`);
  if (response.error) throw response.error;
  return response.data;
}

// In component
const { data, error, isLoading } = useResourceQuery(id);
if (error) {
  return <ErrorComponent message={error.message} />;
}
```

### 3. Data Transformation

Transform data at the API service level when needed:

```typescript
getTransformedData: async (): Promise<TransformedType> => {
  const response = await apiClient.get<RawType>('/endpoint');
  if (response.error) throw response.error;
  return transformData(response.data);
}
```

### 4. Mutations

For data modifications, use React Query mutations:

```typescript
const createMutation = useMutation({
  mutationFn: (newData) => api.createResource(newData),
  onSuccess: (data) => {
    // Invalidate and refetch queries that may have been affected
    queryClient.invalidateQueries({ queryKey: KEYS.lists() });
    // Or directly update the cache
    queryClient.setQueryData(KEYS.detail(data.id), data);
  },
});
```

### 5. Composition

Compose complex data requirements using multiple hooks:

```typescript
function useResourceWithRelations(id) {
  const resource = useResource(id);
  const relatedItems = useRelatedItems(id, {
    enabled: !!resource.data,
  });
  
  return {
    resource: resource.data,
    relatedItems: relatedItems.data,
    isLoading: resource.isLoading || relatedItems.isLoading,
    error: resource.error || relatedItems.error,
  };
}
```

## Implementation Examples

The exams feature demonstrates this pattern:

1. **API Client**: Base HTTP client with authentication
2. **API Service**: Exam-specific API methods
3. **Query Hooks**: React Query hooks for exams data
4. **UI Components**: Components that use the hooks

## Migration Guide

When implementing new features or refactoring existing ones:

1. Start by defining the API service using the base client
2. Create React Query hooks with proper query keys
3. Build UI components that consume these hooks
4. Ensure proper error handling and loading states

## Benefits

This pattern provides:

1. **Separation of concerns**: Clear boundaries between API, data management, and UI
2. **Consistency**: Unified approach to API access across the application
3. **Caching**: Automatic caching and synchronization with server state
4. **Performance**: Reduced network requests and optimized rendering
5. **Developer experience**: Simple, declarative API for data fetching
</file>

<file path="docs/auth-debugging.md">
# Authentication Debugging Guide

## Overview

This document provides guidance on debugging authentication issues in the PharmacyHub application, specifically related to API requests that require authentication.

## Common Issues

### Missing Authorization Header

If API requests are returning 401 Unauthorized or 403 Forbidden status codes, the most common issue is a missing or invalid Authorization header.

To troubleshoot:

1. Check the browser's Network tab in developer tools
2. Look for requests to `/api/exams/published` endpoint
3. Verify if the Authorization header is present in the request headers

### Fixing Authorization Issues

We've implemented a robust token extraction system that tries multiple methods to find and use a valid authentication token:

1. Checks localStorage for common token names:
   - `auth_token`
   - `token`
   - `jwtToken`

2. Checks sessionStorage for similar token names

3. Extracts tokens from cookies:
   - Standard auth cookies (containing 'token', 'auth', 'jwt')
   - JSESSIONID cookie
   - PGADMIN_LANGUAGE cookie format from the screenshot
   - Any cookie containing a JWT-like format

4. Adds the token as a Bearer token in the Authorization header

## Debugging Tools

### Token Extractor Script

We've created a token extractor script that can be run in the browser console:

```javascript
// Paste the content of src/features/exams/api/tokenExtractor.js here
```

This will output all potential tokens found in your browser's storage and cookies.

### Debug Mode

The examService includes a debug mode that can be enabled:

1. Open `src/features/exams/api/examService.ts`
2. Set `const DEBUG_AUTH = true;`
3. This will:
   - Add detailed console logging
   - Inject authentication headers into all fetch requests
   - Output token extraction attempts

## Authentication Flow

The authentication flow should work as follows:

1. User logs in through authentication endpoint
2. Token is stored (in localStorage, sessionStorage, or cookies)
3. examService extracts the token for each API request
4. Token is sent in the Authorization header
5. Backend validates the token and allows access to protected resources

## Troubleshooting Steps

If authentication is still failing:

1. Check if you're properly logged in
2. Verify the token format matches what the backend expects
3. Check token expiration (JWT tokens have expiry)
4. Ensure the backend CORS configuration accepts the Authorization header

## Manual Testing

You can manually test the API authentication with fetch:

```javascript
fetch('http://localhost:8080/api/exams/published', {
  method: 'GET',
  headers: {
    'Authorization': 'Bearer YOUR_TOKEN_HERE',
    'Content-Type': 'application/json'
  }
})
.then(response => {
  console.log('Status:', response.status);
  return response.json();
})
.then(data => console.log(data))
.catch(err => console.error(err));
```

Replace `YOUR_TOKEN_HERE` with the token you extract from storage.
</file>

<file path="docs/auth-feature-refactoring.md">
# Auth Feature Refactoring

## Overview
This document outlines the refactoring of the authentication feature in the PharmacyHub frontend to follow the feature-based architecture pattern.

## Changes Made

1. **Created Auth API Services**
   - Created `userService.ts` with methods for user profile operations
   - Created `securityService.ts` with methods for access control operations
   - Updated the API barrel export in `features/auth/api/index.ts`

2. **Moved Auth Hooks**
   - Moved `useAuth.ts` from `src/hooks` to `src/features/auth/hooks`
   - Updated imports to reference the new API services
   - Created barrel exports for hooks in `features/auth/hooks/index.ts`

3. **Moved Auth UI Components**
   - Moved components from `src/components/auth` to `src/features/auth/ui/components`
   - Moved guards from `src/components/guards` to `src/features/auth/ui/guards`
   - Moved security components from `src/components/security` to `src/features/auth/ui/security`
   - Created appropriate barrel exports at each level

4. **Backward Compatibility**
   - Created re-export files at the old locations to maintain compatibility with existing imports
   - Added deprecation notices to encourage migration to the new import paths

5. **Feature Exports**
   - Created a barrel export file at `src/features/auth/index.ts` to provide a clean public API for the auth feature
   - Structured exports by category (api, hooks, ui)

## Architecture Benefits

This refactoring aligns with the feature-based architecture pattern seen in other parts of the application:

1. **Cohesion**: All auth-related code is now in a single feature directory
2. **Isolation**: Auth feature has clear boundaries and a well-defined public API
3. **Discoverability**: Easier to find and understand auth-related code
4. **Consistency**: Follows the same pattern as other features in the application

## Feature Structure

```
src/features/auth/
├── api/                 # API services
│   ├── authService.ts   # Auth API service
│   ├── userService.ts   # User profile service
│   ├── securityService.ts # Security/access control service
│   └── index.ts         # API barrel exports
├── hooks/               # React hooks
│   ├── useAuth.ts       # Main auth hook
│   └── index.ts         # Hooks barrel exports
├── ui/                  # UI components
│   ├── components/      # Basic UI components
│   │   ├── AuthLoading.tsx
│   │   ├── Unauthorized.tsx
│   │   └── index.ts
│   ├── guards/          # Auth guard components
│   │   ├── AuthGuard.tsx
│   │   ├── RoleGuards.tsx
│   │   ├── RequireAuth.tsx
│   │   ├── types.ts
│   │   └── index.ts
│   ├── security/        # RBAC components
│   │   ├── PermissionCheck.tsx
│   │   └── index.ts
│   └── index.ts         # UI barrel exports
└── index.ts             # Feature barrel exports
```

## Next Steps

1. Gradually update imports in other files to use the new paths (`@/features/auth/...`)
2. Consider removing the backward compatibility layer in a future release
3. Review other hooks for potential migration to the feature-based pattern
4. Update documentation and examples to use the new import paths
</file>

<file path="docs/auth-refactoring-cleanup.md">
# Auth Feature Refactoring Cleanup

This document outlines the cleanup steps needed to complete the auth feature refactoring. The refactoring has organized the auth feature into a more semantically meaningful structure:

## New Structure

```
src/features/auth/
├── api/                 # API services
├── hooks/               # React hooks
├── ui/
│   ├── auth-flow/       # Authentication flow components (login, register)
│   ├── feedback/        # Feedback components (loading, error states)
│   ├── protection/      # Auth guards and protection components
│   ├── rbac/            # Role-based access control components
│   └── index.ts         # UI barrel exports
└── index.ts             # Feature barrel exports
```

## Cleanup Commands

The following commands should be executed in the terminal to clean up redundant directories and files:

```bash
# Remove redundant directories
rm -rf "D:/code/PharmacyHub/pharmacyhub-frontend/src/features/auth/ui/components"
rm -rf "D:/code/PharmacyHub/pharmacyhub-frontend/src/features/auth/ui/guards"
rm -rf "D:/code/PharmacyHub/pharmacyhub-frontend/src/features/auth/ui/security"

# Ensure backward compatibility folders in components directory have updated imports
# (These should import from the new locations)
```

## Manual Steps

If the above commands don't work in your environment, manually delete the following directories:

1. `src/features/auth/ui/components`
2. `src/features/auth/ui/guards`
3. `src/features/auth/ui/security`

## Backward Compatibility

Backward compatibility is maintained through re-export files in the original locations. If you encounter any import errors, check that the compatibility files are properly importing from the new locations.

## Import Update Guide

Update imports in your application to use the new structure:

### Before:
```typescript
import { AuthGuard } from '@/components/auth/AuthGuard';
import { RequireAuth } from '@/components/guards/RequireAuth';
import { PermissionCheck } from '@/components/security/PermissionCheck';
```

### After:
```typescript
import { AuthGuard } from '@/features/auth/ui/protection';
import { RequireAuth } from '@/features/auth/ui/protection';
import { PermissionCheck } from '@/features/auth/ui/rbac';
```

Or, using the barrel exports:
```typescript
import { AuthGuard, RequireAuth } from '@/features/auth/ui';
import { PermissionCheck } from '@/features/auth/ui';
```
</file>

<file path="docs/authentication-integration.md">
# Authentication Integration for PharmacyHub Exam Feature

## Overview

This document explains how authentication has been integrated with the Exam feature to ensure proper authorization.

## Implementation Details

### 1. Token Management

The exam service now includes utility functions to retrieve authentication tokens and add them to API requests:

```typescript
// Function to get the auth token from local storage
const getAuthToken = (): string | null => {
  if (typeof window !== 'undefined') {
    return localStorage.getItem('auth_token');
  }
  return null;
};

// Function to add auth header to request options
const addAuthHeader = (options: Record<string, any>): Record<string, any> => {
  const token = getAuthToken();
  if (token) {
    options.headers = {
      ...options.headers,
      'Authorization': `Bearer ${token}`
    };
  }
  return options;
};
```

### 2. Authenticated API Requests

All exam API methods have been updated to include authentication headers:

```typescript
// Example for getPublishedExams
let options = {
  method: 'GET',
  mode: 'cors',
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
    'Cache-Control': 'no-cache',
    'Pragma': 'no-cache'
  },
  credentials: 'include'
};

// Add authentication headers
options = addAuthHeader(options);
```

### 3. Enhanced Error Handling

The UI has been improved to handle authentication errors more gracefully:

- Detects 401/403 errors and shows more specific guidance
- Provides a direct login button when authentication is required
- Shows relevant troubleshooting steps based on the error type

## Security Considerations

1. **Token Storage**: Authentication tokens are stored in localStorage. For production, consider using more secure options like HttpOnly cookies.

2. **Request Protection**: All exam-related endpoints require authentication as per backend security configuration.

3. **Error Exposure**: Care has been taken to provide helpful error messages without exposing sensitive details.

## Usage

When a user tries to access the exam feature:

1. If they're already authenticated, their token will be included in requests
2. If they're not authenticated or their token is invalid, they'll see an error with a login button
3. After logging in, they can return to the exams page and access protected content

## Integration Points

This integration connects with the existing authentication system through:

1. The standard token storage in localStorage
2. JWT validation on the backend through Spring Security
3. Protected API routes as defined in SecurityConfig.java

## Testing

To test the authentication integration:

1. Clear localStorage and try to access exams (should show auth error)
2. Login with valid credentials
3. Return to exams page (should now load successfully)
4. Check network requests to confirm Authorization headers are present
</file>

<file path="docs/code-cleanup.md">
# PharmacyHub Code Cleanup Guide

This document outlines redundant files that can be safely removed as part of code cleanup, along with their updated alternatives.

## Redundant Files to Remove

### 1. Legacy API Client

**File to remove:** `src/lib/api.ts`

**Replacement:** Use the shared API client pattern with domain-specific API services:
- Base API Client: `src/shared/api/apiClient.ts`
- Exam API Service: `src/features/exams/api/examApi.ts`
- Progress API Service: `src/features/progress/api/progressApi.ts`

### 2. Legacy Exam Hook

**File to remove:** `src/hooks/useExam.ts`

**Replacement:** Use the new React Query hooks:
- Exam Hooks: `src/features/exams/hooks/useExamQueries.ts`

### 3. Legacy Progress Hook

**File to remove:** `src/hooks/useProgress.ts` 

**Replacement:** Use the new React Query hooks:
- Progress Hooks: `src/features/progress/hooks/useProgressQueries.ts`

## Required Updates

When removing these files, ensure that all components that depend on them are updated to use the replacements:

### ExamLayout Component

Updated reference from:
```typescript
import { useExam } from '@/hooks/useExam';
```

To:
```typescript
import { useExamSession } from '@/features/exams/hooks/useExamQueries';
```

And modify the hook call:
```typescript
const { ... } = useExamSession(parseInt(examId!));
```

### Progress Components

Update any components that use the old progress hook to use the new hooks:

```typescript
// Old way
import { useProgress } from '@/hooks/useProgress';

// New way
import { useProgress } from '@/features/progress/hooks/useProgressQueries';
```

## Documentation Updates

The following documentation files reference the old API implementation and should be updated:

1. `wiki/guides/feature-implementation.md`
2. `wiki/development/README.md`

Update these references to point to the new API client pattern.

## Benefits of New Implementation

1. **Consistent API Client Usage**: All features use the same base API client
2. **Better Type Safety**: Improved TypeScript interfaces for all API responses
3. **Enhanced Error Handling**: Standardized error handling across all API calls
4. **Optimized Data Fetching**: Efficient caching and data invalidation with React Query
5. **Domain-Driven Structure**: API services and hooks organized by feature domain
</file>

<file path="docs/DEBUG_NOTES.md">
# Debugging Authentication Issues

## Common Issues and Solutions

### 1. Token Not Available
If you see "No access token available" in the logs:
```typescript
// Check these storage keys
localStorage.getItem('pharmacyhub_access_token')
localStorage.getItem('pharmacyhub_refresh_token')
localStorage.getItem('pharmacyhub_token_expiry')
```

### 2. Token Not Being Sent
If API requests are failing with 401/403:
- Check Network tab in DevTools
- Look for Authorization header
- Verify token format starts with "Bearer "

### 3. Token Refresh Issues
Refresh flow:
1. Original request fails with 401
2. tokenManager.refreshToken() is called
3. New token is obtained and stored
4. Original request is retried

Debug points:
```typescript
// In apiClient.ts
logger.debug('Request failed, attempting refresh', { status, endpoint });

// In tokenManager.ts
logger.debug('Token refresh initiated', { 
  hasRefreshToken: Boolean(this.getStoredRefreshToken())
});

// In authService.ts
logger.debug('Auth state update', { 
  isAuthenticated: this.isAuthenticated(),
  hasToken: Boolean(token)
});
```

### 4. Token Storage Locations
Tokens are stored in multiple places for different purposes:

1. localStorage
   - Main persistence layer
   - Survives page reloads
   ```typescript
   // Check all auth storage
   Object.keys(localStorage).filter(key => key.startsWith('pharmacyhub_'))
   ```

2. tokenManager
   - In-memory cache
   - Used for API requests
   ```typescript
   tokenManager.hasToken() // Check if valid token exists
   tokenManager.getToken() // Get current token with Bearer prefix
   ```

3. authService
   - Manages auth state
   - Handles token refresh
   ```typescript
   authService.isAuthenticated() // Check auth status
   ```

### 5. Development Tools

#### Token Debugger
```typescript
import { debugJwtToken } from '@/shared/auth/utils';

const token = tokenManager.getToken();
const debug = debugJwtToken(token);
console.log('Token debug:', debug);
```

#### Storage Inspector
```typescript
function inspectAuthStorage() {
  const storage = {
    access: localStorage.getItem('pharmacyhub_access_token'),
    refresh: localStorage.getItem('pharmacyhub_refresh_token'),
    expiry: localStorage.getItem('pharmacyhub_token_expiry'),
    profile: localStorage.getItem('pharmacyhub_user_profile')
  };
  
  console.table(storage);
}
```

### 6. Common Error States

```typescript
// Token expired
if (now >= tokenExpiry) {
  logger.warn('Token expired', {
    expiry: new Date(tokenExpiry).toISOString(),
    now: new Date().toISOString()
  });
}

// Token refresh failed
if (!refreshResponse.ok) {
  logger.error('Token refresh failed', {
    status: refreshResponse.status,
    body: await refreshResponse.text()
  });
}

// Auth sync issue
if (tokenManager.hasToken() && !authService.isAuthenticated()) {
  logger.warn('Auth state mismatch', {
    tokenExists: true,
    authState: false
  });
}
```

## Testing Authentication

### Unit Tests
```typescript
describe('TokenManager', () => {
  it('should handle token refresh', async () => {
    const manager = new EnhancedTokenManager();
    await manager.refreshToken();
    expect(manager.hasToken()).toBe(true);
  });
});
```

### Integration Tests
```typescript
describe('Auth Flow', () => {
  it('should maintain auth state across requests', async () => {
    await authService.login(credentials);
    const firstResponse = await examService.getPublishedExams();
    await delay(100);
    const secondResponse = await examService.getPublishedExams();
    expect(secondResponse.status).toBe(200);
  });
});
</file>

<file path="docs/documentation-guide.md">
# PharmacyHub Documentation Guide

This guide explains the documentation structure, standards, and best practices for maintaining the PharmacyHub documentation.

## Table of Contents
1. [Documentation Structure](#documentation-structure)
2. [Naming Conventions](#naming-conventions)
3. [Formatting Standards](#formatting-standards)
4. [Documentation Workflow](#documentation-workflow)
5. [Content Guidelines](#content-guidelines)
6. [Maintenance Responsibilities](#maintenance-responsibilities)

## Documentation Structure

The PharmacyHub documentation follows a numbered directory structure to provide a logical reading order and clear organization:

```
/documentation/
├── 01-overview/           # System overview and introduction
├── 02-architecture/       # Technical architecture
├── 03-authentication/     # Authentication and security
├── 04-features/           # Application features
├── 05-development/        # Development guidelines
├── 06-deployment/         # Deployment information
└── 07-assets/             # Asset management guidelines
```

### Section Purposes

1. **Overview (01-overview)**
   - Introduction to PharmacyHub
   - System requirements and purposes
   - Technical stack overview
   - Getting started guides

2. **Architecture (02-architecture)**
   - System architecture
   - Design patterns (FSD, DDD)
   - Component structure
   - State management
   - Directory organization

3. **Authentication (03-authentication)**
   - Keycloak integration
   - Permission system
   - Security considerations
   - Authentication flows
   - Developer guides for permissions

4. **Features (04-features)**
   - Licensing feature
   - Exam preparation
   - Pharmacy operations
   - User management
   - Feature-specific implementation details

5. **Development (05-development)**
   - Development standards
   - Coding patterns
   - Testing guidelines
   - API integration
   - Best practices

6. **Deployment (06-deployment)**
   - Deployment architecture
   - CI/CD pipeline
   - Environment configuration
   - Monitoring and logging
   - Scaling strategies

7. **Assets (07-assets)**
   - Image requirements
   - Asset organization
   - Optimization guidelines
   - Brand guidelines
   - Accessibility requirements

## Naming Conventions

### Files

1. **README Files**
   - Each directory should contain a `README.md` file providing an overview of that section
   - README files should follow a consistent structure with a clear table of contents

2. **Document Names**
   - Use kebab-case for all markdown files: `file-name-example.md`
   - Be descriptive but concise (3-5 words maximum)
   - Avoid abbreviations unless they are project standards

3. **Image Files**
   - Follow pattern: `[section]-[description]-[size].[extension]`
   - Example: `auth-login-flow-diagram-800x600.webp`

### Directories

1. **Section Directories**
   - Always maintain the numbered prefix: `01-overview`, `02-architecture`, etc.
   - Never create new top-level directories without team review

2. **Subdirectories**
   - Use kebab-case: `code-examples`, `api-documentation`
   - Group related content logically

## Formatting Standards

### Markdown Guidelines

1. **Headers**
   - Use ATX-style headers with a space after the hash: `## Heading`
   - Follow proper hierarchy (don't skip levels)
   - Main document title is H1, sections are H2, subsections are H3, etc.

2. **Lists**
   - Use hyphens (`-`) for unordered lists
   - Use numbers (`1.`) for ordered lists
   - Maintain consistent indentation (2 spaces)

3. **Code Blocks**
   - Always specify the language for syntax highlighting
   - Use triple backticks (```) for code blocks
   - Use single backticks (`) for inline code

4. **Tables**
   - Use proper table formatting with alignment indicators
   - Include headers for all tables
   - Keep tables simple and readable

5. **Links**
   - Use relative paths for internal documentation links
   - Use descriptive link text (avoid "click here")
   - Check links periodically to ensure they work

### Images and Diagrams

1. **Diagrams**
   - Use SVG format when possible
   - Include alt text for accessibility
   - Keep file sizes reasonable (<200KB)
   - Maintain consistent styling (colors, shapes, fonts)

2. **Screenshots**
   - Use WebP format
   - Crop to focus on relevant content
   - Annotate when necessary
   - Include dark mode versions when applicable

## Documentation Workflow

### Creating New Documentation

1. **Planning**
   - Determine the appropriate section
   - Review existing documentation to avoid duplication
   - Create an outline before writing

2. **Writing**
   - Follow the formatting standards
   - Include relevant code examples
   - Provide diagrams for complex concepts
   - Keep content concise but comprehensive

3. **Review**
   - Submit for peer review
   - Ensure technical accuracy
   - Check for clarity and readability
   - Verify all links work

4. **Publishing**
   - Place in appropriate numbered directory
   - Update relevant README files with links
   - Announce significant documentation updates

### Updating Existing Documentation

1. **Identify Updates Needed**
   - Verify content is outdated or incomplete
   - Check if related documents need updating

2. **Make Changes**
   - Update factual information
   - Improve examples
   - Refresh screenshots
   - Enhance clarity

3. **Review and Publish**
   - Have changes reviewed
   - Add update date at the bottom of the document
   - Update any cross-references

## Content Guidelines

### Writing Style

1. **Tone**
   - Professional but approachable
   - Direct and clear
   - Active voice preferred
   - Consistent voice throughout

2. **Audience Awareness**
   - Write for the intended audience (developers, designers, etc.)
   - Explain technical terms when first introduced
   - Provide context for complex concepts

3. **Structure**
   - Start with a brief overview/purpose statement
   - Use logical progression of concepts
   - Include a table of contents for lengthy documents
   - Summarize key points at the end of complex sections

### Content Types

1. **Conceptual Documentation**
   - Explain the "why" behind design decisions
   - Provide high-level understanding
   - Include architectural diagrams
   - Connect to other relevant concepts

2. **Procedural Documentation**
   - Step-by-step instructions
   - Clear prerequisites
   - Expected outcomes
   - Troubleshooting tips

3. **Reference Documentation**
   - Comprehensive details
   - Organized for quick lookup
   - Complete parameter/option lists
   - Version information when relevant

4. **Tutorial Documentation**
   - Learning-focused
   - Progress from simple to complex
   - Complete working examples
   - Explanation of each step

## Maintenance Responsibilities

### Regular Maintenance

1. **Quarterly Reviews**
   - Review all documentation for accuracy
   - Update outdated information
   - Improve clarity and examples
   - Check for broken links

2. **Version Updates**
   - Update documentation when dependencies change
   - Note significant API/behavior changes
   - Maintain backward compatibility notes

3. **Content Expansion**
   - Identify documentation gaps
   - Add new sections as features are developed
   - Expand existing sections based on feedback

### Documentation Ownership

1. **Section Owners**
   - Each numbered section has a primary owner responsible for accuracy
   - Section owners review changes to their section
   - Section owners identify improvement opportunities

2. **Cross-Functional Review**
   - Technical reviews by subject matter experts
   - Usability reviews for clarity and structure
   - New developer reviews for comprehensibility

## Best Practices

1. **Include Real Examples**
   - Use actual code from the codebase
   - Provide complete, working examples
   - Show both basic and advanced usage

2. **Document Limitations**
   - Be transparent about known issues
   - Document workarounds
   - Include performance considerations

3. **Use Visual Aids**
   - Diagrams for architecture and flows
   - Screenshots for UI components
   - Charts for complex relationships

4. **Keep Documentation Close to Code**
   - Reference relevant source files
   - Update documentation when code changes
   - Consider documentation changes part of feature development

5. **Gather Feedback**
   - Include a feedback mechanism
   - Act on user confusion points
   - Continuously improve based on how documentation is used

---

*Last updated: February 21, 2025*
</file>

<file path="docs/EXAM_API_INTEGRATION_GUIDE.md">
# Exam API Integration Guide

This guide outlines how to integrate with the updated Exam API endpoints. The backend has been refactored to resolve recursion issues in API responses, making it easier to integrate with the frontend.

## API Endpoints

### Exam Endpoints

| Endpoint | Method | Purpose | Auth Required |
|----------|--------|---------|--------------|
| `/api/v1/exams` | GET | Get all exams | Yes (ADMIN, INSTRUCTOR) |
| `/api/v1/exams/published` | GET | Get published exams | No |
| `/api/v1/exams/{id}` | GET | Get exam by ID | Yes |
| `/api/v1/exams` | POST | Create new exam | Yes (ADMIN, INSTRUCTOR) |
| `/api/v1/exams/{id}` | PUT | Update existing exam | Yes (ADMIN, INSTRUCTOR) |
| `/api/v1/exams/{id}` | DELETE | Delete exam | Yes (ADMIN) |
| `/api/v1/exams/status/{status}` | GET | Get exams by status | Yes (ADMIN, INSTRUCTOR) |
| `/api/v1/exams/{id}/publish` | POST | Publish exam | Yes (ADMIN, INSTRUCTOR) |
| `/api/v1/exams/{id}/archive` | POST | Archive exam | Yes (ADMIN, INSTRUCTOR) |

### Exam Paper Endpoints

| Endpoint | Method | Purpose | Auth Required |
|----------|--------|---------|--------------|
| `/api/exams/papers` | GET | Get all exam papers | Yes |
| `/api/exams/papers/model` | GET | Get model papers | Yes |
| `/api/exams/papers/past` | GET | Get past papers | Yes |
| `/api/exams/papers/{id}` | GET | Get paper by ID | Yes |
| `/api/exams/papers/stats` | GET | Get exam statistics | Yes |
| `/api/exams/papers` | POST | Create new paper | Yes |
| `/api/exams/papers/{id}` | PUT | Update existing paper | Yes |
| `/api/exams/papers/{id}` | DELETE | Delete paper | Yes |

## Response Formats

### Exam DTO (With Full Question Details)

```json
{
  "id": 1,
  "title": "Introduction to Pharmacy",
  "description": "Basic concepts in pharmacy practice",
  "duration": 60,
  "totalMarks": 100,
  "passingMarks": 60,
  "status": "PUBLISHED",
  "questions": [
    {
      "id": 1,
      "questionNumber": 1,
      "questionText": "What is the primary role of a pharmacist?",
      "options": [
        {
          "id": 1,
          "optionKey": "A",
          "optionText": "Dispensing medication",
          "isCorrect": true
        },
        {
          "id": 2,
          "optionKey": "B",
          "optionText": "Performing surgery",
          "isCorrect": false
        },
        {
          "id": 3,
          "optionKey": "C",
          "optionText": "Diagnosing diseases",
          "isCorrect": false
        },
        {
          "id": 4,
          "optionKey": "D",
          "optionText": "Developing marketing strategies",
          "isCorrect": false
        }
      ],
      "correctAnswer": "A",
      "explanation": "The primary role of a pharmacist is dispensing medication and ensuring medication safety.",
      "marks": 5
    }
    // More questions...
  ]
}
```

### Exam Paper DTO

```json
{
  "id": 1,
  "title": "Pharmacy Fundamentals",
  "description": "Test your knowledge of pharmacy basics",
  "difficulty": "medium",
  "questionCount": 30,
  "durationMinutes": 45,
  "tags": ["pharmacology", "basics", "introduction"],
  "premium": false,
  "attemptCount": 156,
  "successRatePercent": 75.5,
  "lastUpdatedDate": "2024-02-15",
  "type": "MODEL",
  "examId": 1
}
```

## Frontend Integration Steps

### 1. Update API Service Integrations

The existing `examService.ts` should be updated to align with the new API response structures:

```typescript
// Ensure the adapter correctly maps backend fields to frontend model
export function adaptBackendExam(backendExam: BackendExam): Exam {
  return {
    id: backendExam.id,
    title: backendExam.title,
    description: backendExam.description,
    duration: backendExam.duration,
    maxScore: backendExam.totalMarks,
    passingScore: backendExam.passingMarks,
    status: mapBackendStatus(backendExam.status),
    createdAt: backendExam.createdAt,
    updatedAt: backendExam.updatedAt,
    questionCount: backendExam.questionCount // New field
  };
}
```

### 2. Authentication Handling

The API integrates with the authentication system. Ensure your API calls include the proper authorization headers:

```typescript
const token = tokenManager.getToken();
const response = await apiClient.get<BackendExam[]>(`${BASE_PATH}/published`, {
  requiresAuth: token !== null,
  headers: token ? { 'Authorization': `Bearer ${token}` } : undefined
});
```

### 3. Error Handling

Implement proper error handling for API responses:

```typescript
try {
  const exams = await examService.getPublishedExams();
  setExams(exams);
  setLoading(false);
} catch (error) {
  setError('Failed to load exams. Please try again later.');
  setLoading(false);
  console.error('Error fetching exams:', error);
}
```

### 4. Data Loading Strategies

Consider implementing these patterns for loading exam data:

- **Pagination**: For listing large numbers of exams
- **Caching**: For frequently accessed data
- **Optimistic Updates**: For a better user experience during edits
- **Lazy Loading**: For questions and detailed content

## Common Integration Issues

### 1. Authentication Failures

If you encounter 403 errors:
- Check that tokens are correctly stored and refreshed
- Verify user roles match endpoint requirements
- Ensure token is included in request headers

### 2. Data Type Mismatches

Common type issues:
- Status enums (ensure casing matches: "PUBLISHED" vs "published")
- Date formats (backend uses ISO format)
- Numeric fields that might be strings in responses

### 3. Nested Data Access

When working with relationships:
- ExamPaper only contains examId, not the full exam object
- Question data must be loaded in a separate request

## Testing Your Integration

1. **Auth Testing**: Test both authenticated and anonymous access
2. **CRUD Operations**: Verify create, read, update, delete functionality
3. **Status Transitions**: Test exam status changes (draft → published → archived)
4. **Error Handling**: Verify your UI gracefully handles API errors
5. **Loading States**: Test loading indicators during API requests

## Conclusion

This updated API provides a more consistent and reliable way to integrate the exams feature. The refactored backend eliminates recursion issues that previously caused serialization problems, making the API more robust and easier to work with.

If you encounter any issues with the integration, please refer to the full API documentation or contact the backend team for assistance.
</file>

<file path="docs/EXAM_API_INTEGRATION.md">
# Exam Feature API Integration Guide

This document provides detailed information about how the exam feature integrates with the backend APIs.

## Overview

The exam feature uses React Query for server state management and API integration. This provides:

- Automatic caching
- Optimistic updates
- Refetching strategies
- Loading and error states
- Data synchronization

## API Service

The `examApi.ts` file contains all the functions for interacting with the backend API:

```typescript
// Base API functions
getAllExams() - Fetch all exams
getPublishedExams() - Fetch only published exams
getExamsByStatus(status) - Fetch exams with specific status
getExamById(examId) - Fetch a single exam by ID
getExamQuestions(examId) - Fetch questions for an exam

// Exam attempt functions
startExam(examId, userId) - Start a new exam attempt
saveAnswer(attemptId, answer) - Save a single answer
submitExam(attemptId, answers) - Submit all exam answers

// Question flagging
flagQuestion(attemptId, questionId) - Flag a question for review
unflagQuestion(attemptId, questionId) - Unflag a question
getFlaggedQuestions(attemptId) - Get all flagged questions for an attempt

// Results and stats
getExamResult(attemptId) - Get exam result
getUserAttempts(userId) - Get user's exam attempts
getExamAttemptsByUser(examId, userId) - Get attempts for an exam by a user
getExamStats() - Get exam statistics
```

## React Query Hooks

The API is wrapped with React Query hooks in `useExamQueries.ts`:

```typescript
// Basic data fetching hooks
useExams() - Get all exams
usePublishedExams() - Get published exams
useExamsByStatus(status) - Get exams by status
useExam(examId) - Get a single exam
useExamQuestions(examId) - Get exam questions

// User attempts hooks
useUserAttempts(userId) - Get user's exam attempts
useExamAttemptsByUser(examId, userId) - Get attempts by exam and user
useFlaggedQuestions(attemptId) - Get flagged questions

// Results hook
useExamResult(attemptId) - Get exam result

// Statistics hook
useExamStats() - Get exam statistics

// Comprehensive hook for exam session
useExamSession(examId) - Manages the entire exam session
```

## The `useExamSession` Hook

The `useExamSession` hook is the main integration point, combining multiple queries and mutations:

```typescript
// Data fetching
exam - Exam details from API
questions - Exam questions from API
isLoading - Loading state
error - Error state

// State from Zustand store
currentQuestionIndex - Current question index
answers - User answers
flaggedQuestions - Questions flagged by user
timeRemaining - Time left for exam
isCompleted - Exam completion status

// Navigation actions
navigateToQuestion(index) - Navigate to specific question
nextQuestion() - Go to next question
previousQuestion() - Go to previous question

// Question actions
answerQuestion(questionId, optionIndex) - Save answer
toggleFlagQuestion(questionId) - Flag/unflag question

// Exam session actions
startExam({userId}) - Start exam attempt
submitExam() - Submit exam
handleTimeExpired() - Handle timer expiration

// UI actions
toggleSummary() - Show/hide summary
showSummary - Summary visibility state

// Helper getters
hasAnswer(questionId) - Check if question is answered
isFlagged(questionId) - Check if question is flagged
getAnsweredQuestionsCount() - Count of answered questions
getFlaggedQuestionsCount() - Count of flagged questions
getCompletionPercentage() - Completion percentage
```

## API Integration Flow

### Starting an Exam

1. User clicks "Start Exam"
2. `handleStartExam()` in `ExamContainer` is called
3. Calls `startExam()` from `useExamSession`
4. Makes API request via `examApi.startExam()`
5. On success:
   - Updates Zustand store via `examStore.startExam()`
   - Sets attempt ID in state
   - Invalidates relevant queries

### Answering Questions

1. User selects an answer
2. Calls `answerQuestion(questionId, optionIndex)` from `useExamSession`
3. Updates local state in Zustand store
4. Optionally calls API to save answer via `examApi.saveAnswer()`

### Flagging Questions

1. User flags a question
2. Calls `toggleFlagQuestion(questionId)` from `useExamSession`
3. Makes API request via `examApi.flagQuestion()` or `examApi.unflagQuestion()`
4. Updates local state in Zustand store
5. Invalidates flagged questions query

### Submitting Exam

1. User clicks "Submit Exam"
2. Calls `handleSubmitExam()` in `ExamContainer`
3. Calls `submitExam()` from `useExamSession`
4. Makes API request via `examApi.submitExam()`
5. On success:
   - Marks exam as completed in Zustand store
   - Shows results view
   - Invalidates result query

### Timer Expiration

1. Timer reaches zero
2. Calls `handleTimeExpired()` from `useExamSession`
3. Automatically submits exam via `submitExam()`

## Error Handling

Error handling is managed at multiple levels:

1. **API Layer**: Errors from API calls are caught and formatted
2. **React Query Layer**: Provides error states for failed queries/mutations
3. **UI Layer**: Displays appropriate error messages using alerts and toast notifications

## Optimizations

1. **Cache Invalidation**: Only invalidate affected queries to reduce unnecessary calls
2. **State Management Split**: Use Zustand for client state, React Query for server state
3. **Optimistic Updates**: Apply changes locally before API confirms for better UX
4. **Prefetching**: Prefetch related data when appropriate

## Integration Points with Components

- **ExamContainer**: Main component that uses `useExamSession` hook
- **QuestionDisplay**: Shows question and handles answers/flagging
- **QuestionNavigation**: Manages navigation between questions
- **ExamSummary**: Shows overview of exam progress
- **ExamResults**: Displays exam results from API

## Security Considerations

1. User ID is validated on server-side
2. Attempt ownership is verified before allowing actions
3. Exam access is controlled via permissions

## Performance Considerations

1. Minimize API calls during exam session
2. Cache questions to reduce loading times
3. Batch updates when possible
4. Use optimistic updates for better UX
</file>

<file path="docs/EXAM_FEATURE_DIAGNOSIS.md">
# PharmacyHub Exams Feature - Problem Diagnosis

## Current Implementation Analysis

### Architecture Overview
- **Frontend**: Next.js application with React components organized by features
- **Backend**: Spring Boot application with REST API endpoints
- **Data Flow**: Client -> API Services -> Redux/Zustand Stores -> UI Components

### Exam Feature Components
1. **Frontend**:
   - `McqExamList` component for displaying available exams
   - Exam service for API communication (`examService.ts`)
   - Data adapter for converting backend models to frontend types
   - Multiple stores for state management (examSlice.ts, examStore.ts)

2. **Backend**:
   - RESTful API controllers (`ExamController`, `ExamPaperController`, `ExamAttemptController`)
   - Service layer for business logic
   - Repository layer for data access
   - Entity models and DTOs for data representation
   - Sample data loader for initializing exam content

## Identified Issues

### 1. API Communication Failure
- The frontend is making a request to `/api/exams/published` endpoint
- When loading the Exams page, this API call fails, resulting in the error message: "Failed to load exams. Please try again later."
- The browser's network tab shows 404 status code responses for exam-related API calls

### 2. Data Model Mismatch
- Potential inconsistency between frontend expected data model and backend response structure
- The adapter (`adapter.ts`) defines mappings for `BackendExam` to `Exam`, but these may not match the actual API response

### 3. Backend Data Loading
- The `ExamDataLoader` is configured to load exams from JSON files, but only a single sample file exists
- Exams are loaded as DRAFT status by default, but frontend is requesting PUBLISHED exams

### 4. API Proxy Configuration
- Next.js needs proper API routing configuration to proxy requests to the backend
- There appears to be no middleware or API route configuration for handling `/api/exams` paths

### 5. Error Handling
- The frontend has error handling in the component, but the user experience is poor when API calls fail
- No fallback content is provided when exams can't be loaded

## Root Causes

1. **Missing API Proxy Configuration**: The Next.js application needs to be properly configured to route API requests to the Spring Boot backend.

2. **Unpublished Exams**: The sample exam data is loaded in DRAFT status, but the frontend is requesting PUBLISHED exams.

3. **Development Environment Setup**: Potential misconfiguration in the development environment preventing proper communication between frontend and backend.

4. **API Path Inconsistency**: The frontend might be using incorrect API paths that don't match the backend's defined endpoints.

## Potential Bottlenecks

1. **Data Adapter Complexity**: The multiple layers of type conversion between backend and frontend models could introduce bugs.

2. **Multiple State Stores**: The feature uses multiple state stores (Redux slice and Zustand store), which could lead to state management issues.

## Impact Assessment

The exams feature is completely non-functional, preventing users from:
- Viewing available exams
- Starting new exam attempts
- Completing practice exams

This significantly impacts the core functionality of the PharmacyHub application for exam preparation.
</file>

<file path="docs/EXAM_FEATURE_ENHANCEMENT_PLAN.md">
# Exam Feature Enhancement Plan

## Current State Analysis

The current exam feature implements basic functionality for:
- Viewing available exams
- Starting an exam session
- Answering questions
- Submitting exams

The backend architecture is comprehensive with proper entities for:
- Exams
- Exam Papers
- Exam Attempts
- Exam Results
- Flagged Questions

## Enhancement Objectives

1. **Break Down Monolithic Components**:
   - Split `ExamContainer` into smaller, reusable components
   - Create separate components for question display, navigation, and submission

2. **Implement Missing UI Features**:
   - Question flagging functionality
   - Exam timer with auto-submit
   - Answer review mode
   - Pagination for question navigation
   - Detailed results visualization

3. **Improve State Management**:
   - Enhance React Query integration
   - Extend Zustand store for better local state handling

4. **Add User Experience Improvements**:
   - Progress tracking
   - Question status indicators (answered, flagged, unanswered)
   - Confirmation dialogs for important actions
   - Accessibility improvements

## Implementation Plan

### 1. Create Small, Focused Components

1. **QuestionDisplay**: Renders a single exam question with options
2. **QuestionNavigation**: Provides navigation between questions
3. **ExamProgress**: Shows progress through the exam
4. **ExamTimer**: Displays and manages remaining time
5. **FlagQuestion**: Allows users to flag questions for review
6. **ExamSummary**: Shows overview of all questions and their status
7. **ExamResults**: Displays detailed exam results with analytics

### 2. Enhance API Integration

1. Extend `examApi.ts` to support all backend endpoints
2. Update React Query hooks to provide comprehensive data access
3. Implement optimistic updates for better user experience

### 3. Improve State Management

1. Extend the Zustand store to track:
   - Flagged questions
   - Time spent per question
   - Navigation history
   - Exam completion status

### 4. Implement Advanced Features

1. **Question Flagging**:
   - Add UI for flagging questions for later review
   - Create a review mode to revisit flagged questions

2. **Timer Functionality**:
   - Add countdown timer with visual indicators
   - Implement auto-save and auto-submit functionality

3. **Review Mode**:
   - Create a review screen showing all questions and answers
   - Allow users to navigate directly to specific questions

4. **Results Visualization**:
   - Add charts and visualizations for exam performance
   - Show detailed feedback on answers

## Technical Approach

1. Use atomic design principles to create a hierarchy of components
2. Ensure all components are properly typed with TypeScript
3. Follow established project patterns for API integration
4. Implement proper error handling and loading states
5. Ensure accessibility compliance

## Testing Strategy

1. Create unit tests for individual components
2. Implement integration tests for component interactions
3. Test API integration with mock data
4. Perform end-to-end testing of the complete exam flow

## Timeline

1. **Phase 1**: Create base components and enhance API integration
2. **Phase 2**: Implement timer and question flagging functionality
3. **Phase 3**: Add review mode and results visualization
4. **Phase 4**: Final integration, testing, and refinement
</file>

<file path="docs/EXAM_FEATURE_FOLDER_STRUCTURE.md">
# Exam Feature Implementation - Folder Structure

## Required Folder Structure

To implement the exam feature, ensure the following folder structure is in place:

```
src/
├── app/
│   ├── exams/
│   │   └── page.tsx                   # List of available exams 
│   └── (exams)/                       # Route group for exam-related routes
│       └── exam/
│           └── [id]/
│               └── page.tsx           # Exam page with dynamic id parameter
├── components/
│   ├── layout/
│   │   └── container.tsx              # Layout component for page content
│   └── ui/                            # shadcn/ui components
│       ├── alert.tsx
│       ├── badge.tsx
│       ├── button.tsx
│       ├── card.tsx
│       ├── dialog.tsx
│       ├── label.tsx
│       ├── progress.tsx
│       ├── radio-group.tsx
│       ├── separator.tsx
│       ├── skeleton.tsx
│       └── tabs.tsx
├── features/
│   └── exams/
│       ├── api/
│       │   └── examApi.ts             # API service functions
│       ├── hooks/
│       │   └── useExamQueries.ts      # React Query hooks
│       ├── model/
│       │   └── mcqTypes.ts            # TypeScript interfaces
│       ├── store/
│       │   └── examStore.ts           # Zustand state store
│       └── ui/
│           ├── ExamContainer.tsx      # Main container component 
│           ├── ExamList.tsx           # List of available exams
│           └── components/            # Smaller UI components
│               ├── ExamProgress.tsx
│               ├── ExamResults.tsx
│               ├── ExamSummary.tsx
│               ├── ExamTimer.tsx
│               ├── QuestionDisplay.tsx
│               └── QuestionNavigation.tsx
└── hooks/
    └── useClickOutside.ts             # Custom React hook for click outside detection
```

## Component Placement

- `ExamContainer.tsx` should be directly in `src/features/exams/ui/`
- All smaller components should be in `src/features/exams/ui/components/`
- No components should be in an `enhanced` folder

## Route Structure

Make sure the Next.js pages are correctly structured:

1. All exams listing page: `src/app/exams/page.tsx`
2. Individual exam page: `src/app/(exams)/exam/[id]/page.tsx`

## Imports

Update all imports to point to the correct locations. For example:

```tsx
// In src/app/(exams)/exam/[id]/page.tsx
import { ExamContainer } from '@/features/exams/ui/ExamContainer';

// In src/features/exams/ui/ExamContainer.tsx
import { QuestionDisplay } from './components/QuestionDisplay';
import { QuestionNavigation } from './components/QuestionNavigation';
import { ExamProgress } from './components/ExamProgress';
import { ExamTimer } from './components/ExamTimer';
import { ExamSummary } from './components/ExamSummary';
import { ExamResults } from './components/ExamResults';
```

## Integration Points

- All components should use shadcn/ui components for UI elements
- Use `examStore.ts` for client-side state management
- Use `useExamQueries.ts` for API integration via React Query
- Use `mcqTypes.ts` for TypeScript type definitions
</file>

<file path="docs/EXAM_FEATURE_SOLUTION.md">
# Exam Feature Authentication Integration Solution

## Problem Overview
The exam feature was experiencing authentication issues due to token synchronization problems between different auth management systems:
- AuthContext for React context-based auth state
- tokenManager for API request authentication
- authService for backend communication
- localStorage for persistence

## Key Issues Found
1. Token synchronization issue between systems
2. Published exams endpoint requiring auth despite being marked as public
3. Inconsistent auth header handling

## Solution Implemented

### 1. Auth State Management
- Updated AuthContext to properly sync with tokenManager
- Added userType to UserProfile type to support role-based access
- Unified token management between authService and tokenManager

### 2. API Integration Improvements
- Added intelligent auth handling in examService:
  ```typescript
  async getPublishedExams(): Promise<Exam[]> {
    // Try to get token if available
    const token = tokenManager.getToken();
    const useAuth = !!token;

    const response = await apiClient.get<BackendExam[]>(`${BASE_PATH}/published`, {
      requiresAuth: useAuth,
      headers: useAuth ? {
        'Authorization': `Bearer ${token}`
      } : undefined
    });
  }
  ```

### 3. Token Flow
```mermaid
graph TD
    A[AuthContext] -->|sync| B[tokenManager]
    C[authService] -->|persist| D[localStorage]
    B -->|read| D
    E[apiClient] -->|use| B
    F[examService] -->|check token| B
    F -->|make request| E
```

### 4. Authentication Strategy
1. Try unauthenticated request first for public endpoints
2. If 403, fallback to authenticated request when token is available
3. Proper error handling and user feedback

### 5. Key Components Modified

#### examService.ts
```typescript
// Smart auth handling
const token = tokenManager.getToken();
const useAuth = !!token;

// Fallback mechanism
if (response.error && response.status === 403 && !useAuth) {
  return this.getAllExams();
}
```

#### AuthContext.tsx
```typescript
// Token synchronization
if (accessToken) {
  tokenManager.setToken(accessToken);
  if (expiry) {
    tokenManager.setTokenExpiry(parseInt(expiry));
  }
}
```

## Testing and Validation
1. Token Refresh Flow
   - Verify token refresh works correctly
   - Check token synchronization between systems

2. Authorization Scenarios
   - Test public endpoints both with and without auth
   - Verify fallback mechanisms work correctly
   - Check error handling and user feedback

3. Key Test Cases
   ```typescript
   // Should work without auth
   await examService.getPublishedExams();
   
   // Should require auth
   await examService.getAllExams();
   
   // Should handle auth failures gracefully
   try {
     await examService.startExam(1);
   } catch (error) {
     // Should show proper error message
   }
   ```

## Monitoring
1. Added debug logs for auth state changes
2. Improved error tracking for auth failures
3. Added token debugging utilities
4. Token status visibility in dev tools

## Future Recommendations
1. Consider caching strategies for better performance
2. Add retry mechanisms for failed auth refreshes
3. Implement progressive loading for exam content
4. Add real-time token validation

## References
- Next-Auth Documentation
- React Query Best Practices
- JWT Token Management Patterns
- Token Refresh Best Practices
</file>

<file path="docs/EXAM_FEATURE_STRUCTURE.md">
# Exam Feature Structure and Organization

## Component Structure

The exam feature is organized as follows:

```
src/
└── features/
    └── exams/
        ├── api/
        │   └── examApi.ts          # API service functions
        ├── hooks/
        │   └── useExamQueries.ts   # React Query hooks
        ├── model/
        │   └── mcqTypes.ts         # TypeScript interfaces
        ├── store/
        │   └── examStore.ts        # Zustand state store
        └── ui/
            ├── ExamContainer.tsx   # Main container component
            ├── ExamList.tsx        # List of available exams
            └── components/         # Smaller UI components
                ├── QuestionDisplay.tsx
                ├── QuestionNavigation.tsx
                ├── ExamProgress.tsx
                ├── ExamTimer.tsx
                ├── ExamSummary.tsx
                └── ExamResults.tsx
```

## Pages Structure

```
src/
└── app/
    ├── exams/
    │   └── page.tsx               # Available exams listing page
    └── (exams)/
        └── exam/
            └── [id]/
                └── page.tsx       # Individual exam page
```

## State Management

The exam feature uses a combination of state management techniques:

1. **React Query**: For server state and API integration
2. **Zustand**: For client-side state that persists across page refreshes
3. **React state**: For component-level state

## Data Flow

1. User visits `/exams` to see available exams
2. Clicks on an exam to go to `/exam/[id]`
3. ExamContainer manages the entire exam-taking flow:
   - Start exam
   - Navigate between questions
   - Answer questions
   - Flag questions for review
   - View summary
   - Submit exam
   - See results

## API Integration

API integration is handled by `examApi.ts` and exposed through React Query hooks in `useExamQueries.ts`.

## Component Responsibilities

- **ExamContainer**: Overall exam flow and state management
- **QuestionDisplay**: Renders a question with answer options
- **QuestionNavigation**: Handles navigation between questions
- **ExamProgress**: Shows progress through the exam
- **ExamTimer**: Countdown timer
- **ExamSummary**: Review screen before submission
- **ExamResults**: Shows exam results after submission

## File Naming Conventions

- React components use PascalCase (e.g., `ExamContainer.tsx`)
- Hooks use camelCase with "use" prefix (e.g., `useExamQueries.ts`)
- API services use camelCase (e.g., `examApi.ts`)
- Type definitions use camelCase (e.g., `mcqTypes.ts`)
</file>

<file path="docs/exam-feature-fix.md">
# Exam Feature Fix Documentation

## Issue Overview

The exams feature had TypeScript errors related to the `ExamStatus` export from `mcqTypes.ts`. The adapter file was trying to use `ExamStatus` as an enum with properties like `ExamStatus.DRAFT`, but it was defined as a TypeScript type: `type ExamStatus = 'DRAFT' | 'PUBLISHED' | 'ARCHIVED'`. 

Additionally, there were missing type definitions for `ExamQuestion` and `ExamOption` that were referenced in the adapter file.

## Changes Made

1. Updated `mcqTypes.ts` to provide both a type and const object for ExamStatus:
   ```typescript
   // The type for type checking
   export type ExamStatusType = 'DRAFT' | 'PUBLISHED' | 'ARCHIVED';
   
   // The constant for consistent enum-like usage
   export const ExamStatus = {
     DRAFT: 'DRAFT',
     PUBLISHED: 'PUBLISHED',
     ARCHIVED: 'ARCHIVED'
   } as const;
   ```

2. Added missing type definitions for `ExamQuestion` and `ExamOption`:
   ```typescript
   export interface ExamQuestion {
     id: number;
     text: string;
     options: ExamOption[];
     explanation: string;
     points: number;
   }
   
   export interface ExamOption {
     id: string;
     text: string;
     isCorrect: boolean;
   }
   ```

3. Updated the `Exam` interface to use the new `ExamStatusType`.

4. Updated `adapter.ts` to:
   - Import the new `ExamStatusType`
   - Fix the return type of `mapBackendStatus`
   - Fix property names in the `adaptBackendExam` function to match the `Exam` interface

## Architecture Notes

The exam feature follows a clean architecture pattern with:

1. **Model layer** - Type definitions in `mcqTypes.ts` and `types.ts`
2. **API layer** - API clients and adapters to transform data between frontend and backend formats
3. **UI layer** - React components to render the exam interface
4. **Store layer** - State management for exam data

The adapter pattern is used to transform data between different formats, making it easy to handle changes in API responses without affecting the rest of the application.

## Future Improvements

1. Consider consolidating types between `mcqTypes.ts` and `types.ts` to avoid duplication
2. Add runtime type validation using a library like Zod
3. Add unit tests for the adapter functions to ensure they correctly transform data

## Additional Information

The exam feature is integrated with the backend through REST APIs defined in the `examApi.ts` file. The backend provides endpoints for:
- Retrieving exam lists and details
- Starting an exam attempt
- Submitting answers
- Retrieving results

The frontend handles exam presentation, timer management, and result display.
</file>

<file path="docs/exam-feature-implementation-details.md">
# Exam Feature Implementation Documentation

## Overview

The exam feature has been implemented with a focus on:
- Component-based architecture
- Proper state management
- Advanced UI/UX features
- Full integration between frontend and backend

## Component Structure

The implementation follows atomic design principles, breaking down the UI into smaller, reusable components:

### Core Components

1. **QuestionDisplay**: Renders a single exam question with options and flag functionality
2. **QuestionNavigation**: Provides navigation between questions with status indicators
3. **ExamProgress**: Shows progress through the exam
4. **ExamTimer**: Displays and manages remaining time
5. **ExamSummary**: Shows overview of all questions and their status before submission
6. **ExamResults**: Displays detailed exam results with analytics

### Composites

1. **EnhancedExamContainer**: Orchestrates all the core components and manages the exam flow

### Pages

1. **ExamPage**: Next.js page component for taking an exam
2. **ExamsPage**: Next.js page component for listing available exams

## State Management

### React Query Integration

The implementation uses React Query for server state management with custom hooks:

- `useExams`: Fetches all exams
- `usePublishedExams`: Fetches only published exams
- `useExam`: Fetches a single exam by ID
- `useExamQuestions`: Fetches questions for an exam
- `useExamSession`: Comprehensive hook for exam-taking functionality

### Zustand Store

A Zustand store (`examStore.ts`) is used for client-side state management:

- Tracks current question, answers, and flagged questions
- Manages timer functionality
- Handles exam navigation and submission
- Persists state between page refreshes

## API Integration

The implementation includes comprehensive API integration:

- Full CRUD operations for exams
- Exam attempt tracking
- Question flagging
- Answer submission
- Result retrieval

## Feature Highlights

1. **Question Flagging**: Users can flag questions for later review
2. **Exam Timer**: Countdown timer with auto-submit functionality
3. **Progress Tracking**: Visual indicators of exam progress
4. **Review Mode**: Pre-submission review of answers
5. **Detailed Results**: Comprehensive results with correct answers and explanations
6. **Responsive Design**: Works on all device sizes

## Implementation Decisions

1. **Small Components**: Breaking down the UI into small, focused components improves:
   - Maintainability
   - Testability
   - Reusability
   - Collaboration

2. **State Management Split**:
   - React Query for server state
   - Zustand for client-only state
   - Clear separation of concerns

3. **Progressive Enhancement**:
   - Basic functionality works without JavaScript
   - Enhanced experience with JavaScript enabled

4. **Accessibility**: All components are built with accessibility in mind:
   - Proper ARIA attributes
   - Keyboard navigation
   - Screen reader support

## Future Enhancements

1. **Offline Support**: Enable taking exams without an internet connection
2. **Enhanced Analytics**: More detailed performance metrics and insights
3. **Question Types**: Support for different question types (multiple choice, fill-in-the-blank, etc.)
4. **Media Support**: Add images, videos, and other media to questions
5. **Performance Optimization**: Lazy loading and code splitting for faster loading

## Technical Challenges Solved

1. **Race Conditions**: Proper handling of async operations with React Query
2. **Timer Accuracy**: Implementing a reliable countdown timer
3. **State Persistence**: Maintaining exam state across page refreshes
4. **Server Synchronization**: Keeping client and server state in sync
5. **Error Handling**: Comprehensive error handling and recovery

## Conclusion

The exam feature implementation provides a robust, user-friendly experience for taking exams, with a focus on small, well-integrated components. The architecture supports future enhancements and ensures maintainability over time.
</file>

<file path="docs/exam-feature-implementation.md">
# Exam Feature Implementation

This document outlines the implementation of the PharmacyHub exam feature, focusing on React Query integration with the application's API client.

## Architecture Overview

The exam feature follows a layered architecture pattern:

1. **API Layer**: Provides functions to interact with the backend API endpoints
2. **Hooks Layer**: Encapsulates React Query for data fetching and mutations
3. **UI Layer**: Components that consume hooks and display data to users

## API Integration

### Exam API Service

The exam API service (`examApi.ts`) uses the main application's API client for making HTTP requests to exam-related endpoints. This approach ensures consistent error handling, authentication, and caching across the application.

```typescript
// Example API method
getExamById: async (examId: number): Promise<Exam> => {
  const response = await apiClient.get<Exam>(`${BASE_PATH}/${examId}`);
  if (response.error) throw response.error;
  if (!response.data) throw new Error('Exam not found');
  return response.data;
}
```

### React Query Integration

The custom hooks in `useExamQueries.ts` integrate React Query with the API service, providing:

- Structured query keys for proper caching
- Automatic refetching and cache invalidation
- Loading, error, and data states
- Mutations for data modification operations

```typescript
// Example React Query hook
export function useExam(examId: number | undefined) {
  return useQuery({
    queryKey: EXAM_KEYS.detail(examId as number),
    queryFn: () => examApi.getExamById(examId as number),
    enabled: !!examId,
  });
}
```

## Key Features

### Data Fetching

- Automatic data loading with loading states
- Proper error handling
- Cache management (stale time, refetch policies)

### Data Mutations

- Optimistic updates
- Cache invalidation
- Error handling

### State Management

- React Query for server state
- Zustand for client-only state (exam progress, user answers)
- Clear separation of concerns

## Usage Examples

### Fetching Exam Data

```tsx
// In a component:
const { data: exam, isLoading, error } = useExam(examId);

if (isLoading) return <Loading />;
if (error) return <ErrorDisplay error={error} />;
if (!exam) return <NotFound />;

return <ExamDisplay exam={exam} />;
```

### Starting an Exam

```tsx
const { startExam, isStarting } = useExamSession(examId);

// In an event handler:
const handleStartExam = () => {
  startExam(
    { userId },
    {
      onSuccess: (data) => {
        // Handle success
      },
      onError: (error) => {
        // Handle error
      }
    }
  );
};
```

## Component Hierarchy

- `ExamList` - Displays available exams
- `ExamContainer` - Main exam UI that handles exam session state
  - Exam Start View
  - Question Navigation
  - Answer Selection
  - Exam Completion

## Future Improvements

1. **Offline Support**: Implement offline capabilities using React Query's persistQueryClient plugin
2. **Performance Optimization**: Prefetch exams for smoother navigation
3. **Analytics Integration**: Track user progress and performance metrics
4. **Accessibility Enhancements**: Ensure all exam components are fully accessible
5. **Test Coverage**: Add comprehensive tests for API, hooks, and components

## Migration Guide

When migrating existing components to use the new React Query implementation:

1. Replace direct API calls with React Query hooks
2. Update UI components to handle loading/error states
3. Use mutations for data modifications
4. Leverage the query client for cache operations
</file>

<file path="docs/exams-feature-cleanup.md">
# PharmacyHub Exams Feature Cleanup

This document outlines the changes made to organize the exam feature properly under the features directory structure and cleanup redundant files.

## Updated Directory Structure

All exam-related code is now organized under the `src/features/exams` directory with the following structure:

```
src/features/exams/
├── api/
│   ├── examApi.ts
│   ├── examPaperService.ts
│   └── examService.ts
├── model/
│   ├── mcqTypes.ts
│   └── types.ts
├── hooks/
│   ├── useExamQueries.ts
│   └── useExams.ts
├── store/
│   ├── examPaperStore.ts
│   ├── examSlice.ts
│   ├── examStore.ts
│   └── mcqExamStore.ts
└── ui/
    ├── components/
    │   ├── ExamTimer.tsx
    │   ├── PerformanceCharts.tsx
    │   ├── QuestionCard.tsx
    │   ├── QuestionNavigation.tsx
    │   └── ResultsView.tsx
    ├── mcq/
    │   ├── McqExamLayout.tsx
    │   ├── McqExamList.tsx
    │   └── McqExamResults.tsx
    ├── quiz/
    │   ├── ExamLayout.tsx
    │   ├── ExamSettings.tsx
    │   └── ExamTimer.tsx
    ├── results/
    │   ├── PerformanceCharts.tsx
    │   └── ResultsView.tsx
    ├── ExamContainer.tsx
    ├── ExamLanding.tsx
    ├── ExamList.tsx
    └── ExamPaperCard.tsx
```

## Files Updated to Use Feature-Specific Stores

We've updated the following files to use the feature-specific stores instead of the legacy store:

1. `src/components/exam/ExamLayout.tsx`
2. `src/components/exam/QuestionNavigation.tsx`
3. `src/components/exam/ExamTimer.tsx`
4. `src/features/exams/hooks/useExamQueries.ts`
5. `src/features/exams/ui/ExamContainer.tsx`

## Files Safe to Remove

The following files are now redundant and can be safely removed:

1. `src/store/examStore.ts` - Replaced by `src/features/exams/store/mcqExamStore.ts`

## Component Migration

The exam UI components have been properly organized in the feature folder structure, with components being moved to appropriate subfolders:

- Basic exam components are under `ui/components/`
- MCQ-specific components are under `ui/mcq/`
- Quiz-specific components are under `ui/quiz/`
- Results visualization components are under `ui/results/`

## Store Implementation Notes

We now have three different implementations of exam stores in the feature folder:

1. `examStore.ts` - A simple implementation for basic exam state
2. `mcqExamStore.ts` - A comprehensive implementation for MCQ exam interactions
3. `examPaperStore.ts` - A specialized store for exam papers

We've standardized on using `mcqExamStore.ts` as the primary store for exam interactions.

## Future Recommendations

1. Consider consolidating the exam stores into a single, unified store with proper typing
2. Ensure all components use the feature-specific API client and hooks
3. Remove any other legacy exam-related code outside the feature directory
4. Update documentation to reflect the new organization

By following this cleanup, we now have a consistent, well-organized feature structure that follows the project's architectural patterns.
</file>

<file path="docs/plan/documentation-roadmap.md">
# PharmacyHub Frontend Documentation Roadmap

## Current Status
The documentation is organized in a numbered structure with clear sections. This roadmap outlines the planned updates and additions to ensure comprehensive coverage of all system aspects.

## Documentation Updates Plan

### 1. Authentication (03-authentication/)
- [ ] Keycloak Integration Guide
- [ ] RBAC Implementation Details
- [ ] JWT Token Management
- [ ] Security Best Practices
- [ ] Session Management
- [ ] OAuth2 Flows

### 2. Architecture (02-architecture/)
- [ ] Feature-Sliced Design Implementation
- [ ] Component Architecture
- [ ] State Management with Zustand
- [ ] API Integration Patterns
- [ ] Error Handling Strategy
- [ ] Performance Optimization Guidelines

### 3. Development (05-development/)
- [ ] Development Environment Setup
- [ ] Code Standards and Best Practices
- [ ] Testing Strategy (Unit, Integration, E2E)
- [ ] CI/CD Pipeline Details
- [ ] Code Review Guidelines
- [ ] Performance Monitoring

### 4. Features (04-features/)
- [ ] Feature Flag System
- [ ] Core Components
- [ ] Business Logic Implementation
- [ ] API Integration Examples
- [ ] State Management Examples
- [ ] Error Handling Examples

### 5. UI/UX (new section: 08-ui-ux/)
- [ ] Design System Documentation
- [ ] Component Library
- [ ] Theme Configuration
- [ ] Accessibility Guidelines
- [ ] Responsive Design Patterns

## Implementation Timeline

### Week 1
- Complete Authentication Documentation
- Set up Architecture Documentation

### Week 2
- Complete Development Guidelines
- Document Feature Implementation

### Week 3
- Create UI/UX Documentation
- Review and Update All Sections

### Week 4
- Gather Team Feedback
- Make Final Revisions
- Release Documentation Update

## Quality Assurance

Each documentation update will go through:
1. Technical review
2. Readability review
3. Example validation
4. Link verification
5. Team feedback incorporation

## Maintenance Plan

- Monthly reviews of each section
- Quarterly comprehensive updates
- Continuous feedback collection
- Version control alignment
</file>

<file path="docs/plan/exams-ui-enhancement.md">
# Exams UI Enhancement Plan

## Overview
Modernize and enhance the exam practice interface following FSD and DDD principles.

## Component Structure
```
features/
  exam/
    ui/
      ExamDashboard/
      ModelPaperCard/
      ExamFilters/
      PremiumAccessCard/
    model/
      types.ts
    api/
      examApi.ts
    lib/
      helpers.ts
    config/
      constants.ts
```

## Tasks
1. [x] Create enhanced UI components
   - [ ] Redesign ModelPaperCard component
   - [ ] Implement ExamFilters component
   - [ ] Create ExamDashboard layout
   - [ ] Enhance PremiumAccessCard design

2. [ ] Implement Data Layer
   - [ ] Define exam domain types
   - [ ] Create API integration hooks
   - [ ] Implement data fetching logic

3. [ ] Add Interactive Features
   - [ ] Implement search functionality
   - [ ] Add difficulty filter
   - [ ] Create paper preview modal

4. [ ] Testing & Documentation
   - [ ] Write unit tests
   - [ ] Add component documentation
   - [ ] Update README

## Design Guidelines
- Use shadcn/ui components for consistent styling
- Implement responsive design patterns
- Follow accessibility best practices
- Maintain clean component hierarchy
</file>

<file path="docs/PR_NOTES.md">
# Authentication Integration PR Notes

## Changes Made

### 1. Token Management Improvements
- Fixed naming conflicts in tokenManager
- Added consistent token storage keys
- Enhanced error logging and debugging
- Improved token synchronization between storage locations

### 2. Auth Service Updates
- Added proper token refresh mechanics
- Improved token storage and retrieval
- Better error handling and recovery

### 3. API Client Integration
- Added smart auth header handling
- Improved token validation
- Better error recovery for auth failures

### 4. Documentation
- Added comprehensive debugging guide (DEBUG_NOTES.md)
- Documented token flow (TOKEN_FLOW.md)
- Added testing instructions

## Key Files Changed
1. src/shared/api/tokenManager.ts
2. src/shared/auth/authService.ts
3. src/shared/auth/types.ts
4. src/features/exams/api/examService.ts

## Testing Instructions

### 1. Token Persistence
```typescript
// Login and check token storage
await authService.login(credentials);
expect(localStorage.getItem(TOKEN_CONFIG.ACCESS_TOKEN_KEY)).toBeTruthy();
expect(tokenManager.hasToken()).toBe(true);
```

### 2. Auth Headers
```typescript
// Verify API calls include auth headers
const response = await examService.getPublishedExams();
expect(response.status).toBe(200);
```

### 3. Token Refresh
```typescript
// Force token expiry and verify refresh
tokenManager.setTokenExpiry(Date.now() - 1000);
await examService.getPublishedExams(); // Should trigger refresh
expect(tokenManager.hasToken()).toBe(true);
```

### 4. Error Recovery
```typescript
// Test error handling
localStorage.clear();
await expect(examService.getAllExams()).rejects.toThrow('Authentication required');
```

## Debugging

### Token State
Use the browser console:
```javascript
// Check auth state
Object.keys(localStorage).filter(k => k.startsWith('pharmacyhub_'))

// Inspect token
const token = tokenManager.getToken();
console.log('Token:', token?.substring(0, 20) + '...');
```

### Common Issues
1. Token not being sent
   - Check Network tab in DevTools
   - Verify Authorization header format

2. Token refresh failing
   - Check refresh token in localStorage
   - Verify refresh endpoint URL

3. Auth state mismatch
   - Check tokenManager.hasToken()
   - Verify localStorage persistence

## Deployment Notes

### Configuration
- Ensure TOKEN_CONFIG values match backend expectations
- Update API_CONFIG.BASE_URL for production

### Monitoring
Added debug logs for:
- Token operations
- Auth state changes
- API request failures

### Breaking Changes
None. This PR improves existing functionality without changing APIs.

## Follow-up Tasks
1. Add token rotation on refresh
2. Implement offline token storage
3. Add real-time token validation
4. Enhance error messages

## Resources
- [Token Management Docs](./TOKEN_FLOW.md)
- [Debugging Guide](./DEBUG_NOTES.md)
- [Auth Integration Tests](../tests/auth)
</file>

<file path="docs/project-architecture.md">
# PharmacyHub Project Architecture

## Overview

PharmacyHub is a comprehensive platform for pharmacists and pharmacy students. The application includes features for exams, educational content, and professional development tracking.

## Tech Stack

### Frontend
- **Framework**: Next.js (React)
- **State Management**: Likely using React hooks, Context API and custom stores
- **Styling**: Tailwind CSS (based on components.json)
- **Testing**: Jest
- **TypeScript**: For type safety

### Backend
- **Framework**: Spring Boot 3.1.x
- **Database Access**: Spring Data JPA
- **Security**: Spring Security with JWT
- **Documentation**: SpringDoc OpenAPI
- **Database**: PostgreSQL (production) / H2 (development)
- **Testing**: JUnit Jupiter
- **API Style**: RESTful

## Architecture

### Frontend Architecture

The frontend follows a feature-based architecture:

```
src/
├── app/              # Next.js page routes 
├── components/       # Shared UI components
├── features/         # Feature modules
│   ├── exams/        # Exam feature
│   │   ├── api/      # API integration
│   │   ├── hooks/    # Custom React hooks
│   │   ├── model/    # TypeScript types and interfaces
│   │   ├── store/    # State management
│   │   └── ui/       # UI components
│   └── progress/     # Progress tracking feature
└── shared/           # Shared utilities and services
    ├── api/          # API client utilities
    └── auth/         # Authentication utilities
```

#### Design Patterns

1. **Feature-Based Organization**: Code is organized around business features rather than technical concerns
2. **Adapter Pattern**: Used to transform data between frontend and backend formats
3. **Repository Pattern**: API clients abstract data access details
4. **Hooks Pattern**: Custom React hooks encapsulate reusable logic
5. **Store Pattern**: State management for complex features

### Backend Architecture

The backend follows a layered architecture:

```
src/main/java/com/pharmacyhub/
├── controller/       # REST API controllers
├── domain/           # Domain entities and repositories
│   ├── entity/       # JPA entity classes
│   └── repository/   # Spring Data repositories
├── dto/              # Data Transfer Objects
├── service/          # Business logic layer
│   ├── interfaces/   # Service interfaces
│   └── impl/         # Service implementations
├── security/         # Security configuration and JWT
└── loader/           # Data loaders for sample/test data
```

#### Design Patterns

1. **Layered Architecture**: Clear separation between controllers, services, and repositories
2. **Repository Pattern**: Spring Data JPA repositories for data access
3. **DTO Pattern**: Separate objects for API communication
4. **Service Pattern**: Business logic encapsulated in services
5. **Dependency Injection**: Spring's IoC container manages dependencies

## Data Flow

1. **API Request Flow**:
   - Request from browser → Next.js → API client → Backend Controller → Service → Repository → Database
   - Response: Database → Repository → Service → Controller → API client → React component

2. **State Management Flow**:
   - User action → React component → Custom hook → API client → Backend
   - Or: User action → React component → Store → React components (re-render)

## Integration Points

1. **API Integration**:
   - Frontend API clients in `features/*/api/` folders
   - Backend controllers define REST endpoints
   - JWT authentication for secure communication

2. **Authentication Flow**:
   - Login → JWT token generation → Token storage → Include token in API requests
   - Authenticated routes protected on both frontend and backend
   
## Deployment Strategy

The application likely follows a containerized deployment approach:
- Docker containers for frontend and backend
- Separate databases for different environments
- CI/CD pipeline for automated deployments

## Development Patterns

1. **TypeScript Type Safety**: Strict typing between frontend and backend
2. **Adapter Pattern**: For data transformation between API and frontend models
3. **Feature-First Organization**: Code organized around business features
4. **Layered Security**: JWT-based authentication with role-based access control

## Exam Feature Architecture

The exam feature follows a clean structure:
1. **Model Layer**: Type definitions in `mcqTypes.ts` and `types.ts`
2. **API Layer**: Adapters and API clients for data fetching
3. **UI Layer**: React components for exam taking and result display
4. **Store Layer**: State management for exam session data

### API Contract
- GET /exams - Get all exams
- GET /exams/published - Get published exams
- GET /exams/:id - Get exam by ID
- GET /exams/:id/questions - Get questions for exam
- POST /exams/:id/start - Start an exam attempt
- POST /exams/:id/submit - Submit exam answers
- GET /exams/attempts/:id/result - Get exam result

## Conclusion

PharmacyHub follows modern architecture practices with clear separation of concerns, type safety, and modular organization. The feature-based approach makes it easy to add new features while maintaining existing ones.
</file>

<file path="docs/README.md">
# PharmacyHub Frontend Documentation

Welcome to the PharmacyHub frontend documentation. This repository provides comprehensive information about the project's architecture, features, and development guidelines.

## Documentation Structure

1. [Overview](./01-overview/README.md)
   - System purpose and requirements
   - Technical stack
   - Getting started

2. [Architecture](./02-architecture/README.md)
   - Project structure
   - Design patterns
   - Component organization
   - State management

3. [Authentication](./03-authentication/README.md)
   - Authentication system
   - Keycloak integration
   - Permission system
   - Security considerations

4. [Features](./04-features/README.md)
   - Licensing management
   - Exam preparation
   - Pharmacy operations
   - Reporting & analytics

5. [Development](./05-development/README.md)
   - Development standards
   - Coding patterns
   - API integration
   - Testing guidelines

6. [Deployment](./06-deployment/README.md)
   - Deployment architecture
   - CI/CD pipeline
   - Environment configuration
   - Monitoring & logging

7. [Assets](./07-assets/README.md)
   - Image requirements
   - Asset organization
   - Optimization guidelines

## Quick Start

```bash
# Install dependencies
npm install

# Run development server
npm run dev
```

## Project Overview

PharmacyHub is a comprehensive pharmacy management and licensing platform built with Next.js 15, TypeScript, and Keycloak for authentication. The application follows Feature-Sliced Design (FSD) principles and Domain-Driven Design (DDD) for maintainable, scalable architecture.

For detailed information, please navigate to the appropriate section in the documentation structure.
</file>

<file path="docs/TOKEN_FLOW.md">
# Token Flow & Authentication

## Overview
The authentication flow has been improved to handle tokens more reliably and provide better error handling.

## Token Storage Locations
1. localStorage (primary storage)
2. tokenManager (in-memory for API requests)
3. authService (for auth state management)

## Flow Diagram
```mermaid
graph TD
    A[Login] -->|success| B[saveTokens]
    B -->|save| C[localStorage]
    B -->|sync| D[tokenManager]
    B -->|update| E[AuthContext]
    F[API Request] -->|check| D
    F -->|fallback| C
    G[Refresh Token] -->|update| B
```

## Authentication States

### 1. Initial Login
```typescript
// In authService
login = async (emailAddress: string, password: string) => {
  const data = await loginRequest();
  this.saveTokens(data);
  await this.getUserProfile();
}
```

### 2. API Requests
```typescript
// In examService
const token = localStorage.getItem(TOKEN_CONFIG.ACCESS_TOKEN_KEY) || 
              tokenManager.getToken();
if (token) {
  headers['Authorization'] = `Bearer ${token}`;
}
```

### 3. Token Refresh
```typescript
// In authService
refreshToken = async () => {
  const data = await refreshRequest();
  this.saveTokens(data);
  tokenManager.setToken(data.access_token);
}
```

## Error Handling

### Authentication Required
```typescript
if (!token) {
  throw new Error('Authentication required');
}
```

### Token Expired
```typescript
if (now > expiry - 5 * 60 * 1000) {
  await this.refreshToken();
}
```

### Public Endpoint Fallback
```typescript
// Try without auth first
const response = await apiClient.get(endpoint, { requiresAuth: false });
if (response.error?.status === 403) {
  // Fallback to authenticated request
  return authenticatedRequest();
}
```

## Testing Points
1. Token persistence across page reloads
2. Proper token refresh before expiry
3. Graceful handling of auth failures
4. Public endpoint access handling
5. Token synchronization between storage locations
</file>

<file path="eslint.config.mjs">
import {dirname} from 'path';
import {fileURLToPath} from 'url';
import {FlatCompat} from '@eslint/eslintrc';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends('next/core-web-vitals', 'next/typescript'),
];

export default eslintConfig;
</file>

<file path="final-build-fixes-summary.md">
# Final Build Fixes for PharmacyHub Frontend

## Overview

This document summarizes the fixes implemented to resolve the remaining build errors in the PharmacyHub frontend project. All changes were made following the feature-based architecture, ensuring that each fix was applied within the appropriate feature module.

## Key Fixes

### 1. Created Missing Module Files

- **Auth Mutations Module**
  - Created missing mutations file with proper hooks for login, registration, and password reset
  - Implemented backward compatibility for existing components

- **Auth Validation Module**
  - Added comprehensive password validation utilities
  - Implemented form validation for login, registration, and reset password flows

- **Shared Logger Module**
  - Created a flexible logging system for application-wide use
  - Implemented feature-specific logging capabilities

- **ExamQueries Hook**
  - Added proper query hooks for exam functionality
  - Implemented backward compatibility with existing components

### 2. Fixed Missing Service Methods

- **ExamService**
  - Added `getExamById` method to support exam detail views
  - Added `getUserAttempts` and `getAttempt` methods for proper exam session handling

### 3. Fixed Import Paths

- Updated auth-related imports to point to the auth feature
- Updated exam-related imports to point to the exams feature
- Fixed RBAC imports to use the proper feature modules
- Updated UI component imports to reference the features UI hooks

### 4. Added Missing Types

- Added `ResetStep` and `ResetStatus` types to support password reset flows
- Enhanced the user profile types for consistency

## Implementation Strategy

Each fix was implemented following these principles:

1. **Feature Integrity**: All changes were contained within the appropriate feature module
2. **Minimal Changes**: Only created what was necessary to fix the errors
3. **Backward Compatibility**: Ensured existing components continue to work
4. **No Duplication**: Avoided creating redundant utility functions
5. **Modern Patterns**: Used React hooks and modern JavaScript patterns

## Verification

The fixes were verified by successfully building the application, ensuring all webpack errors were resolved.

## Recommendations

For future development:

1. **Strict Feature Boundary Enforcement**: Continue to enforce strict feature boundaries to prevent cross-feature dependencies
2. **Component Documentation**: Add documentation for key components in each feature
3. **Type Enhancement**: Improve type definitions for better IDE support and error prevention
4. **Testing**: Add comprehensive tests for each feature module
5. **Feature Registry**: Implement a formal feature registry to manage feature dependencies
</file>

<file path="final-eslint-webpack-fixes.md">
# Final Build Fixes - ESLint and Webpack Issues

This document summarizes the final fixes implemented to resolve all ESLint and Webpack build issues in the PharmacyHub frontend project.

## Webpack Issues Fixed

1. **Conflicting Exports in Auth Module**
   - Fixed conflicting star exports for TOKEN_CONFIG in auth/index.ts
   - Changed from wildcard export to named export for apiRoutes

2. **Missing Feature Flag Service**
   - Added featureFlagService export to rbac/api/index.ts
   - Removed duplicate export from rbac/index.ts

## ESLint Issues Fixed

1. **Unescaped Entities**
   - Fixed apostrophes in:
     - ForgotPasswordForm.tsx
     - ResetPasswordForm.tsx
     - ExamContainer.tsx
     - McqExamLayout.tsx
     - McqExamResults.tsx
     - RegisterForm.tsx

2. **Missing Permissions Constants**
   - Added comprehensive permissions constants file for RBAC
   - Implemented Role enum and Permission types
   - Added default permission mappings

3. **Client Component Issues**
   - Added "use client" directive to ReviewMode.tsx for Next.js compatibility

4. **Missing Types**
   - Added MCQPaper and UserAnswer types in exams module
   - Created full type definitions for the exam feature

## Architecture Improvements

1. **Feature Consistency**
   - Maintained feature-based architecture throughout
   - Ensured each fix was contained within its respective feature module

2. **Import Structure**
   - Prioritized direct imports from features over shared imports
   - Fixed circular dependencies

3. **Code Quality**
   - Fixed ESLint warnings about unused variables
   - Addressed potential React Hook dependency issues

## Next Steps

With these fixes implemented, the application now builds successfully with only minor ESLint warnings that don't affect functionality. For future development, consider:

1. Implementing stricter ESLint rules to prevent similar issues
2. Adding pre-commit hooks to catch these issues earlier
3. Setting up CI/CD to run build verification automatically
4. Adding comprehensive tests to validate functionality
</file>

<file path="final-fixes-summary.md">
# Final Build Errors Fix Summary

This document summarizes the final fixes implemented to resolve the build errors in the PharmacyHub frontend project.

## Issues Fixed

### 1. Duplicate Export in RBAC Feature

- **Problem**: The `featureFlagService` was being exported twice from the `rbac/index.ts` file, once from the API export and once directly from the services folder.
- **Solution**: Removed the duplicate export, keeping only the one from the API export.

### 2. Missing Permissions Constants

- **Problem**: The `RoleGuards.tsx` component was importing from a non-existent `constants/permissions` module.
- **Solution**: Created the permissions constants file with comprehensive role and permission definitions to support the RBAC system.

### 3. Client Component Using Server-Only Hooks

- **Problem**: The `ReviewMode.tsx` component was using the client-side `useRouter` hook without the `"use client"` directive.
- **Solution**: Added the required directive to ensure proper client-side rendering.

### 4. Missing Types for Exam Models

- **Problem**: The exams feature was missing proper type definitions for `MCQPaper` and `UserAnswer` that were being referenced.
- **Solution**: Created a comprehensive types file with all required interfaces for the exams feature.

## Architecture Improvements

All fixes were implemented following these principles:

1. **Feature-Based Approach**: Each fix was contained within its respective feature module, maintaining the established architecture.

2. **Complete Type Definitions**: Added comprehensive type definitions rather than minimal fixes to ensure better type safety throughout the application.

3. **Consistent Patterns**: Maintained the existing patterns for constants, components, and type definitions.

4. **Client/Server Separation**: Properly marked client components to ensure Next.js server components work correctly.

## Next Steps

Now that all build errors are resolved, we recommend:

1. Adding unit tests for the components and features to catch type errors early
2. Implementing a component documentation system
3. Setting up CI/CD processes to check for build errors automatically
4. Creating a style guide to maintain consistency across features
</file>

<file path="jest.config.js">
const nextJest = require('next/jest');

const createJestConfig = nextJest({
  dir: './',
});

const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testEnvironment: 'jest-environment-jsdom',
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  testMatch: [
    '<rootDir>/src/**/__tests__/**/*.{ts,tsx}',
    '<rootDir>/src/**/*.{spec,test}.{ts,tsx}'
  ],
};

module.exports = createJestConfig(customJestConfig);
</file>

<file path="jest.setup.js">
import '@testing-library/jest-dom';
import 'jest-fetch-mock';

// Mock globals for testing environment
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  clear: jest.fn(),
  removeItem: jest.fn(),
  length: 0,
  key: jest.fn(),
};

global.localStorage = localStorageMock;

// Mock window.location
const locationMock = {
  href: '',
  pathname: '',
  assign: jest.fn(),
  replace: jest.fn(),
};

Object.defineProperty(window, 'location', {
  value: locationMock,
  writable: true
});

// Reset all mocks before each test
beforeEach(() => {
  jest.clearAllMocks();
  localStorage.clear();
  fetch.resetMocks();
  window.location.href = '';
});
</file>

<file path="mutations.ts.fixed">
import { useApiMutation } from '@/features/tanstack-query-api';
import { AUTH_ROUTES } from '../../constants/routes';
import type { 
  AuthResponse, 
  AuthTokens, 
  LoginRequest, 
  RegisterRequest 
} from './authService';

/**
 * Hook for handling login mutations
 */
export const useLoginMutation = () => {
  return useApiMutation<AuthResponse, LoginRequest>(
    AUTH_ROUTES.LOGIN,
    {
      onSuccess: (data) => {
        // Save tokens on successful login
        if (data.tokens) {
          // Store tokens using authService
          const authService = require('./authService').default;
          authService.storeTokens(data.tokens);
        }
      }
    }
  );
};

/**
 * Hook for handling registration mutations
 */
export const useRegisterMutation = () => {
  return useApiMutation<AuthResponse, RegisterRequest>(
    AUTH_ROUTES.REGISTER,
    {
      onSuccess: (data) => {
        // Save tokens on successful registration
        if (data.tokens) {
          const authService = require('./authService').default;
          authService.storeTokens(data.tokens);
        }
      }
    }
  );
};

/**
 * Hook for handling password reset request
 */
export const usePasswordResetRequestMutation = () => {
  return useApiMutation<{ success: boolean }, { email: string }>(
    AUTH_ROUTES.REQUEST_PASSWORD_RESET
  );
};

/**
 * Hook for handling password reset completion
 */
export const usePasswordResetCompleteMutation = () => {
  return useApiMutation<void, { token: string; newPassword: string; confirmPassword: string }>(
    AUTH_ROUTES.RESET_PASSWORD
  );
};

/**
 * Hook for handling logout
 */
export const useLogoutMutation = () => {
  return useApiMutation<void, void>(
    AUTH_ROUTES.LOGOUT,
    {
      onSuccess: () => {
        const authService = require('./authService').default;
        authService.clearTokens();
        window.location.href = '/login';
      }
    }
  );
};

/**
 * Hook for refreshing auth token
 */
export const useRefreshTokenMutation = () => {
  return useApiMutation<AuthTokens, { refreshToken: string }>(
    AUTH_ROUTES.REFRESH_TOKEN,
    {
      onSuccess: (data) => {
        if (data) {
          const authService = require('./authService').default;
          authService.storeTokens(data);
        }
      }
    }
  );
};
</file>

<file path="next.config.ts">
import type {NextConfig} from "next";

const nextConfig: NextConfig = {
  /* config options here */
  webpack: (config, { isServer }) => {
    // Handle browser-incompatible modules
    if (!isServer) {
      config.resolve.fallback = {
        ...config.resolve.fallback,
        fs: false,
        path: false,
        os: false,
        crypto: false,
        // Add other Node.js modules if needed
      };
    }
    
    return config;
  },
};

export default nextConfig;
</file>

<file path="package.json">
{
  "name": "pharmacyhub-next",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "shadcn": "shadcn-ui",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "dependencies": {
    "@auth/core": "^0.37.4",
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@hookform/resolvers": "^4.1.0",
    "@mui/icons-material": "^6.3.0",
    "@mui/material": "^6.3.0",
    "@radix-ui/react-accordion": "^1.2.3",
    "@radix-ui/react-alert-dialog": "^1.1.6",
    "@radix-ui/react-aspect-ratio": "^1.1.2",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-checkbox": "^1.1.4",
    "@radix-ui/react-collapsible": "^1.1.3",
    "@radix-ui/react-context-menu": "^2.2.6",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-dropdown-menu": "^2.1.6",
    "@radix-ui/react-hover-card": "^1.1.6",
    "@radix-ui/react-icons": "^1.3.2",
    "@radix-ui/react-label": "^2.1.2",
    "@radix-ui/react-menubar": "^1.1.6",
    "@radix-ui/react-navigation-menu": "^1.2.5",
    "@radix-ui/react-popover": "^1.1.6",
    "@radix-ui/react-progress": "^1.1.2",
    "@radix-ui/react-radio-group": "^1.2.3",
    "@radix-ui/react-scroll-area": "^1.2.3",
    "@radix-ui/react-select": "^2.1.6",
    "@radix-ui/react-separator": "^1.1.2",
    "@radix-ui/react-slider": "^1.2.3",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-switch": "^1.1.3",
    "@radix-ui/react-tabs": "^1.1.3",
    "@radix-ui/react-toast": "^1.2.6",
    "@radix-ui/react-toggle": "^1.1.2",
    "@radix-ui/react-toggle-group": "^1.1.2",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@tabler/icons": "^3.26.0",
    "@tanstack/react-query": "^5.62.11",
    "@tanstack/react-query-devtools": "^5.62.11",
    "@types/jwt-decode": "^2.2.1",
    "axios": "^1.7.9",
    "buffer": "^6.0.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "date-fns": "^3.6.0",
    "embla-carousel-autoplay": "^8.5.1",
    "embla-carousel-react": "^8.5.2",
    "framer-motion": "^12.4.5",
    "input-otp": "^1.4.2",
    "jwt-decode": "^4.0.0",
    "lucide-react": "^0.468.0",
    "next": "15.1.7",
    "next-auth": "^4.24.11",
    "next-themes": "^0.4.4",
    "react": "19.0.0",
    "react-day-picker": "^8.10.1",
    "react-dom": "19.0.0",
    "react-hook-form": "^7.54.2",
    "react-icon": "^1.0.0",
    "react-icons": "^5.4.0",
    "react-resizable-panels": "^2.1.7",
    "react-router": "^7.1.1",
    "react-tooltip": "^5.28.0",
    "recharts": "^2.15.1",
    "sonner": "^2.0.0",
    "stream": "^0.0.3",
    "tailwind-merge": "^2.5.5",
    "tailwindcss-animate": "^1.0.7",
    "util": "^0.12.5",
    "vaul": "^1.1.2",
    "winston": "^3.17.0",
    "winston-daily-rotate-file": "^5.0.0",
    "zod": "^3.24.2",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tanstack/eslint-plugin-query": "^5.62.9",
    "@types/node": "^20",
    "@types/react": "19.0.10",
    "@types/react-dom": "19.0.4",
    "autoprefixer": "^10.4.20",
    "eslint": "^9",
    "eslint-config-next": "15.1.7",
    "postcss": "^8.4.49",
    "tailwindcss": "^3.4.16",
    "typescript": "^5"
  },
  "overrides": {
    "@types/react": "19.0.10",
    "@types/react-dom": "19.0.4"
  }
}
</file>

<file path="pharmacyhub-frontend.iml">
<?xml version="1.0" encoding="UTF-8"?>
<module type="WEB_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$" />
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
</file>

<file path="pharmacyhub-next.iml">
<?xml version="1.0" encoding="UTF-8"?>
<module type="WEB_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$" />
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
</file>

<file path="postcss.config.mjs">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="proposed-jwt-enhancement.java">
// Proposed enhancement to JwtHelper.java
private String doGenerateToken(Map<String, Object> claims, String subject) {
    // Get user roles and permissions
    User user = userRepository.findByEmailAddress(subject)
        .orElseThrow(() -> new UsernameNotFoundException("User not found: " + subject));
    
    // Add roles and permissions to claims
    Set<String> roleNames = user.getRoles().stream()
        .map(role -> role.getName())
        .collect(Collectors.toSet());
    claims.put("roles", roleNames);
    
    // Add authorities (including permissions) for Spring Security format
    Set<String> authorities = new HashSet<>();
    
    // Add role-based authorities (ROLE_XXX format for Spring Security)
    roleNames.forEach(role -> authorities.add("ROLE_" + role));
    
    // Add permissions
    Set<Permission> permissions = rbacService.getUserEffectivePermissions(user.getId());
    permissions.forEach(permission -> authorities.add(permission.getName()));
    
    claims.put("authorities", authorities);
    
    // Create token with enhanced claims
    return Jwts.builder()
        .setClaims(claims)
        .setSubject(subject)
        .setIssuedAt(new Date(System.currentTimeMillis()))
        .setExpiration(new Date(System.currentTimeMillis() + JWT_TOKEN_VALIDITY * 1000))
        .signWith(SignatureAlgorithm.HS512, secret)
        .compact();
}
</file>

<file path="proposed-user-profile-controller.java">
// Proposed UserProfileController
package com.pharmacyhub.controller;

import com.pharmacyhub.dto.UserProfileDTO;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.service.RBACService;
import com.pharmacyhub.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Set;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/users")
public class UserProfileController {

    @Autowired
    private UserService userService;
    
    @Autowired
    private RBACService rbacService;
    
    /**
     * Get the complete profile of the currently authenticated user including roles and permissions
     */
    @PreAuthorize("isAuthenticated()")
    @GetMapping("/profile")
    public ResponseEntity<UserProfileDTO> getUserProfile() {
        User currentUser = userService.getLoggedInUser();
        
        if (currentUser == null) {
            return ResponseEntity.notFound().build();
        }
        
        // Get user roles
        Set<Role> roles = rbacService.getUserRoles(currentUser.getId());
        Set<String> roleNames = roles.stream()
            .map(Role::getName)
            .collect(Collectors.toSet());
            
        // Get user permissions
        Set<Permission> permissions = rbacService.getUserEffectivePermissions(currentUser.getId());
        Set<String> permissionNames = permissions.stream()
            .map(Permission::getName)
            .collect(Collectors.toSet());
        
        // Build the user profile response
        UserProfileDTO profile = UserProfileDTO.builder()
            .id(currentUser.getId())
            .emailAddress(currentUser.getEmailAddress())
            .firstName(currentUser.getFirstName())
            .lastName(currentUser.getLastName())
            .contactNumber(currentUser.getContactNumber())
            .userType(currentUser.getUserType())
            .registered(currentUser.isRegistered())
            .openToConnect(currentUser.isOpenToConnect())
            .verified(currentUser.isVerified())
            .roles(roleNames)
            .permissions(permissionNames)
            .build();
            
        return ResponseEntity.ok(profile);
    }
}
</file>

<file path="proposed-user-profile-dto.java">
// Proposed UserProfileDTO
package com.pharmacyhub.dto;

import com.pharmacyhub.entity.enums.UserType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Set;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserProfileDTO {
    private Long id;
    private String emailAddress;
    private String firstName;
    private String lastName;
    private String contactNumber;
    private UserType userType;
    private boolean registered;
    private boolean openToConnect;
    private boolean verified;
    private Set<String> roles;
    private Set<String> permissions;
}
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
    <path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z"
          clip-rule="evenodd" fill="#666" fill-rule="evenodd"/>
</svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
    <g clip-path="url(#a)">
        <path fill-rule="evenodd" clip-rule="evenodd"
              d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1"
              fill="#666"/>
    </g>
    <defs>
        <clipPath id="a">
            <path fill="#fff" d="M0 0h16v16H0z"/>
        </clipPath>
    </defs>
</svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80">
    <path fill="#000"
          d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/>
    <path fill="#000"
          d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/>
</svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000">
    <path d="m577.3 0 577.4 1000H0z" fill="#fff"/>
</svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
    <path fill-rule="evenodd" clip-rule="evenodd"
          d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5"
          fill="#666"/>
</svg>
</file>

<file path="queries.ts.fixed">
import { useApiQuery } from '@/features/tanstack-query-api';
import { authKeys } from '../queryKeys';
import { AUTH_ROUTES } from '../../constants/routes';
import type { User } from './userService';

/**
 * Hook for fetching the current user's profile
 */
export const useUserProfile = () => {
  return useApiQuery<User>(
    authKeys.me(),
    AUTH_ROUTES.PROFILE,
    {
      staleTime: 5 * 60 * 1000, // Consider profile data fresh for 5 minutes
      gcTime: 30 * 60 * 1000, // Keep in cache for 30 minutes
    }
  );
};

/**
 * Hook for validating password reset token
 */
export const useResetTokenValidation = (token: string) => {
  return useApiQuery<{ valid: boolean }>(
    authKeys.resetToken(token),
    `${AUTH_ROUTES.RESET_PASSWORD}/validate/${token}`,
    {
      enabled: !!token,
      // Don't cache or retry invalid tokens
      gcTime: 0,
      retry: false
    }
  );
};
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [
`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically
optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions
are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use
the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme)
from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for
more details.
</file>

<file path="scripts/finalize-entities.bat">
@echo off
echo Finalizing entity organization...

REM Create model files for entities
echo export interface User {> src\entities\user\model.ts
echo   id: string;>> src\entities\user\model.ts
echo   email: string;>> src\entities\user\model.ts
echo   role: string;>> src\entities\user\model.ts
echo   name?: string;>> src\entities\user\model.ts
echo }>> src\entities\user\model.ts

echo export interface Pharmacy {> src\entities\pharmacy\model.ts
echo   id: string;>> src\entities\pharmacy\model.ts
echo   name: string;>> src\entities\pharmacy\model.ts
echo   address: string;>> src\entities\pharmacy\model.ts
echo   licenseNumber?: string;>> src\entities\pharmacy\model.ts
echo }>> src\entities\pharmacy\model.ts

echo export interface License {> src\entities\license\model.ts
echo   id: string;>> src\entities\license\model.ts
echo   number: string;>> src\entities\license\model.ts
echo   type: string;>> src\entities\license\model.ts
echo   expiryDate: string;>> src\entities\license\model.ts
echo   status: string;>> src\entities\license\model.ts
echo }>> src\entities\license\model.ts

REM Create index files for entities
echo export * from './model';> src\entities\user\index.ts
echo export * from './model';> src\entities\pharmacy\index.ts
echo export * from './model';> src\entities\license\index.ts

REM Move entity-related types
move src\shared\types\User.tsx src\entities\user\types.ts
type src\shared\types\role.ts >> src\entities\user\types.ts
del src\shared\types\role.ts

echo Creating API layers for entities...
mkdir src\entities\user\api
mkdir src\entities\pharmacy\api
mkdir src\entities\license\api

REM Create API files
echo // User API endpoints and services> src\entities\user\api\index.ts
echo // Pharmacy API endpoints and services> src\entities\pharmacy\api\index.ts
echo // License API endpoints and services> src\entities\license\api\index.ts

echo Entity organization complete.
</file>

<file path="scripts/migrate-frontend.bat">
@echo off
echo Starting frontend migration...

REM Create backup of current src directory
echo Creating backup...
xcopy /E /I src src_backup_%date:~-4,4%%date:~-10,2%%date:~-7,2%

REM Clean up any existing duplicate directories
rmdir /S /Q src\src 2>nul
rmdir /S /Q src\features 2>nul
rmdir /S /Q src\entities 2>nul
rmdir /S /Q src\shared 2>nul

REM Create FSD structure
echo Creating FSD structure...
mkdir src\features
mkdir src\entities
mkdir src\shared

REM Create feature layers
mkdir src\features\licensing\ui
mkdir src\features\licensing\model
mkdir src\features\licensing\api
mkdir src\features\licensing\lib

mkdir src\features\exams\ui
mkdir src\features\exams\model
mkdir src\features\exams\api
mkdir src\features\exams\lib

REM Create shared layers
mkdir src\shared\ui
mkdir src\shared\api
mkdir src\shared\config
mkdir src\shared\lib
mkdir src\shared\types

REM Create entities
mkdir src\entities\user
mkdir src\entities\pharmacy
mkdir src\entities\license

REM Move files to new structure
echo Moving files to new structure...

REM Move UI components to shared
xcopy /E /I src\components\ui\* src\shared\ui\
rmdir /S /Q src\components\ui

REM Move navigation components
mkdir src\shared\ui\navigation
xcopy /E /I src\components\NavigationBar\* src\shared\ui\navigation\
rmdir /S /Q src\components\NavigationBar

REM Move sidebar components
mkdir src\shared\ui\sidebar
xcopy /E /I src\components\NavSideBar\* src\shared\ui\sidebar\
rmdir /S /Q src\components\NavSideBar

REM Move API and services
mkdir src\shared\api\services
xcopy /E /I src\api\* src\shared\api\
rmdir /S /Q src\api

REM Move config and utils
xcopy /E /I src\config\* src\shared\config\
rmdir /S /Q src\config
xcopy /E /I src\lib\* src\shared\lib\
rmdir /S /Q src\lib
xcopy /E /I src\types\* src\shared\types\
rmdir /S /Q src\types
xcopy /E /I src\utils\* src\shared\lib\utils\
rmdir /S /Q src\utils

REM Move feature-specific components
xcopy /E /I src\components\RegistrationForm\* src\features\licensing\ui\forms\
xcopy /E /I src\components\Pharmacist\* src\features\licensing\ui\pharmacist\
xcopy /E /I src\components\PharmacyManager\* src\features\licensing\ui\pharmacy-manager\
xcopy /E /I src\components\Proprietor\* src\features\licensing\ui\proprietor\
xcopy /E /I src\components\Salesman\* src\features\licensing\ui\salesman\
rmdir /S /Q src\components\RegistrationForm
rmdir /S /Q src\components\Pharmacist
rmdir /S /Q src\components\PharmacyManager
rmdir /S /Q src\components\Proprietor
rmdir /S /Q src\components\Salesman

REM Move hooks
mkdir src\shared\lib\hooks
move src\hooks\useApi.ts src\shared\api\hooks\useApi.ts
move src\hooks\useAuth.ts src\features\licensing\lib\hooks\useAuth.ts
move src\hooks\useDebounce.ts src\shared\lib\hooks\useDebounce.ts
move src\hooks\use-mobile.tsx src\shared\lib\hooks\use-mobile.tsx
rmdir /S /Q src\hooks

REM Create index files
echo Creating index files...
echo export * from './ui';> src\shared\index.ts
echo export * from './api';>> src\shared\index.ts
echo export * from './config';>> src\shared\index.ts
echo export * from './lib';>> src\shared\index.ts
echo export * from './types';>> src\shared\index.ts

echo export * from './model';> src\features\licensing\index.ts
echo export * from './ui';>> src\features\licensing\index.ts
echo export * from './api';>> src\features\licensing\index.ts
echo export * from './lib';>> src\features\licensing\index.ts

echo export * from './model';> src\features\exams\index.ts
echo export * from './ui';>> src\features\exams\index.ts
echo export * from './api';>> src\features\exams\index.ts
echo export * from './lib';>> src\features\exams\index.ts

echo Migration completed successfully.
</file>

<file path="scripts/move-connections-pages.bat">
@echo off
echo Moving connection and request pages...

REM Create connections directories
mkdir src\features\licensing\ui\pages\connections\pharmacist
mkdir src\features\licensing\ui\pages\connections\pharmacy-manager
mkdir src\features\licensing\ui\pages\connections\proprietor
mkdir src\features\licensing\ui\pages\connections\salesman

REM Move pharmacist connections
echo import { SidebarLayout } from "@/shared/ui/sidebar/SideBarLayout";> src\features\licensing\ui\pages\connections\pharmacist\page.tsx
echo import { PharmacistConnections } from "@/features/licensing/ui/pharmacist/PharmacistConnections";>> src\features\licensing\ui\pages\connections\pharmacist\page.tsx
echo.>> src\features\licensing\ui\pages\connections\pharmacist\page.tsx
echo export default function PharmacistConnectionsPage() {>> src\features\licensing\ui\pages\connections\pharmacist\page.tsx
echo   return (>> src\features\licensing\ui\pages\connections\pharmacist\page.tsx
echo     ^<^>^<h1^>Pharmacist Connections^</h1^>^<PharmacistConnections/^>^</^>>> src\features\licensing\ui\pages\connections\pharmacist\page.tsx
echo   );>> src\features\licensing\ui\pages\connections\pharmacist\page.tsx
echo }>> src\features\licensing\ui\pages\connections\pharmacist\page.tsx

REM Move pharmacy manager connections
echo import { SidebarLayout } from "@/shared/ui/sidebar/SideBarLayout";> src\features\licensing\ui\pages\connections\pharmacy-manager\page.tsx
echo import { PharmacyManagerConnections } from "@/features/licensing/ui/pharmacy-manager/PharmacyManagerConnections";>> src\features\licensing\ui\pages\connections\pharmacy-manager\page.tsx
echo.>> src\features\licensing\ui\pages\connections\pharmacy-manager\page.tsx
echo export default function PharmacyManagerConnectionsPage() {>> src\features\licensing\ui\pages\connections\pharmacy-manager\page.tsx
echo   return (>> src\features\licensing\ui\pages\connections\pharmacy-manager\page.tsx
echo     ^<^>^<h1^>Pharmacy Manager Connections^</h1^>^<PharmacyManagerConnections/^>^</^>>> src\features\licensing\ui\pages\connections\pharmacy-manager\page.tsx
echo   );>> src\features\licensing\ui\pages\connections\pharmacy-manager\page.tsx
echo }>> src\features\licensing\ui\pages\connections\pharmacy-manager\page.tsx

REM Move proprietor connections
echo import { SidebarLayout } from "@/shared/ui/sidebar/SideBarLayout";> src\features\licensing\ui\pages\connections\proprietor\page.tsx
echo import { ProprietorConnections } from "@/features/licensing/ui/proprietor/ProprietorConnections";>> src\features\licensing\ui\pages\connections\proprietor\page.tsx
echo.>> src\features\licensing\ui\pages\connections\proprietor\page.tsx
echo export default function ProprietorConnectionsPage() {>> src\features\licensing\ui\pages\connections\proprietor\page.tsx
echo   return (>> src\features\licensing\ui\pages\connections\proprietor\page.tsx
echo     ^<^>^<h1^>Proprietor Connections^</h1^>^<ProprietorConnections/^>^</^>>> src\features\licensing\ui\pages\connections\proprietor\page.tsx
echo   );>> src\features\licensing\ui\pages\connections\proprietor\page.tsx
echo }>> src\features\licensing\ui\pages\connections\proprietor\page.tsx

REM Move salesman connections
echo import { SidebarLayout } from "@/shared/ui/sidebar/SideBarLayout";> src\features\licensing\ui\pages\connections\salesman\page.tsx
echo import { SalesmanConnections } from "@/features/licensing/ui/salesman/SalesmanConnections";>> src\features\licensing\ui\pages\connections\salesman\page.tsx
echo.>> src\features\licensing\ui\pages\connections\salesman\page.tsx
echo export default function SalesmanConnectionsPage() {>> src\features\licensing\ui\pages\connections\salesman\page.tsx
echo   return (>> src\features\licensing\ui\pages\connections\salesman\page.tsx
echo     ^<^>^<h1^>Salesman Connections^</h1^>^<SalesmanConnections/^>^</^>>> src\features\licensing\ui\pages\connections\salesman\page.tsx
echo   );>> src\features\licensing\ui\pages\connections\salesman\page.tsx
echo }>> src\features\licensing\ui\pages\connections\salesman\page.tsx

REM Create Next.js route structure for connections
mkdir src\app\(licensing)\connections
mkdir src\app\(licensing)\connections\pharmacist
mkdir src\app\(licensing)\connections\pharmacy-manager
mkdir src\app\(licensing)\connections\proprietor
mkdir src\app\(licensing)\connections\salesman

REM Create Next.js route files
echo import { PharmacistConnectionsPage } from '@/features/licensing/ui/pages/connections/pharmacist/page';> src\app\(licensing)\connections\pharmacist\page.tsx
echo export default PharmacistConnectionsPage;>> src\app\(licensing)\connections\pharmacist\page.tsx

echo import { PharmacyManagerConnectionsPage } from '@/features/licensing/ui/pages/connections/pharmacy-manager/page';> src\app\(licensing)\connections\pharmacy-manager\page.tsx
echo export default PharmacyManagerConnectionsPage;>> src\app\(licensing)\connections\pharmacy-manager\page.tsx

echo import { ProprietorConnectionsPage } from '@/features/licensing/ui/pages/connections/proprietor/page';> src\app\(licensing)\connections\proprietor\page.tsx
echo export default ProprietorConnectionsPage;>> src\app\(licensing)\connections\proprietor\page.tsx

echo import { SalesmanConnectionsPage } from '@/features/licensing/ui/pages/connections/salesman/page';> src\app\(licensing)\connections\salesman\page.tsx
echo export default SalesmanConnectionsPage;>> src\app\(licensing)\connections\salesman\page.tsx

REM Clean up old connection pages
del src\app\(pages)\pharmacistsConnections\page.tsx
del src\app\(pages)\pharmacyManagerConnections\page.tsx
del src\app\(pages)\proprietorConnections\page.tsx
del src\app\(pages)\salesmanConnections\page.tsx

echo Connection pages moved successfully.
</file>

<file path="scripts/move-remaining-pages.bat">
@echo off
echo Moving and updating remaining pages...

REM Update and move pharmacy-manager page
echo import { SidebarLayout } from "@/shared/ui/sidebar/SideBarLayout";> src\features\licensing\ui\pages\pharmacy-manager\page.tsx
echo import { PharmacyManagerList } from "@/features/licensing/ui/pharmacy-manager/PharmacyManagerList";>> src\features\licensing\ui\pages\pharmacy-manager\page.tsx
echo.>> src\features\licensing\ui\pages\pharmacy-manager\page.tsx
echo export default function PharmacyManager() {>> src\features\licensing\ui\pages\pharmacy-manager\page.tsx
echo   return (>> src\features\licensing\ui\pages\pharmacy-manager\page.tsx
echo     ^<^>^<h1^>Pharmacy Managers Page^</h1^>^<PharmacyManagerList/^>^</^>>> src\features\licensing\ui\pages\pharmacy-manager\page.tsx
echo   );>> src\features\licensing\ui\pages\pharmacy-manager\page.tsx
echo }>> src\features\licensing\ui\pages\pharmacy-manager\page.tsx

REM Update and move proprietor page
echo import { SidebarLayout } from "@/shared/ui/sidebar/SideBarLayout";> src\features\licensing\ui\pages\proprietor\page.tsx
echo import { ProprietorList } from "@/features/licensing/ui/proprietor/ProprietorList";>> src\features\licensing\ui\pages\proprietor\page.tsx
echo.>> src\features\licensing\ui\pages\proprietor\page.tsx
echo export default function Proprietor() {>> src\features\licensing\ui\pages\proprietor\page.tsx
echo   return (>> src\features\licensing\ui\pages\proprietor\page.tsx
echo     ^<^>^<h1^>Proprietors Page^</h1^>^<ProprietorList/^>^</^>>> src\features\licensing\ui\pages\proprietor\page.tsx
echo   );>> src\features\licensing\ui\pages\proprietor\page.tsx
echo }>> src\features\licensing\ui\pages\proprietor\page.tsx

REM Update and move salesman page
echo import { SidebarLayout } from "@/shared/ui/sidebar/SideBarLayout";> src\features\licensing\ui\pages\salesman\page.tsx
echo import { SalesmanList } from "@/features/licensing/ui/salesman/SalesmanList";>> src\features\licensing\ui\pages\salesman\page.tsx
echo.>> src\features\licensing\ui\pages\salesman\page.tsx
echo export default function Salesman() {>> src\features\licensing\ui\pages\salesman\page.tsx
echo   return (>> src\features\licensing\ui\pages\salesman\page.tsx
echo     ^<^>^<h1^>Salesmen Page^</h1^>^<SalesmanList/^>^</^>>> src\features\licensing\ui\pages\salesman\page.tsx
echo   );>> src\features\licensing\ui\pages\salesman\page.tsx
echo }>> src\features\licensing\ui\pages\salesman\page.tsx

REM Create route configurations for each
echo Creating route configurations...

echo export const pharmacyManagerRoutes = {> src\features\licensing\ui\pages\pharmacy-manager\route.ts
echo   base: '/pharmacy-manager',>> src\features\licensing\ui\pages\pharmacy-manager\route.ts
echo   list: '/pharmacy-manager/list',>> src\features\licensing\ui\pages\pharmacy-manager\route.ts
echo   connections: '/pharmacy-manager/connections',>> src\features\licensing\ui\pages\pharmacy-manager\route.ts
echo   requests: '/pharmacy-manager/requests'>> src\features\licensing\ui\pages\pharmacy-manager\route.ts
echo };>> src\features\licensing\ui\pages\pharmacy-manager\route.ts

echo export const proprietorRoutes = {> src\features\licensing\ui\pages\proprietor\route.ts
echo   base: '/proprietor',>> src\features\licensing\ui\pages\proprietor\route.ts
echo   list: '/proprietor/list',>> src\features\licensing\ui\pages\proprietor\route.ts
echo   connections: '/proprietor/connections',>> src\features\licensing\ui\pages\proprietor\route.ts
echo   requests: '/proprietor/requests'>> src\features\licensing\ui\pages\proprietor\route.ts
echo };>> src\features\licensing\ui\pages\proprietor\route.ts

echo export const salesmanRoutes = {> src\features\licensing\ui\pages\salesman\route.ts
echo   base: '/salesman',>> src\features\licensing\ui\pages\salesman\route.ts
echo   list: '/salesman/list',>> src\features\licensing\ui\pages\salesman\route.ts
echo   connections: '/salesman/connections',>> src\features\licensing\ui\pages\salesman\route.ts
echo   requests: '/salesman/requests'>> src\features\licensing\ui\pages\salesman\route.ts
echo };>> src\features\licensing\ui\pages\salesman\route.ts

REM Update Next.js route files
mkdir src\app\(licensing)\pharmacy-manager
mkdir src\app\(licensing)\proprietor
mkdir src\app\(licensing)\salesman

echo import { PharmacyManager } from '@/features/licensing/ui/pages/pharmacy-manager/page';> src\app\(licensing)\pharmacy-manager\page.tsx
echo export default PharmacyManager;>> src\app\(licensing)\pharmacy-manager\page.tsx

echo import { Proprietor } from '@/features/licensing/ui/pages/proprietor/page';> src\app\(licensing)\proprietor\page.tsx
echo export default Proprietor;>> src\app\(licensing)\proprietor\page.tsx

echo import { Salesman } from '@/features/licensing/ui/pages/salesman/page';> src\app\(licensing)\salesman\page.tsx
echo export default Salesman;>> src\app\(licensing)\salesman\page.tsx

REM Clean up old files
del src\app\(pages)\pharmacy-manager\page.tsx
del src\app\(pages)\proprietor\page.tsx
del src\app\(pages)\salesman\page.tsx

REM Create index file for all routes
echo export * from './pharmacist/route';> src\features\licensing\ui\pages\routes.ts
echo export * from './pharmacy-manager/route';>> src\features\licensing\ui\pages\routes.ts
echo export * from './proprietor/route';>> src\features\licensing\ui\pages\routes.ts
echo export * from './salesman/route';>> src\features\licensing\ui\pages\routes.ts

echo Remaining pages moved and updated successfully.
</file>

<file path="scripts/move-requests-pages.bat">
@echo off
echo Moving request pages...

REM Create requests directories
mkdir src\features\licensing\ui\pages\requests\pharmacist
mkdir src\features\licensing\ui\pages\requests\pharmacy-manager
mkdir src\features\licensing\ui\pages\requests\proprietor
mkdir src\features\licensing\ui\pages\requests\salesman

REM Move pharmacist requests
echo import { SidebarLayout } from "@/shared/ui/sidebar/SideBarLayout";> src\features\licensing\ui\pages\requests\pharmacist\page.tsx
echo import { PharmacistRequests } from "@/features/licensing/ui/pharmacist/PharmacistRequests";>> src\features\licensing\ui\pages\requests\pharmacist\page.tsx
echo.>> src\features\licensing\ui\pages\requests\pharmacist\page.tsx
echo export default function PharmacistRequestsPage() {>> src\features\licensing\ui\pages\requests\pharmacist\page.tsx
echo   return (>> src\features\licensing\ui\pages\requests\pharmacist\page.tsx
echo     ^<^>^<h1^>Pharmacist Requests^</h1^>^<PharmacistRequests/^>^</^>>> src\features\licensing\ui\pages\requests\pharmacist\page.tsx
echo   );>> src\features\licensing\ui\pages\requests\pharmacist\page.tsx
echo }>> src\features\licensing\ui\pages\requests\pharmacist\page.tsx

REM Move pharmacy manager requests
echo import { SidebarLayout } from "@/shared/ui/sidebar/SideBarLayout";> src\features\licensing\ui\pages\requests\pharmacy-manager\page.tsx
echo import { PharmacyManagerRequests } from "@/features/licensing/ui/pharmacy-manager/PharmacyManagerRequests";>> src\features\licensing\ui\pages\requests\pharmacy-manager\page.tsx
echo.>> src\features\licensing\ui\pages\requests\pharmacy-manager\page.tsx
echo export default function PharmacyManagerRequestsPage() {>> src\features\licensing\ui\pages\requests\pharmacy-manager\page.tsx
echo   return (>> src\features\licensing\ui\pages\requests\pharmacy-manager\page.tsx
echo     ^<^>^<h1^>Pharmacy Manager Requests^</h1^>^<PharmacyManagerRequests/^>^</^>>> src\features\licensing\ui\pages\requests\pharmacy-manager\page.tsx
echo   );>> src\features\licensing\ui\pages\requests\pharmacy-manager\page.tsx
echo }>> src\features\licensing\ui\pages\requests\pharmacy-manager\page.tsx

REM Move proprietor requests
echo import { SidebarLayout } from "@/shared/ui/sidebar/SideBarLayout";> src\features\licensing\ui\pages\requests\proprietor\page.tsx
echo import { ProprietorRequests } from "@/features/licensing/ui/proprietor/ProprietorRequests";>> src\features\licensing\ui\pages\requests\proprietor\page.tsx
echo.>> src\features\licensing\ui\pages\requests\proprietor\page.tsx
echo export default function ProprietorRequestsPage() {>> src\features\licensing\ui\pages\requests\proprietor\page.tsx
echo   return (>> src\features\licensing\ui\pages\requests\proprietor\page.tsx
echo     ^<^>^<h1^>Proprietor Requests^</h1^>^<ProprietorRequests/^>^</^>>> src\features\licensing\ui\pages\requests\proprietor\page.tsx
echo   );>> src\features\licensing\ui\pages\requests\proprietor\page.tsx
echo }>> src\features\licensing\ui\pages\requests\proprietor\page.tsx

REM Move salesman requests
echo import { SidebarLayout } from "@/shared/ui/sidebar/SideBarLayout";> src\features\licensing\ui\pages\requests\salesman\page.tsx
echo import { SalesmanRequests } from "@/features/licensing/ui/salesman/SalesmanRequests";>> src\features\licensing\ui\pages\requests\salesman\page.tsx
echo.>> src\features\licensing\ui\pages\requests\salesman\page.tsx
echo export default function SalesmanRequestsPage() {>> src\features\licensing\ui\pages\requests\salesman\page.tsx
echo   return (>> src\features\licensing\ui\pages\requests\salesman\page.tsx
echo     ^<^>^<h1^>Salesman Requests^</h1^>^<SalesmanRequests/^>^</^>>> src\features\licensing\ui\pages\requests\salesman\page.tsx
echo   );>> src\features\licensing\ui\pages\requests\salesman\page.tsx
echo }>> src\features\licensing\ui\pages\requests\salesman\page.tsx

REM Create Next.js route structure for requests
mkdir src\app\(licensing)\requests
mkdir src\app\(licensing)\requests\pharmacist
mkdir src\app\(licensing)\requests\pharmacy-manager
mkdir src\app\(licensing)\requests\proprietor
mkdir src\app\(licensing)\requests\salesman

REM Create Next.js route files
echo import { PharmacistRequestsPage } from '@/features/licensing/ui/pages/requests/pharmacist/page';> src\app\(licensing)\requests\pharmacist\page.tsx
echo export default PharmacistRequestsPage;>> src\app\(licensing)\requests\pharmacist\page.tsx

echo import { PharmacyManagerRequestsPage } from '@/features/licensing/ui/pages/requests/pharmacy-manager/page';> src\app\(licensing)\requests\pharmacy-manager\page.tsx
echo export default PharmacyManagerRequestsPage;>> src\app\(licensing)\requests\pharmacy-manager\page.tsx

echo import { ProprietorRequestsPage } from '@/features/licensing/ui/pages/requests/proprietor/page';> src\app\(licensing)\requests\proprietor\page.tsx
echo export default ProprietorRequestsPage;>> src\app\(licensing)\requests\proprietor\page.tsx

echo import { SalesmanRequestsPage } from '@/features/licensing/ui/pages/requests/salesman/page';> src\app\(licensing)\requests\salesman\page.tsx
echo export default SalesmanRequestsPage;>> src\app\(licensing)\requests\salesman\page.tsx

REM Clean up old request pages
del src\app\(pages)\pharmacistsRequests\page.tsx
del src\app\(pages)\pharmacyManagerRequests\page.tsx
del src\app\(pages)\proprietorsRequests\page.tsx
del src\app\(pages)\salesmenRequests\page.tsx

REM Create index file for requests routes
echo export * from './pharmacist/route';> src\features\licensing\ui\pages\requests\routes.ts
echo export * from './pharmacy-manager/route';>> src\features\licensing\ui\pages\requests\routes.ts
echo export * from './proprietor/route';>> src\features\licensing\ui\pages\requests\routes.ts
echo export * from './salesman/route';>> src\features\licensing\ui\pages\requests\routes.ts

echo Request pages moved successfully.
</file>

<file path="scripts/reorganize-pages.bat">
@echo off
echo Reorganizing pages according to FSD...

REM Create feature-specific page directories
mkdir src\features\licensing\ui\pages
mkdir src\features\licensing\ui\pages\pharmacist
mkdir src\features\licensing\ui\pages\pharmacy-manager
mkdir src\features\licensing\ui\pages\proprietor
mkdir src\features\licensing\ui\pages\salesman
mkdir src\features\licensing\ui\pages\connections

REM Create dashboard feature directory
mkdir src\features\dashboard
mkdir src\features\dashboard\ui
mkdir src\features\dashboard\ui\pages

REM Move dashboard page
xcopy /Y src\app\(pages)\dashboard\* src\features\dashboard\ui\pages\
rmdir /S /Q src\app\(pages)\dashboard

REM Move licensing-related pages
xcopy /Y src\app\(pages)\pharmacist\* src\features\licensing\ui\pages\pharmacist\
xcopy /Y src\app\(pages)\pharmacistsConnections\* src\features\licensing\ui\pages\connections\pharmacist\
xcopy /Y src\app\(pages)\pharmacistsRequests\* src\features\licensing\ui\pages\connections\pharmacist-requests\

xcopy /Y src\app\(pages)\pharmacy-manager\* src\features\licensing\ui\pages\pharmacy-manager\
xcopy /Y src\app\(pages)\pharmacyManagerConnections\* src\features\licensing\ui\pages\connections\pharmacy-manager\
xcopy /Y src\app\(pages)\pharmacyManagerRequests\* src\features\licensing\ui\pages\connections\pharmacy-manager-requests\

xcopy /Y src\app\(pages)\proprietor\* src\features\licensing\ui\pages\proprietor\
xcopy /Y src\app\(pages)\proprietorConnections\* src\features\licensing\ui\pages\connections\proprietor\
xcopy /Y src\app\(pages)\proprietorsRequests\* src\features\licensing\ui\pages\connections\proprietor-requests\

xcopy /Y src\app\(pages)\salesman\* src\features\licensing\ui\pages\salesman\
xcopy /Y src\app\(pages)\salesmanConnections\* src\features\licensing\ui\pages\connections\salesman\
xcopy /Y src\app\(pages)\salesmenRequests\* src\features\licensing\ui\pages\connections\salesman-requests\

REM Copy layout to shared components
xcopy /Y src\app\(pages)\layout.tsx src\shared\ui\layouts\
del src\app\(pages)\layout.tsx

REM Update app router structure
mkdir src\app\(dashboard)
mkdir src\app\(licensing)

REM Create route files that import from features
echo import { DashboardPage } from '@/features/dashboard/ui/pages';> src\app\(dashboard)\page.tsx
echo export default DashboardPage;>> src\app\(dashboard)\page.tsx

REM Create licensing route files
echo import { PharmacistPage } from '@/features/licensing/ui/pages/pharmacist';> src\app\(licensing)\pharmacist\page.tsx
echo export default PharmacistPage;>> src\app\(licensing)\pharmacist\page.tsx

echo import { PharmacyManagerPage } from '@/features/licensing/ui/pages/pharmacy-manager';> src\app\(licensing)\pharmacy-manager\page.tsx
echo export default PharmacyManagerPage;>> src\app\(licensing)\pharmacy-manager\page.tsx

echo import { ProprietorPage } from '@/features/licensing/ui/pages/proprietor';> src\app\(licensing)\proprietor\page.tsx
echo export default ProprietorPage;>> src\app\(licensing)\proprietor\page.tsx

echo import { SalesmanPage } from '@/features/licensing/ui/pages/salesman';> src\app\(licensing)\salesman\page.tsx
echo export default SalesmanPage;>> src\app\(licensing)\salesman\page.tsx

echo import { PageLayout } from '@/shared/ui/layouts';> src\app\(licensing)\layout.tsx
echo export default PageLayout;>> src\app\(licensing)\layout.tsx

REM Clean up old pages directory
rmdir /S /Q src\app\(pages)

echo Pages reorganization complete.
</file>

<file path="scripts/setup_structure.bat">
@echo off
REM Create main FSD layers
mkdir src\features
mkdir src\entities
mkdir src\shared

REM Create feature-specific directories
mkdir src\features\licensing
mkdir src\features\licensing\ui
mkdir src\features\licensing\model
mkdir src\features\licensing\api

mkdir src\features\exams
mkdir src\features\exams\ui
mkdir src\features\exams\model
mkdir src\features\exams\api

REM Create shared layers
mkdir src\shared\ui
mkdir src\shared\api
mkdir src\shared\config
mkdir src\shared\lib
mkdir src\shared\types

REM Create entities layer structure
mkdir src\entities\user
mkdir src\entities\pharmacy
mkdir src\entities\license

REM Move existing files to new structure
REM UI Components
move src\components\ui\* src\shared\ui\
move src\components\NavigationBar\* src\shared\ui\navigation\
move src\components\NavSideBar\* src\shared\ui\sidebar\

REM API and Services
move src\api\* src\shared\api\
move src\services\* src\shared\api\services\

REM Config and Utils
move src\config\* src\shared\config\
move src\lib\* src\shared\lib\
move src\types\* src\shared\types\
move src\utils\* src\shared\lib\utils\

REM Features specific moves
move src\components\RegistrationForm\* src\features\licensing\ui\forms\
move src\components\Pharmacist\* src\features\licensing\ui\pharmacist\
move src\components\PharmacyManager\* src\features\licensing\ui\pharmacy-manager\
move src\components\Proprietor\* src\features\licensing\ui\proprietor\
move src\components\Salesman\* src\features\licensing\ui\salesman\

echo Directory structure setup complete.
</file>

<file path="scripts/update-and-move-pages.bat">
@echo off
echo Updating and moving pages according to FSD...

REM Create necessary directories
mkdir src\features\licensing\ui\pages\pharmacist
mkdir src\features\licensing\ui\pages\pharmacy-manager
mkdir src\features\licensing\ui\pages\proprietor
mkdir src\features\licensing\ui\pages\salesman
mkdir src\features\dashboard\ui\pages

REM Update and move pharmacist page
echo import { SidebarLayout } from "@/shared/ui/sidebar/SideBarLayout";> src\features\licensing\ui\pages\pharmacist\page.tsx
echo import { PharmacistList } from "@/features/licensing/ui/pharmacist/PharmacistList";>> src\features\licensing\ui\pages\pharmacist\page.tsx
echo.>> src\features\licensing\ui\pages\pharmacist\page.tsx
echo export default function Pharmacist() {>> src\features\licensing\ui\pages\pharmacist\page.tsx
echo   return (>> src\features\licensing\ui\pages\pharmacist\page.tsx
echo     ^<^>^<h1^>Pharmacists Page^</h1^>^<PharmacistList/^>^</^>>> src\features\licensing\ui\pages\pharmacist\page.tsx
echo   );>> src\features\licensing\ui\pages\pharmacist\page.tsx
echo }>> src\features\licensing\ui\pages\pharmacist\page.tsx

REM Create route.ts files for pages
echo Creating route configuration...

echo // Route configuration for pharmacist pages> src\features\licensing\ui\pages\pharmacist\route.ts
echo export const pharmacistRoutes = {>> src\features\licensing\ui\pages\pharmacist\route.ts
echo   base: '/pharmacist',>> src\features\licensing\ui\pages\pharmacist\route.ts
echo   list: '/pharmacist/list',>> src\features\licensing\ui\pages\pharmacist\route.ts
echo   connections: '/pharmacist/connections',>> src\features\licensing\ui\pages\pharmacist\route.ts
echo   requests: '/pharmacist/requests'>> src\features\licensing\ui\pages\pharmacist\route.ts
echo };>> src\features\licensing\ui\pages\pharmacist\route.ts

REM Update app router structure
mkdir src\app\(licensing)
mkdir src\app\(licensing)\pharmacist

REM Create Next.js route file that imports from feature
echo import { Pharmacist } from '@/features/licensing/ui/pages/pharmacist/page';> src\app\(licensing)\pharmacist\page.tsx
echo.>> src\app\(licensing)\pharmacist\page.tsx
echo export default Pharmacist;>> src\app\(licensing)\pharmacist\page.tsx

REM Move layout file
mkdir src\shared\ui\layouts
echo import { SidebarLayout } from "@/shared/ui/sidebar/SideBarLayout";> src\shared\ui\layouts\LicensingLayout.tsx
echo.>> src\shared\ui\layouts\LicensingLayout.tsx
echo export default function LicensingLayout({ children }: { children: React.ReactNode }) {>> src\shared\ui\layouts\LicensingLayout.tsx
echo   return ^<SidebarLayout^>{children}^</SidebarLayout^>;>> src\shared\ui\layouts\LicensingLayout.tsx
echo }>> src\shared\ui\layouts\LicensingLayout.tsx

echo import { LicensingLayout } from "@/shared/ui/layouts/LicensingLayout";> src\app\(licensing)\layout.tsx
echo export default LicensingLayout;>> src\app\(licensing)\layout.tsx

REM Clean up old files
del src\app\(pages)\pharmacist\page.tsx

echo Page updates and moves completed.
</file>

<file path="scripts/verify-structure.bat">
@echo off
echo Verifying final FSD structure...

REM Clean up any remaining old directories
rmdir /S /Q src\app\(pages) 2>nul
rmdir /S /Q src\components 2>nul
rmdir /S /Q src\api 2>nul
rmdir /S /Q src\types 2>nul
rmdir /S /Q src\utils 2>nul
rmdir /S /Q src\src 2>nul

REM Create feature-specific models and types
echo Creating models and types...

REM Licensing feature models
echo export interface PharmacistModel {> src\features\licensing\model\pharmacist.ts
echo   id: string;>> src\features\licensing\model\pharmacist.ts
echo   name: string;>> src\features\licensing\model\pharmacist.ts
echo   license: string;>> src\features\licensing\model\pharmacist.ts
echo }>> src\features\licensing\model\pharmacist.ts

echo export interface ConnectionModel {> src\features\licensing\model\connection.ts
echo   id: string;>> src\features\licensing\model\connection.ts
echo   type: string;>> src\features\licensing\model\connection.ts
echo   status: string;>> src\features\licensing\model\connection.ts
echo }>> src\features\licensing\model\connection.ts

REM Create barrel exports
echo export * from './pharmacist';> src\features\licensing\model\index.ts
echo export * from './connection';>> src\features\licensing\model\index.ts

REM Create feature-specific constants
echo export const LICENSE_TYPES = {> src\features\licensing\lib\constants.ts
echo   PHARMACIST: 'pharmacist',>> src\features\licensing\lib\constants.ts
echo   PHARMACY_MANAGER: 'pharmacy-manager',>> src\features\licensing\lib\constants.ts
echo   PROPRIETOR: 'proprietor',>> src\features\licensing\lib\constants.ts
echo   SALESMAN: 'salesman'>> src\features\licensing\lib\constants.ts
echo };>> src\features\licensing\lib\constants.ts

REM Create feature root index
echo export * from './model';> src\features\licensing\index.ts
echo export * from './ui';>> src\features\licensing\index.ts
echo export * from './api';>> src\features\licensing\index.ts
echo export * from './lib';>> src\features\licensing\index.ts

REM Create UI index
echo export * from './pages';> src\features\licensing\ui\index.ts
echo export * from './pharmacist';>> src\features\licensing\ui\index.ts
echo export * from './pharmacy-manager';>> src\features\licensing\ui\index.ts
echo export * from './proprietor';>> src\features\licensing\ui\index.ts
echo export * from './salesman';>> src\features\licensing\ui\index.ts

REM Create shared layer exports
echo export * from './ui';> src\shared\index.ts
echo export * from './api';>> src\shared\index.ts
echo export * from './config';>> src\shared\index.ts
echo export * from './lib';>> src\shared\index.ts
echo export * from './types';>> src\shared\index.ts

REM Verify directory structure
echo.
echo Verifying directories...
dir src\features
dir src\entities
dir src\shared
dir src\app

echo Structure verification complete.
</file>

<file path="src/app/(auth)/forgot-password/page.tsx">
"use client";

import { ForgotPasswordForm } from '@/features/auth/ui/password-recovery/ForgotPasswordForm';
import { AuthLayout } from '@/features/auth/ui/layout/AuthLayout';

export default function ForgotPasswordPage() {
  return (
    <AuthLayout title="Reset Password">
      <ForgotPasswordForm />
    </AuthLayout>
  );
}
</file>

<file path="src/app/(auth)/index.ts">
import { AuthLoading } from '@/features/auth/ui/feedback';

export { AuthLoading };
</file>

<file path="src/app/(auth)/layout.tsx">
"use client";

import { useRouter } from 'next/navigation';
import { useEffect } from 'react';
import { ROUTES } from '@/features/auth/config/auth';
import { useAuth } from '@/features/auth/hooks';

export default function AuthLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const { user, isLoadingUser } = useAuth();
  const router = useRouter();

  useEffect(() => {
    // Redirect if user is authenticated
    if (user) {
      router.replace(ROUTES.DASHBOARD);
    }
  }, [user, router]);

  // Show loading state while checking auth
  if (isLoadingUser) {
    return (
      <div className="min-h-screen bg-gray-100 flex items-center justify-center">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-gray-900"></div>
      </div>
    );
  }

  // Only render children when not authenticated
  return (
    <div className="min-h-screen bg-gray-100">
      {!user && children}
    </div>
  );
}
</file>

<file path="src/app/(auth)/loading.tsx">
import { AuthLoading } from '@/features/auth/ui/feedback';

export default function AuthGroupLoading() {
  return <AuthLoading message="Loading authentication..." />;
}
</file>

<file path="src/app/(auth)/login/page.tsx">
"use client";

import { LoginForm } from '@/features/auth/ui/login/LoginForm';
import { AuthLayout } from '@/features/auth/ui/layout/AuthLayout';

export default function LoginPage() {
  return (
    <AuthLayout >
      <LoginForm />
    </AuthLayout>
  );
}
</file>

<file path="src/app/(auth)/register/page.tsx">
"use client";

import { useEffect, useState } from 'react';
import { RegisterForm } from '@/features/auth/ui/register/RegisterForm';
import { AuthLayout } from '@/features/auth/ui/layout/AuthLayout';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { AlertCircle } from 'lucide-react';

export default function RegisterPage() {
  const [error, setError] = useState<Error | null>(null);

  // Global error boundary for the register page
  useEffect(() => {
    // Reset error state when component mounts
    setError(null);

    // Add global error handler
    const handleError = (event: ErrorEvent) => {
      console.error('Global error caught:', event.error);
      setError(event.error);
      event.preventDefault();
    };

    window.addEventListener('error', handleError);
    return () => window.removeEventListener('error', handleError);
  }, []);

  if (error) {
    return (
      <AuthLayout title="Registration Error">
        <Card className="border-red-200 shadow-lg">
          <CardHeader>
            <CardTitle className="flex items-center text-red-600">
              <AlertCircle className="mr-2 h-5 w-5" />
              Registration Error
            </CardTitle>
          </CardHeader>
          <CardContent>
            <p className="mb-4">We encountered an error during registration. Please try again later or contact support.</p>
            <button
              onClick={() => setError(null)}
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
            >
              Try Again
            </button>
          </CardContent>
        </Card>
      </AuthLayout>
    );
  }

  return (
    <AuthLayout title="Create Account">
      <RegisterForm />
    </AuthLayout>
  );
}
</file>

<file path="src/app/(auth)/reset-password/[token]/page.tsx">
"use client";

import { ResetPasswordForm } from '@/features/auth/ui/password-recovery/ResetPasswordForm';
import { AuthLayout } from '@/features/auth/ui/layout/AuthLayout';

interface ResetPasswordPageProps {
  params: {
    token: string;
  };
}

export default function ResetPasswordPage({ params }: ResetPasswordPageProps) {
  const { token } = params;
  
  return (
    <AuthLayout title="Set New Password">
      <ResetPasswordForm token={token} />
    </AuthLayout>
  );
}
</file>

<file path="src/app/(auth)/reset-password/page.tsx">
"use client";

import { useState } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import Link from 'next/link';
import { AuthLoading } from '@/features/auth/ui/feedback';
import { validatePassword, calculatePasswordStrength } from '@/utils/password';
import { ROUTES } from '@/features/auth/config/auth';
import { authService } from '@/features/auth/api/services/authService';

export default function ResetPasswordPage() {
  const [newPassword, setNewPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const [passwordStrength, setPasswordStrength] = useState(calculatePasswordStrength(''));

  const router = useRouter();
  const searchParams = useSearchParams();
  const token = searchParams.get('token');

  // If no token is provided, redirect to forgot password page
  if (!token) {
    router.replace(ROUTES.LOGIN);
    return null;
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    // Validate passwords match
    if (newPassword !== confirmPassword) {
      setError('Passwords do not match');
      return;
    }

    // Validate password strength
    const validation = validatePassword(newPassword);
    if (!validation.isValid) {
      setError(validation.errors[0]);
      return;
    }

    try {
      setLoading(true);
      await authService.resetPassword(token, newPassword);
      router.push(`${ROUTES.LOGIN}?message=Password reset successful. Please login with your new password.`);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to reset password');
    } finally {
      setLoading(false);
    }
  };

  const handlePasswordChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setNewPassword(value);
    setPasswordStrength(calculatePasswordStrength(value));
  };

  if (loading) {
    return <AuthLoading message="Resetting your password..." />;
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="max-w-md w-full px-6 py-8 bg-white rounded-lg shadow-md">
        <h1 className="text-2xl font-bold text-center text-gray-900 mb-6">
          Reset your password
        </h1>

        {error && (
          <div className="mb-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-6">
          <div>
            <label 
              htmlFor="newPassword" 
              className="block text-sm font-medium text-gray-700"
            >
              New password
            </label>
            <input
              id="newPassword"
              type="password"
              value={newPassword}
              onChange={handlePasswordChange}
              className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
              required
            />
            {/* Password strength indicator */}
            <div className="mt-2">
              <div className="flex items-center">
                <div className="flex-1 h-2 bg-gray-200 rounded">
                  <div
                    className={`h-full rounded transition-all ${
                      passwordStrength.label === 'very-weak' ? 'w-1/5 bg-red-500' :
                      passwordStrength.label === 'weak' ? 'w-2/5 bg-orange-500' :
                      passwordStrength.label === 'medium' ? 'w-3/5 bg-yellow-500' :
                      passwordStrength.label === 'strong' ? 'w-4/5 bg-green-500' :
                      'w-full bg-green-600'
                    }`}
                  />
                </div>
                <span className="ml-2 text-sm text-gray-500">
                  {passwordStrength.label.replace('-', ' ')}
                </span>
              </div>
              {passwordStrength.suggestions.length > 0 && (
                <p className="mt-1 text-sm text-gray-500">
                  {passwordStrength.suggestions[0]}
                </p>
              )}
            </div>
          </div>

          <div>
            <label 
              htmlFor="confirmPassword" 
              className="block text-sm font-medium text-gray-700"
            >
              Confirm new password
            </label>
            <input
              id="confirmPassword"
              type="password"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
              required
            />
          </div>

          <button
            type="submit"
            disabled={loading}
            className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
          >
            Reset password
          </button>
        </form>

        <div className="mt-4 text-center">
          <Link
            href={ROUTES.LOGIN}
            className="text-sm text-blue-600 hover:text-blue-500"
          >
            Back to login
          </Link>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/(auth)/verify-email/[token]/loading.tsx">
"use client";

import { AuthLayout } from '@/features/auth/ui/layout/AuthLayout';

export default function Loading() {
  return (
    <AuthLayout title="Verify Email">
      <div className="flex justify-center items-center min-h-[200px]">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900"></div>
      </div>
    </AuthLayout>
  );
}
</file>

<file path="src/app/(auth)/verify-email/[token]/page.tsx">
"use client";

import { EmailVerificationView } from '@/features/auth/ui';
import { AuthLayout } from '@/features/auth/ui/layout/AuthLayout';

interface VerifyEmailPageProps {
  params: {
    token: string;
  };
}

export default function VerifyEmailPage({ params }: VerifyEmailPageProps) {
  const { token } = params;
  
  return (
    <AuthLayout title="Verify Email">
      <EmailVerificationView token={token} />
    </AuthLayout>
  );
}
</file>

<file path="src/app/(dashboard)/dashboard/page.tsx">
"use client";

import { usePermissions, useAccess } from "@/features/rbac/hooks";
import { useSession } from "@/features/auth/hooks";
import { Button } from "@/components/ui/button";

function DashboardMetrics() {
  // Using useAccess for feature-specific checks
  const canViewMetrics = useAccess({
    permissions: ['view_reports'],
  });

  if (!canViewMetrics) return null;

  return (
    <div className="grid grid-cols-3 gap-4">
      <div className="bg-white p-4 rounded-lg shadow">
        <h3 className="font-semibold text-gray-700">Total Orders</h3>
        <p className="text-2xl font-bold">1,234</p>
      </div>
      <div className="bg-white p-4 rounded-lg shadow">
        <h3 className="font-semibold text-gray-700">Revenue</h3>
        <p className="text-2xl font-bold">$45,678</p>
      </div>
      <div className="bg-white p-4 rounded-lg shadow">
        <h3 className="font-semibold text-gray-700">Active Users</h3>
        <p className="text-2xl font-bold">567</p>
      </div>
    </div>
  );
}

function InventorySection() {
  const { hasPermission } = usePermissions();
  
  return (
    <div className="bg-white p-6 rounded-lg shadow mt-6">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-xl font-semibold">Inventory Overview</h2>
        {hasPermission('manage_inventory') && (
          <Button variant="outline">Manage Inventory</Button>
        )}
      </div>
      <div className="space-y-4">
        <div className="flex justify-between border-b pb-2">
          <span>Low Stock Items</span>
          <span className="font-semibold">12</span>
        </div>
        <div className="flex justify-between border-b pb-2">
          <span>Out of Stock Items</span>
          <span className="font-semibold">3</span>
        </div>
        <div className="flex justify-between">
          <span>Total Products</span>
          <span className="font-semibold">456</span>
        </div>
      </div>
    </div>
  );
}

function AdminSection() {
  const { isAdmin } = usePermissions();

  if (!isAdmin) return null;

  return (
    <div className="bg-white p-6 rounded-lg shadow mt-6">
      <h2 className="text-xl font-semibold mb-4">Admin Controls</h2>
      <div className="grid grid-cols-2 gap-4">
        <Button variant="outline">Manage Users</Button>
        <Button variant="outline">System Settings</Button>
        <Button variant="outline">Access Logs</Button>
        <Button variant="outline">Backup Database</Button>
      </div>
    </div>
  );
}

export default function DashboardPage() {
  const { session } = useSession({ required: true });
  const { isManager } = usePermissions();

  return (
    <div className="max-w-7xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
      <div className="mb-8">
        <h1 className="text-2xl font-bold">Welcome, {session?.user?.name}</h1>
        <p className="text-gray-600 mt-1">
          {isManager ? 'Manager Dashboard' : 'Dashboard'}
        </p>
      </div>

      {/* Metrics Section */}
      <DashboardMetrics />

      {/* Main Content */}
      <div className="grid md:grid-cols-2 gap-6 mt-6">
        <InventorySection />
        <AdminSection />
      </div>
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/layout.tsx">
"use client";

import { useSession } from "@/features/auth/hooks";
import Link from "next/link";
import { Bell } from "lucide-react";
import { UserMenu } from "@/components/dashboard/UserMenu";
import { Breadcrumbs } from "@/components/dashboard/Breadcrumbs";
import { Sidebar } from "@/components/dashboard/Sidebar";
import ModernMinimalistLogo from "@/shared/ui/logo/ModernMinimalistLogo";
import { Button } from "@/components/ui/button";
import { usePermissions } from "@/features/rbac/hooks";
import { useIsMobile } from "@/features/ui/hooks";

function Notifications() {
  const { hasPermission } = usePermissions();
  
  if (!hasPermission("view_reports")) return null;

  return (
    <Button variant="ghost" size="default" className="relative">
      <Bell className="h-5 w-5" />
      <span className="absolute top-1 right-1 h-2 w-2 bg-red-500 rounded-full" />
    </Button>
  );
}

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const { isAuthenticated } = useSession({ required: true });
  const isMobile = useIsMobile();

  if (!isAuthenticated) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-gray-900"></div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-white shadow-sm sticky top-0 z-50">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center h-16">
            <div className="flex items-center space-x-4">
              {isMobile && <Sidebar />}
              <Link href="/dashboard" className="font-bold text-xl text-blue-600">
                <ModernMinimalistLogo />
              </Link>
            </div>
            <div className="flex items-center space-x-4">
              <Notifications />
              <UserMenu />
            </div>
          </div>
        </div>
      </header>

      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="flex flex-col md:flex-row gap-8">
          {/* Hide sidebar on mobile - it's shown in the Sheet component */}
          <div className="hidden md:block">
            <Sidebar />
          </div>

          <main className="flex-1 min-w-0">
            <Breadcrumbs />
            <div className="bg-white rounded-lg shadow-sm p-4 md:p-6">
              {children}
            </div>
          </main>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/settings/page.tsx">
"use client";

import { AdminGuard } from "@/features/rbac/ui";
import { FeatureGuard } from "@/features/rbac";
import { useAuth } from "@/features/auth/hooks";

// Basic settings component that's protected by admin role
function BasicSettings() {
  const { user } = useAuth();
  
  return (
    <div className="p-6 bg-white rounded-lg shadow">
      <h2 className="text-xl font-semibold mb-4">General Settings</h2>
      <div className="space-y-4">
        <div className="mb-4 p-4 bg-gray-50 rounded-md">
          <p className="text-sm text-gray-600">Logged in as: {user?.email}</p>
          <p className="text-sm text-gray-600">Role: {user?.roles.join(', ')}</p>
        </div>
        <div>
          <label className="block text-sm font-medium text-gray-700">Pharmacy Name</label>
          <input
            type="text"
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-gray-700">Contact Email</label>
          <input
            type="email"
            defaultValue={user?.email}
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
          />
        </div>
      </div>
    </div>
  );
}

// Advanced settings component that requires system management permission
function AdvancedSettings() {
  const { user } = useAuth();
  
  return (
    <div className="p-6 bg-white rounded-lg shadow">
      <h2 className="text-xl font-semibold mb-4">Advanced Settings</h2>
      <div className="space-y-4">
        <div className="mb-4 p-4 bg-gray-50 rounded-md">
          <p className="text-sm text-gray-600">Permissions: {user?.permissions.join(', ')}</p>
        </div>
        <div>
          <label className="block text-sm font-medium text-gray-700">API Configuration</label>
          <input
            type="text"
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-gray-700">System Backup</label>
          <select className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            <option>Daily</option>
            <option>Weekly</option>
            <option>Monthly</option>
          </select>
        </div>
      </div>
    </div>
  );
}

export default function SettingsPage() {
  return (
    <div className="max-w-6xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
      <div className="mb-8">
        <h1 className="text-2xl font-bold text-gray-900">Settings</h1>
        <p className="mt-2 text-sm text-gray-600">
          Manage your pharmacy system settings
        </p>
      </div>

      <div className="grid gap-8 md:grid-cols-2">
        {/* Basic settings - requires admin role */}
        <AdminGuard>
          <BasicSettings />
        </AdminGuard>

        {/* Advanced settings - requires manage_system permission */}
        <FeatureGuard permissions={['manage_system']}>
          <AdvancedSettings />
        </FeatureGuard>
      </div>
    </div>
  );
}
</file>

<file path="src/app/(exams)/exam/[id]/page.tsx">
'use client';

import React from 'react';
import { useRouter } from 'next/navigation';
import { Container } from '@/components/layout/container';
import { ExamContainer } from '@/features/exams/ui/ExamContainer';
import { Button } from '@/components/ui/button';
import { QueryProvider } from '@/features/tanstack-query-api/components/QueryProvider';

interface ExamPageProps {
  params: Promise<{
    id: string;
  }>;
}

export default function ExamPage({ params }: ExamPageProps) {
  const router = useRouter();
  const { id } = React.use(params);
  const examId = parseInt(id, 10);
  
  // In a real application, you would get the user ID from authentication context
  const userId = "current-user-id"; // This should come from auth context
  
  const handleExit = () => {
    router.push('/exams');
  };
  
  if (isNaN(examId)) {
    return (
      <Container>
        <div className="my-8 text-center">
          <h1 className="text-2xl font-bold mb-4">Invalid Exam ID</h1>
          <p className="text-gray-600 mb-4">The exam ID provided is not valid.</p>
          <Button 
            onClick={() => router.push('/exams')}
          >
            Return to Exams
          </Button>
        </div>
      </Container>
    );
  }
  
  return (
    <QueryProvider>
      <Container>
        <div className="my-8">
          <ExamContainer
            examId={examId}
            userId={userId}
            onExit={handleExit}
          />
        </div>
      </Container>
    </QueryProvider>
  );
}
</file>

<file path="src/app/(exams)/exam/mock/mockData.ts">
export interface ExamPaper {
  id: string;
  title: string;
  description: string;
  difficulty: 'easy' | 'medium' | 'hard';
  totalQuestions: number;
  duration: number; // in minutes
  topics: string[];
  isPremium: boolean;
  attempts: number;
  successRate: number;
  lastUpdated: string;
}

export const mockModelPapers: ExamPaper[] = [
  {
    id: 'mp-001',
    title: 'Pharmacology Basics 2024',
    description: 'Comprehensive review of basic pharmacology principles',
    difficulty: 'easy',
    totalQuestions: 50,
    duration: 60,
    topics: ['Basic Pharmacology', 'Drug Classification', 'Mechanisms of Action'],
    isPremium: false,
    attempts: 1250,
    successRate: 78,
    lastUpdated: '2024-02-15'
  },
  {
    id: 'mp-002',
    title: 'Clinical Pharmacy Practice',
    description: 'Advanced clinical pharmacy scenarios and case studies',
    difficulty: 'hard',
    totalQuestions: 75,
    duration: 90,
    topics: ['Patient Care', 'Clinical Decision Making', 'Therapeutic Management'],
    isPremium: true,
    attempts: 850,
    successRate: 65,
    lastUpdated: '2024-02-18'
  },
  {
    id: 'mp-003',
    title: 'Pharmaceutical Calculations',
    description: 'Essential calculations for pharmacy practice',
    difficulty: 'medium',
    totalQuestions: 40,
    duration: 60,
    topics: ['Dosage Calculations', 'Concentration Calculations', 'Compounding'],
    isPremium: false,
    attempts: 2000,
    successRate: 72,
    lastUpdated: '2024-02-10'
  },
  {
    id: 'mp-004',
    title: 'Pharmacy Law & Ethics',
    description: 'Latest updates on pharmacy regulations and ethical practices',
    difficulty: 'medium',
    totalQuestions: 60,
    duration: 75,
    topics: ['Pharmacy Laws', 'Professional Ethics', 'Regulatory Compliance'],
    isPremium: true,
    attempts: 1500,
    successRate: 70,
    lastUpdated: '2024-02-20'
  }
];

export const mockPastPapers: ExamPaper[] = [
  {
    id: 'pp-001',
    title: '2023 Board Exam Paper 1',
    description: 'Official board examination from 2023',
    difficulty: 'hard',
    totalQuestions: 100,
    duration: 180,
    topics: ['Comprehensive', 'Clinical Practice', 'Pharmacy Management'],
    isPremium: true,
    attempts: 3000,
    successRate: 68,
    lastUpdated: '2023-12-01'
  },
  {
    id: 'pp-002',
    title: '2023 Board Exam Paper 2',
    description: 'Second paper from 2023 board examination',
    difficulty: 'hard',
    totalQuestions: 100,
    duration: 180,
    topics: ['Drug Therapy', 'Patient Care', 'Pharmacy Operations'],
    isPremium: true,
    attempts: 2800,
    successRate: 65,
    lastUpdated: '2023-12-01'
  }
];

export interface ExamStats {
  totalPapers: number;
  avgDuration: number;
  completionRate: number;
  activeUsers: number;
}

export const mockStats: ExamStats = {
  totalPapers: mockModelPapers.length + mockPastPapers.length,
  avgDuration: 180,
  completionRate: 75,
  activeUsers: 2500
};
</file>

<file path="src/app/(exams)/exam/page.tsx">
'use client';

import React from 'react';
import { McqExamList } from '@/features/exams/ui/mcq';

export default function ExamPage() {
  return <McqExamList />;
}
</file>

<file path="src/app/(exams)/exam/results/page.tsx">
'use client';

import React from 'react';
import { McqExamResults } from '@/features/exams/ui/mcq';

export default function ExamResultsPage() {
  return <McqExamResults />;
}
</file>

<file path="src/app/(exams)/exam/review/[id]/page.tsx">
import React from 'react';
import { ReviewMode } from '@/features/exams/ui/review/ReviewMode';
import { examService } from '@/features/exams/api/core/examService';
import { useExamStore } from '@/features/exams/store/examStore';
import { Metadata } from 'next';
import { notFound } from 'next/navigation';

interface ReviewPageProps {
    params: Promise<{
        id: string;
    }>;
}

export async function generateMetadata({ params }: ReviewPageProps): Promise<Metadata> {
    const { id } = await params;
    const paper = await examService.getExamById(parseInt(id));
    
    return {
        title: `Review ${paper.title} | PharmacyHub`,
        description: `Review your answers and explanations for ${paper.title}`,
    };
}

export default async function ReviewPage({ params }: ReviewPageProps) {
    // Get the paper and exam state
    const { id } = await params;
    const paper = await examService.getExamById(parseInt(id)).catch(() => null);
    const examState = useExamStore.getState();

    // If paper doesn't exist or exam state is empty, show 404
    if (!paper || !examState.answers) {
        notFound();
    }

    return (
        <div className="min-h-screen bg-gray-50">
            <ReviewMode paper={paper} answers={examState.answers} />
        </div>
    );
}
</file>

<file path="src/app/(exams)/layout.tsx">
export { default } from "../(dashboard)/layout";
</file>

<file path="src/app/exam/dashboard/page.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { FileText, Medal, BookOpen } from "lucide-react";
import Link from "next/link";
import { Progress } from "@/components/ui/progress";
import { ExamsSidebar } from "@/components/dashboard/ExamsSidebar";

interface PaperCategory {
  name: string;
  href: string;
  icon: React.ComponentType<{className?: string}>;
  totalPapers: number;
  completedPapers: number;
}

const paperCategories: PaperCategory[] = [
  {
    name: 'Past Papers',
    href: '/exam/past-papers',
    icon: FileText,
    totalPapers: 50,
    completedPapers: 15
  },
  {
    name: 'Model Papers',
    href: '/exam/model-papers',
    icon: Medal,
    totalPapers: 30,
    completedPapers: 10
  },
  {
    name: 'Subject Papers',
    href: '/exam/subject-papers',
    icon: BookOpen,
    totalPapers: 40,
    completedPapers: 20
  }
];

export default function ExamDashboardPage() {
  const calculateOverallProgress = () => {
    const totalPapers = paperCategories.reduce((sum, category) => sum + category.totalPapers, 0);
    const completedPapers = paperCategories.reduce((sum, category) => sum + category.completedPapers, 0);
    return (completedPapers / totalPapers) * 100;
  };

  return (
    <div className="flex">
      <ExamsSidebar />
      <main className="flex-1 p-6">
        <h1 className="text-3xl font-bold text-gray-800 mb-6">
          Exams Preparation Dashboard
        </h1>

        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          {paperCategories.map((category) => (
            <Link 
              key={category.name} 
              href={category.href} 
              className="hover:scale-[1.02] transition-transform"
            >
              <Card className="hover:shadow-lg transition-shadow">
                <CardHeader className="flex flex-row items-center space-x-4 pb-2">
                  <category.icon className="h-8 w-8 text-blue-600" />
                  <CardTitle>{category.name}</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="flex justify-between items-center mb-2">
                    <span className="text-sm text-gray-600">
                      Progress
                    </span>
                    <span className="text-sm font-semibold">
                      {category.completedPapers} / {category.totalPapers}
                    </span>
                  </div>
                  <Progress 
                    value={(category.completedPapers / category.totalPapers) * 100} 
                    className="h-2"
                  />
                </CardContent>
              </Card>
            </Link>
          ))}
        </div>

        <Card className="mt-6">
          <CardHeader>
            <CardTitle>Overall Progress</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="flex items-center space-x-4">
              <Progress 
                value={calculateOverallProgress()} 
                className="h-4 flex-grow" 
              />
              <span className="text-sm font-semibold">
                {calculateOverallProgress().toFixed(1)}%
              </span>
            </div>
          </CardContent>
        </Card>
      </main>
    </div>
  );
}
</file>

<file path="src/app/exam/model-papers/page.tsx">
import { ExamsSidebar } from "@/components/dashboard/ExamsSidebar";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Medal } from "lucide-react";

export default function ModelPapersPage() {
  const modelPapers = [
    { id: 1, subject: 'Chemistry', difficulty: 'Advanced', status: 'Completed' },
    { id: 2, subject: 'Physics', difficulty: 'Intermediate', status: 'In Progress' },
    { id: 3, subject: 'Biology', difficulty: 'Basic', status: 'Not Started' },
    { id: 4, subject: 'Mathematics', difficulty: 'Advanced', status: 'Completed' },
  ];

  return (
    <div className="flex">
      <ExamsSidebar />
      <main className="flex-1 p-6">
        <h1 className="text-3xl font-bold text-gray-800 mb-6">
          Model Papers
        </h1>

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {modelPapers.map((paper) => (
            <Card key={paper.id} className="hover:shadow-lg transition-shadow">
              <CardHeader className="flex flex-row items-center space-x-4 pb-2">
                <Medal className="h-8 w-8 text-blue-600" />
                <CardTitle>{paper.subject}</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="flex justify-between items-center mb-2">
                  <span className="text-sm text-gray-600">Difficulty:</span>
                  <span className={`text-sm font-semibold ${
                    paper.difficulty === 'Advanced' 
                      ? 'text-red-600' 
                      : paper.difficulty === 'Intermediate' 
                      ? 'text-yellow-600' 
                      : 'text-green-600'
                  }`}>
                    {paper.difficulty}
                  </span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="text-sm text-gray-600">Status:</span>
                  <span 
                    className={`text-sm font-semibold ${
                      paper.status === 'Completed' 
                        ? 'text-green-600' 
                        : paper.status === 'In Progress' 
                        ? 'text-yellow-600' 
                        : 'text-gray-500'
                    }`}
                  >
                    {paper.status}
                  </span>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      </main>
    </div>
  );
}
</file>

<file path="src/app/exam/past-papers/page.tsx">
import { ExamsSidebar } from "@/components/dashboard/ExamsSidebar";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { FileText } from "lucide-react";

export default function PastPapersPage() {
  const pastPapers = [
    { id: 1, subject: 'Chemistry', year: 2023, status: 'Completed' },
    { id: 2, subject: 'Physics', year: 2022, status: 'In Progress' },
    { id: 3, subject: 'Biology', year: 2023, status: 'Not Started' },
    { id: 4, subject: 'Mathematics', year: 2022, status: 'Completed' },
  ];

  return (
    <div className="flex">
      <ExamsSidebar />
      <main className="flex-1 p-6">
        <h1 className="text-3xl font-bold text-gray-800 mb-6">
          Past Papers
        </h1>

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {pastPapers.map((paper) => (
            <Card key={paper.id} className="hover:shadow-lg transition-shadow">
              <CardHeader className="flex flex-row items-center space-x-4 pb-2">
                <FileText className="h-8 w-8 text-blue-600" />
                <CardTitle>{paper.subject} - {paper.year}</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="flex justify-between items-center">
                  <span className="text-sm text-gray-600">Status:</span>
                  <span 
                    className={`text-sm font-semibold ${
                      paper.status === 'Completed' 
                        ? 'text-green-600' 
                        : paper.status === 'In Progress' 
                        ? 'text-yellow-600' 
                        : 'text-gray-500'
                    }`}
                  >
                    {paper.status}
                  </span>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      </main>
    </div>
  );
}
</file>

<file path="src/app/exam/subject-papers/page.tsx">
import { ExamsSidebar } from "@/components/dashboard/ExamsSidebar";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { BookOpen } from "lucide-react";

export default function SubjectPapersPage() {
  const subjectPapers = [
    { id: 1, subject: 'Pharmacology', topic: 'Drug Metabolism', status: 'Completed' },
    { id: 2, subject: 'Anatomy', topic: 'Human Physiology', status: 'In Progress' },
    { id: 3, subject: 'Microbiology', topic: 'Bacterial Pathogenesis', status: 'Not Started' },
    { id: 4, subject: 'Biochemistry', topic: 'Enzymology', status: 'Completed' },
  ];

  return (
    <div className="flex">
      <ExamsSidebar />
      <main className="flex-1 p-6">
        <h1 className="text-3xl font-bold text-gray-800 mb-6">
          Subject Papers
        </h1>

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {subjectPapers.map((paper) => (
            <Card key={paper.id} className="hover:shadow-lg transition-shadow">
              <CardHeader className="flex flex-row items-center space-x-4 pb-2">
                <BookOpen className="h-8 w-8 text-blue-600" />
                <CardTitle>{paper.subject}</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="flex justify-between items-center mb-2">
                  <span className="text-sm text-gray-600">Topic:</span>
                  <span className="text-sm font-semibold text-gray-800">
                    {paper.topic}
                  </span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="text-sm text-gray-600">Status:</span>
                  <span 
                    className={`text-sm font-semibold ${
                      paper.status === 'Completed' 
                        ? 'text-green-600' 
                        : paper.status === 'In Progress' 
                        ? 'text-yellow-600' 
                        : 'text-gray-500'
                    }`}
                  >
                    {paper.status}
                  </span>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      </main>
    </div>
  );
}
</file>

<file path="src/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@keyframes float {
  0%, 100% {
    transform: translateY(0px);
  }
  50% {
    transform: translateY(-10px);
  }
}

.animate-float {
  animation: float 3s ease-in-out infinite;
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 240 5.3% 26.1%;
    --sidebar-primary: 240 5.9% 10%;
    --sidebar-primary-foreground: 0 0% 98%;
    --sidebar-accent: 240 4.8% 95.9%;
    --sidebar-accent-foreground: 240 5.9% 10%;
    --sidebar-border: 220 13% 91%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }

  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 224.3 76.3% 48%;
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
}


@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="src/app/layout.tsx">
import { Inter } from "next/font/google";
import "./globals.css";
import AuthProvider from "@/app/providers/AuthProvider";
import QueryProvider from "@/app/providers/QueryProvider";
import ToastProvider from "@/app/providers/ToastProvider";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "PharmacyHub",
  description: "Your complete pharmacy management solution",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <QueryProvider>
          <AuthProvider>
            <ToastProvider>
              {children}
            </ToastProvider>
          </AuthProvider>
        </QueryProvider>
      </body>
    </html>
  );
}
</file>

<file path="src/app/page.module.css">
.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition: background 0.2s,
  color 0.2s,
  border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 180px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
}
</file>

<file path="src/app/page.tsx">
'use client';

import React, { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { motion } from 'framer-motion';
import { FeatureCardSection } from "@/features/home/ui/FeatureCardSection";
import { Footer } from "@/features/home/ui/Footer";
import { useAuth } from '@/shared/auth';
import { ArrowRight, ChevronRight } from 'lucide-react';
import { Button } from "@/components/ui/button";
import ModernMinimalistLogo from "@/shared/ui/logo/ModernMinimalistLogo";

interface Router {
  replace: (path: string) => void;
}

export default function Home() {
  const router = useRouter();
  const { isAuthenticated } = useAuth();

  useEffect(() => {
    if (isAuthenticated) {
      router.replace('/dashboard');
    }
  }, [isAuthenticated, router]);

  const handleNavigation = (route: string) => {
    (router as Router).replace(route);
  };

  return (
    <main className="min-h-screen">
      <header className="fixed top-0 left-0 right-0 z-50 bg-white/90 backdrop-blur-md border-b border-gray-200 shadow-sm">
        <div className="container mx-auto px-4">
          <div className="flex h-14 md:h-16 items-center justify-between">
            <div className="flex items-center">
              <motion.div
                initial={{ scale: 0.8, opacity: 0 }}
                animate={{ scale: 1, opacity: 1 }}
                transition={{ duration: 0.3 }}
              >
                <ModernMinimalistLogo />
              </motion.div>
            </div>

            <motion.div
              initial={{ x: 20, opacity: 0 }}
              animate={{ x: 0, opacity: 1 }}
              transition={{ delay: 0.3, duration: 0.3 }}
            >
              <Button
                variant="outline"
                className="text-sm md:text-base bg-gradient-to-r from-blue-600 to-indigo-600 text-white border-0 hover:opacity-90 transition-all duration-300 py-1.5 md:py-2 px-3 md:px-4"
                onClick={() => handleNavigation('/login')}
              >
                Join Us
                <ArrowRight className="w-4 h-4 ml-2" />
              </Button
>
            </motion.div>
          </div>
        </div>
      </header>

      {/* Hero Section */}
      <section className="pt-24 pb-12 md:pb-16 relative overflow-hidden">
        <div className="absolute inset-0 bg-gradient-to-br from-blue-50 to-indigo-50 opacity-50" />
        <div className="absolute inset-0 bg-[url('/Images/med.jpg')] opacity-5" />
        <div className="container mx-auto px-4 relative">
          <motion.div
            initial={{ y: 20, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{ duration: 0.5 }}
            className="max-w-3xl mx-auto text-center space-y-4 md:space-y-6 py-8 md:py-16"
          >
            <h1 className="text-4xl md:text-5xl lg:text-6xl font-bold">
              <span className="bg-gradient-to-r from-blue-600 to-indigo-600 bg-clip-text text-transparent">
                Welcome to PharmacyHub
              </span>
            </h1>
            <p className="text-lg md:text-xl text-gray-600 max-w-2xl mx-auto px-4 md:px-0">
              Connect with pharmacies, manage licenses, and prepare for exams all in one place.
              Join our growing network of pharmacy professionals.
            </p>
            <div className="flex flex-col sm:flex-row gap-4 justify-center mt-8">
              <Button
                size="lg"
                className="text-sm md:text-base bg-gradient-to-r from-blue-600 to-indigo-600 text-white hover:opacity-90 transition-all duration-300 py-1.5 md:py-2"
                onClick={() => handleNavigation('/register')}
              >
                Get Started
                <ChevronRight className="w-5 h-5 ml-2" />
              </Button>
              <Button
                size="lg"
                variant="outline"
                className="text-sm md:text-base border-blue-600 text-blue-600 hover:bg-blue-50 py-1.5 md:py-2"
              >
                Learn More
              </Button>
            </div>
          </motion.div>
        </div>
      </section>

      <FeatureCardSection />
      <Footer />
    </main>
  );
}
</file>

<file path="src/app/providers/AuthProvider.tsx">
"use client";

import { AuthProvider as KeycloakAuthProvider } from "@/shared/auth";
import { ReactNode } from "react";

interface AuthProviderProps {
  children: ReactNode;
}

/**
 * Global authentication provider that uses Keycloak
 * 
 * This component wraps the application with our custom Keycloak
 * authentication provider, making all auth functionality 
 * available throughout the app.
 */
export default function AuthProvider({ children }: AuthProviderProps) {
  return (
    <KeycloakAuthProvider>
      {children}
    </KeycloakAuthProvider>
  );
}
</file>

<file path="src/app/providers/QueryProvider.tsx">
"use client";

import { QueryClientProvider } from '@tanstack/react-query';
import { queryClient } from '@/features/tanstack-query-api/core/queryClient';

export default function QueryProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
}
</file>

<file path="src/app/providers/ToastProvider.tsx">
"use client"

import { Toaster } from "@/components/ui/toaster"
import { ToastProvider as ToastContextProvider } from "@/components/ui/toast-context"
import { ReactNode } from "react"

interface ToastProviderProps {
  children: ReactNode
}

export default function ToastProvider({ children }: ToastProviderProps) {
  return (
    <ToastContextProvider>
      {children}
      <Toaster />
    </ToastContextProvider>
  )
}
</file>

<file path="src/app/unauthorized/page.tsx">
'use client';

import React from 'react';
import Link from 'next/link';
import { useAuth } from '@/features/auth/hooks';

export default function Unauthorized() {
  const { user, logout } = useAuth();

  return (
    <div className="flex min-h-screen flex-col items-center justify-center bg-gray-100 p-6 text-center">
      <div className="w-full max-w-md rounded-lg bg-white p-8 shadow-lg">
        <div className="mb-6 flex justify-center">
          <div className="rounded-full bg-red-100 p-3">
            <svg 
              xmlns="http://www.w3.org/2000/svg" 
              className="h-12 w-12 text-red-500" 
              fill="none" 
              viewBox="0 0 24 24" 
              stroke="currentColor"
            >
              <path 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                strokeWidth={2} 
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" 
              />
            </svg>
          </div>
        </div>
        
        <h1 className="mb-2 text-2xl font-bold text-gray-800">Access Denied</h1>
        
        <p className="mb-6 text-gray-600">
          You don't have permission to access this page. This area is restricted.
        </p>
        
        {user && (
          <div className="mb-6 rounded-md bg-gray-100 p-4 text-sm text-gray-700">
            <p>Logged in as: <span className="font-semibold">{user.email}</span></p>
            <p>Role: <span className="font-semibold">{user.roles.join(', ') || 'Unknown'}</span></p>
          </div>
        )}
        
        <div className="mt-6 flex flex-col space-y-3 sm:flex-row sm:space-x-3 sm:space-y-0">
          <Link
            href="/dashboard"
            className="rounded-md bg-blue-500 px-4 py-2 text-sm font-medium text-white hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
          >
            Back to Dashboard
          </Link>
          
          <button
            onClick={logout}
            className="rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
          >
            Logout
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/auth/index.ts">
/**
 * Re-export auth components from the features directory
 * This file serves as a compatibility layer for older code
 */

export {
  AuthLoading,
  InitialAuthCheck,
  PermissionCheck as AuthPermissionCheck,
  TokenRefresh,
  ProfileLoading
} from '@/features/auth/ui/feedback';

export {
  AuthLayout
} from '@/features/auth/ui/layout';

export {
  LoginForm
} from '@/features/auth/ui/login';

export {
  ForgotPasswordForm,
  ResetPasswordForm
} from '@/features/auth/ui/password-recovery';

export {
  RegisterForm
} from '@/features/auth/ui/register';

export {
  AuthGuard,
  RequireAuth
} from '@/features/auth/ui/protection';
</file>

<file path="src/components/auth/PermissionGuard.tsx">
"use client";

import { useEffect, type ReactNode } from "react";
import { useRouter } from "next/navigation";
import { isAuthorized, type AuthConfig } from "@/utils/auth-utils";
import { LoadingSpinner, LoadingOverlay } from "@/components/ui/loading-spinner";
import { useAuth } from "@/features/auth/hooks";

interface PermissionGuardProps extends AuthConfig {
  children: ReactNode;
  fallback?: ReactNode;
  loader?: ReactNode;
  redirectTo?: string;
  showLoading?: boolean;
  loadingMessage?: string;
  loadingType?: "overlay" | "inline";
}

export function PermissionGuard({
  children,
  roles = [],
  permissions = [],
  requireAllRoles = false,
  requireAllPermissions = false,
  fallback,
  loader,
  redirectTo,
  showLoading = true,
  loadingMessage = "Checking permissions...",
  loadingType = "inline"
}: PermissionGuardProps) {
  const { user, isLoadingUser } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!isLoadingUser && !user) {
      router.push(redirectTo || "/login");
    }
  }, [isLoadingUser, user, router, redirectTo]);

  // Show loader while checking authentication
  if (isLoadingUser && showLoading) {
    if (loader) {
      return <>{loader}</>;
    }

    return loadingType === "overlay" ? (
      <LoadingOverlay message={loadingMessage} />
    ) : (
      <div className="flex flex-col items-center justify-center min-h-[200px]">
        <LoadingSpinner size="lg" />
        {loadingMessage && (
          <p className="mt-4 text-gray-600">{loadingMessage}</p>
        )}
      </div>
    );
  }

  // Not authenticated
  if (!user) {
    return null;
  }

  // Check authorization
  const hasAccess = isAuthorized(
    user.roles,
    user.permissions,
    { roles, permissions, requireAllRoles, requireAllPermissions }
  );

  if (!hasAccess) {
    if (fallback) {
      return <>{fallback}</>;
    }

    if (redirectTo) {
      router.push(redirectTo);
      return showLoading ? (
        <LoadingSpinner size="lg" className="mx-auto" />
      ) : null;
    }

    return null;
  }

  return <>{children}</>;
}

// Higher-order component wrapper
export function withPermissionGuard<P extends object>(
  WrappedComponent: React.ComponentType<P>,
  config: AuthConfig & {
    fallback?: ReactNode;
    loader?: ReactNode;
    redirectTo?: string;
    showLoading?: boolean;
    loadingMessage?: string;
    loadingType?: "overlay" | "inline";
  }
) {
  return function PermissionGuardWrapper(props: P) {
    return (
      <PermissionGuard {...config}>
        <WrappedComponent {...props} />
      </PermissionGuard>
    );
  };
}

// Conditional rendering components
export function IfHasPermission({
  children,
  permission,
  fallback,
  loadingElement
}: {
  children: ReactNode;
  permission: string;
  fallback?: ReactNode;
  loadingElement?: ReactNode;
}) {
  const { user, isLoadingUser } = useAuth();
  
  if (isLoadingUser) {
    return loadingElement || <LoadingSpinner size="sm" className="mx-auto" />;
  }

  if (!user?.permissions.includes(permission)) {
    return fallback || null;
  }

  return <>{children}</>;
}

export function IfHasRole({
  children,
  role,
  fallback,
  loadingElement
}: {
  children: ReactNode;
  role: string;
  fallback?: ReactNode;
  loadingElement?: ReactNode;
}) {
  const { user, isLoadingUser } = useAuth();
  
  if (isLoadingUser) {
    return loadingElement || <LoadingSpinner size="sm" className="mx-auto" />;
  }

  if (!user?.roles.includes(role)) {
    return fallback || null;
  }

  return <>{children}</>;
}

// Example usage:
/*
// As a wrapper component
<PermissionGuard
  roles={["ADMIN"]}
  permissions={["manage:users"]}
  requireAllPermissions
  fallback={<AccessDenied />}
  redirectTo="/unauthorized"
  loadingType="overlay"
  loadingMessage="Checking admin access..."
>
  <AdminDashboard />
</PermissionGuard>

// As a HOC
const ProtectedComponent = withPermissionGuard(MyComponent, {
  roles: ["ADMIN"],
  permissions: ["manage:users"],
  redirectTo: "/unauthorized",
  loadingType: "overlay"
});

// For conditional rendering
<IfHasPermission 
  permission="edit:pharmacy"
  fallback={<ReadOnlyView />}
  loadingElement={<CustomLoader />}
>
  <EditButton />
</IfHasPermission>

<IfHasRole 
  role="ADMIN"
  fallback={<UserView />}
  loadingElement={<CustomLoader />}
>
  <AdminPanel />
</IfHasRole>
*/
</file>

<file path="src/components/common/ErrorBoundary.tsx">
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return (
        <Alert variant="destructive" className="m-4">
          <AlertTitle>Something went wrong</AlertTitle>
          <AlertDescription>
            {this.state.error?.message || 'An unexpected error occurred'}
          </AlertDescription>
        </Alert>
      );
    }

    return this.props.children;
  }
}
</file>

<file path="src/components/dashboard/Breadcrumbs.tsx">
"use client";

import { usePathname } from "next/navigation";
import Link from "next/link";
import { ChevronRight, Home } from "lucide-react";
import { useMemo } from "react";

interface BreadcrumbItem {
  label: string;
  href: string;
}

const routeLabels: Record<string, string> = {
  dashboard: "Dashboard",
  inventory: "Inventory",
  users: "Users",
  reports: "Reports",
  settings: "Settings",
  profile: "Profile",
  "manage-users": "Manage Users",
  "manage-inventory": "Manage Inventory",
  analytics: "Analytics",
  "system-settings": "System Settings",
};

export function Breadcrumbs() {
  const pathname = usePathname();

  const breadcrumbs = useMemo(() => {
    // Remove trailing slash and split path
    const pathParts = pathname.replace(/\/$/, "").split("/").filter(Boolean);
    
    // Generate breadcrumb items
    const items: BreadcrumbItem[] = [];
    let currentPath = "";

    pathParts.forEach((part) => {
      currentPath += `/${part}`;
      items.push({
        label: routeLabels[part] || part.replace(/-/g, " "),
        href: currentPath,
      });
    });

    return items;
  }, [pathname]);

  if (breadcrumbs.length <= 1) return null;

  return (
    <nav aria-label="Breadcrumb" className="mb-4 flex items-center text-sm">
      <ol className="flex items-center space-x-2">
        <li>
          <Link
            href="/dashboard"
            className="text-gray-500 hover:text-blue-600 transition-colors flex items-center"
          >
            <Home className="h-4 w-4" />
          </Link>
        </li>
        
        {breadcrumbs.map((item, index) => (
          <li key={item.href} className="flex items-center">
            <ChevronRight className="h-4 w-4 text-gray-400 mx-1" />
            {index === breadcrumbs.length - 1 ? (
              <span className="text-gray-900 font-medium">
                {item.label}
              </span>
            ) : (
              <Link
                href={item.href}
                className="text-gray-500 hover:text-blue-600 transition-colors"
              >
                {item.label}
              </Link>
            )}
          </li>
        ))}
      </ol>
    </nav>
  );
}
</file>

<file path="src/components/dashboard/ExamsSidebar.tsx">
import React, { useMemo } from 'react';
import Link from "next/link";
import { 
  Sidebar, 
  SidebarContent, 
  SidebarGroup, 
  SidebarGroupLabel, 
  SidebarMenu, 
  SidebarMenuItem, 
  SidebarMenuButton, 
  SidebarTrigger 
} from "@/components/ui/sidebar";
import { 
  FileText, 
  Medal, 
  BookOpen, 
  GraduationCap 
} from "lucide-react";
import { usePathname, useRouter } from "next/navigation";
import { usePermissions } from "@/features/rbac/hooks";

// Define exam menu items with icons and permissions
const examMenuItems = [
  {
    label: "Exams Preparation",
    href: "/exam/dashboard",
    icon: GraduationCap,
    type: 'main',
    roles: ['USER', 'STUDENT'],
    subItems: [
      {
        label: "Past Papers",
        href: "/exam/past-papers",
        icon: FileText,
        type: 'submenu',
        permissions: ['view_past_papers']
      },
      {
        label: "Model Papers",
        href: "/exam/model-papers",
        icon: Medal,
        type: 'submenu', 
        permissions: ['view_model_papers']
      },
      {
        label: "Subject Papers",
        href: "/exam/subject-papers",
        icon: BookOpen,
        type: 'submenu',
        permissions: ['view_subject_papers']
      }
    ]
  }
];

export function ExamsSidebar() {
  const pathname = usePathname();
  const router = useRouter();
  const { hasAccess } = usePermissions();
  const [openMainItem, setOpenMainItem] = React.useState<number | null>(null);

  // Memoize menu items with access filtering
  const filteredMenuItems = useMemo(() => {
    return examMenuItems.filter(item => 
      hasAccess({
        permissions: item.permissions,
        roles: item.roles,
        requireAll: false
      })
    );
  }, [hasAccess]);

  return (
    <Sidebar>
      <SidebarContent>
        <SidebarGroup>
          <SidebarGroupLabel>Exams</SidebarGroupLabel>
          <SidebarMenu>
            {filteredMenuItems.map((item, index) => (
              <SidebarMenuItem key={item.href}>
                <SidebarMenuButton
                  onClick={() => {
                    // If it's a main item with subitems, toggle expand/collapse
                    if (item.subItems && item.subItems.length > 0) {
                      setOpenMainItem(
                        openMainItem === index ? null : index
                      );
                    }
                    
                    // If it's a main item without subitems, navigate to its dashboard
                    if (item.type === 'main') {
                      router.push(item.href);
                    }
                  }}
                  className={pathname === item.href ? 'bg-blue-50 text-blue-600' : ''}
                >
                  <item.icon className="mr-2 h-4 w-4" />
                  {item.label}
                </SidebarMenuButton>

                {/* Render sub-items if open */}
                {item.subItems && openMainItem === index && (
                  <SidebarMenu>
                    {item.subItems.map((subItem) => (
                      <SidebarMenuItem key={subItem.href}>
                        <SidebarMenuButton
                          onClick={() => router.push(subItem.href)}
                          className={pathname === subItem.href ? 'bg-blue-50 text-blue-600' : ''}
                        >
                          <subItem.icon className="mr-2 h-4 w-4" />
                          {subItem.label}
                        </SidebarMenuButton>
                      </SidebarMenuItem>
                    ))}
                  </SidebarMenu>
                )}
              </SidebarMenuItem>
            ))}
          </SidebarMenu>
        </SidebarGroup>
      </SidebarContent>
      <SidebarTrigger />
    </Sidebar>
  );
}
</file>

<file path="src/components/dashboard/MobileSidebar.tsx">
"use client";

import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import { Button } from "@/components/ui/button";
import { Menu, Search, Star } from "lucide-react";
import Link from "next/link";
import { usePathname, useRouter } from "next/navigation";
import { usePermissions } from "@/hooks/usePermissions";
import type { MenuItem } from "@/types/shared";
import { useState, useEffect, useRef, useMemo } from "react";
import { cn } from "@/lib/utils";
import { Input } from "@/components/ui/input";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import { useSwipe } from "@/hooks/useSwipe";
import { useFavorites } from "@/hooks/useFavorites";
import { motion, AnimatePresence } from "framer-motion";

interface MobileSidebarProps {
  items: MenuItem[];
  logo: React.ReactNode;
}

interface SidebarItemProps {
  item: MenuItem;
  onItemClick?: () => void;
  isSelected?: boolean;
  tabIndex?: number;
  showFavorite?: boolean;
}

function SidebarItem({ 
  item, 
  onItemClick, 
  isSelected,
  tabIndex = 0,
  showFavorite = true
}: SidebarItemProps) {
  const pathname = usePathname();
  const { canAccess } = usePermissions();
  const { isFavorite, toggleFavorite } = useFavorites();
  const isActive = pathname === item.href;

  if (!canAccess({
    permissions: item.permissions,
    roles: item.roles,
    requireAll: false
  })) {
    return null;
  }

  const Icon = item.icon;
  const itemIsFavorite = isFavorite(item.href);

  return (
    <div className="group relative">
      <Link
        href={item.href}
        onClick={onItemClick}
        tabIndex={tabIndex}
        className={cn(
          "flex items-center space-x-3 px-4 py-3 rounded-lg transition-colors outline-none",
          isActive
            ? "bg-blue-50 text-blue-600"
            : "text-gray-700 hover:bg-gray-100",
          isSelected && "ring-2 ring-blue-400",
          "focus-visible:ring-2 focus-visible:ring-blue-400"
        )}
      >
        <Icon className="h-5 w-5 shrink-0" />
        <span className="truncate flex-1">{item.label}</span>
        {showFavorite && (
          <Button
            variant="ghost"
            size="icon"
            className={cn(
              "h-8 w-8 opacity-0 group-hover:opacity-100 transition-opacity",
              itemIsFavorite && "opacity-100 text-yellow-500"
            )}
            onClick={(e) => {
              e.preventDefault();
              e.stopPropagation();
              toggleFavorite(item.href);
            }}
          >
            <Star className={cn("h-4 w-4", itemIsFavorite && "fill-current")} />
          </Button>
        )}
      </Link>
    </div>
  );
}

export function MobileSidebar({ items, logo }: MobileSidebarProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedIndex, setSelectedIndex] = useState(-1);
  const router = useRouter();
  const searchInputRef = useRef<HTMLInputElement>(null);
  const { favorites } = useFavorites();

  const swipeHandlers = useSwipe({
    onSwipeLeft: () => setIsOpen(false),
    onSwipeRight: () => setIsOpen(true),
    threshold: 100
  });

  // Group and filter items
  const { favoriteItems, categories } = useMemo(() => {
    const favItems = items.filter(item => favorites.includes(item.href));
    
    const categoryMap = new Map<string, MenuItem[]>();
    
    items.forEach(item => {
      const category = item.category || "General";
      const existingItems = categoryMap.get(category) || [];
      if (!favorites.includes(item.href)) {
        categoryMap.set(category, [...existingItems, item]);
      }
    });

    const filteredCategories = Array.from(categoryMap.entries())
      .map(([name, categoryItems]) => ({
        name,
        items: categoryItems.filter(item => 
          item.label.toLowerCase().includes(searchQuery.toLowerCase())
        )
      }))
      .filter(category => category.items.length > 0);

    return {
      favoriteItems: favItems.filter(item =>
        item.label.toLowerCase().includes(searchQuery.toLowerCase())
      ),
      categories: filteredCategories
    };
  }, [items, favorites, searchQuery]);

  // Reset states when route changes
  const pathname = usePathname();
  useEffect(() => {
    setIsOpen(false);
    setSearchQuery("");
    setSelectedIndex(-1);
  }, [pathname]);

  // Handle keyboard navigation
  const handleKeyDown = (e: React.KeyboardEvent) => {
    const allItems = [...favoriteItems, ...categories.flatMap(c => c.items)];
    
    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        setSelectedIndex(prev => 
          prev < allItems.length - 1 ? prev + 1 : prev
        );
        break;
      case "ArrowUp":
        e.preventDefault();
        setSelectedIndex(prev => prev > 0 ? prev - 1 : prev);
        break;
      case "Enter":
        if (selectedIndex >= 0 && selectedIndex < allItems.length) {
          const selectedItem = allItems[selectedIndex];
          router.push(selectedItem.href);
          setIsOpen(false);
          setSearchQuery("");
          setSelectedIndex(-1);
        }
        break;
      case "Escape":
        if (searchQuery) {
          e.preventDefault();
          setSearchQuery("");
          setSelectedIndex(-1);
        }
        break;
      case "/":
        if (e.target === searchInputRef.current) return;
        e.preventDefault();
        searchInputRef.current?.focus();
        break;
    }
  };

  return (
    <>
      <div
        className="fixed inset-y-0 left-0 w-8 md:hidden"
        {...swipeHandlers}
      />

      <Sheet open={isOpen} onOpenChange={setIsOpen}>
        <SheetTrigger asChild>
          <Button 
            variant="ghost" 
            size="icon" 
            className="md:hidden"
            aria-label="Open menu"
          >
            <Menu className="h-5 w-5" />
          </Button>
        </SheetTrigger>
        <SheetContent 
          side="left" 
          className="w-[80%] max-w-[320px] p-0"
          {...swipeHandlers}
        >
          <div className="flex flex-col h-full" onKeyDown={handleKeyDown}>
            <div className="p-4 border-b">
              {logo}
            </div>
            
            {/* Search Box */}
            <div className="p-4 border-b">
              <div className="relative">
                <Search className="absolute left-2 top-2.5 h-4 w-4 text-gray-500" />
                <Input
                  ref={searchInputRef}
                  type="text"
                  placeholder="Search menu... ('/' to focus)"
                  value={searchQuery}
                  onChange={(e) => {
                    setSearchQuery(e.target.value);
                    setSelectedIndex(-1);
                  }}
                  className="pl-8 w-full"
                />
              </div>
              {searchQuery && (
                <div className="mt-2 text-xs space-y-1 text-gray-500">
                  <p>Use ↑↓ to navigate</p>
                  <p>Enter to select</p>
                  <p>Escape to clear search</p>
                </div>
              )}
            </div>

            {/* Menu Items */}
            <nav className="flex-1 overflow-y-auto">
              {/* Favorites Section */}
              <AnimatePresence initial={false}>
                {favoriteItems.length > 0 && (
                  <motion.div
                    initial={{ height: 0, opacity: 0 }}
                    animate={{ height: "auto", opacity: 1 }}
                    exit={{ height: 0, opacity: 0 }}
                    transition={{ duration: 0.2 }}
                    className="border-b"
                  >
                    <div className="p-2">
                      <h2 className="px-2 text-sm font-medium text-gray-500 mb-2">
                        Favorites
                      </h2>
                      <div className="space-y-1">
                        {favoriteItems.map((item, index) => (
                          <SidebarItem
                            key={item.href}
                            item={item}
                            isSelected={index === selectedIndex}
                            onItemClick={() => {
                              setIsOpen(false);
                              setSearchQuery("");
                              setSelectedIndex(-1);
                            }}
                            tabIndex={index === selectedIndex ? 0 : -1}
                          />
                        ))}
                      </div>
                    </div>
                  </motion.div>
                )}
              </AnimatePresence>

              {/* Categories */}
              <Accordion
                type="multiple"
                defaultValue={categories.map(c => c.name)}
                className="p-2"
              >
                {categories.map((category) => (
                  <AccordionItem key={category.name} value={category.name}>
                    <AccordionTrigger className="px-2 hover:no-underline">
                      <span className="text-sm font-medium text-gray-600">
                        {category.name}
                      </span>
                    </AccordionTrigger>
                    <AccordionContent>
                      <div className="space-y-1">
                        {category.items.map((item, index) => {
                          let globalIndex = favoriteItems.length;
                          for (let i = 0; i < categories.indexOf(category); i++) {
                            globalIndex += categories[i].items.length;
                          }
                          globalIndex += index;

                          return (
                            <SidebarItem
                              key={item.href}
                              item={item}
                              isSelected={globalIndex === selectedIndex}
                              onItemClick={() => {
                                setIsOpen(false);
                                setSearchQuery("");
                                setSelectedIndex(-1);
                              }}
                              tabIndex={globalIndex === selectedIndex ? 0 : -1}
                            />
                          );
                        })}
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                ))}
              </Accordion>
            </nav>
          </div>
        </SheetContent>
      </Sheet>
    </>
  );
}
</file>

<file path="src/components/dashboard/Sidebar.tsx">
"use client";

import React from 'react';
import Link from "next/link";
import { usePathname } from "next/navigation";
import { Button } from "@/components/ui/button";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet";
import { cn } from "@/lib/utils";
import { 
  Menu, 
  LucideIcon, 
  GraduationCap 
} from "lucide-react";
import ModernMinimalistLogo from "@/shared/ui/logo/ModernMinimalistLogo";
import { useIsMobile } from "@/features/ui/hooks";

// Simplified menu items
const menuItems = [
  { 
    label: "Exam Preparation", 
    href: "/exam/dashboard", 
    icon: GraduationCap,
    subItems: [
      { 
        label: "Past Papers", 
        href: "/exam/past-papers", 
        icon: GraduationCap
      },
      { 
        label: "Model Papers", 
        href: "/exam/model-papers", 
        icon: GraduationCap
      },
      { 
        label: "Subject Papers", 
        href: "/exam/subject-papers", 
        icon: GraduationCap
      }
    ]
  }
];

function NavItem({ 
  item, 
  depth = 0, 
  pathname 
}: { 
  item: any, 
  depth?: number, 
  pathname: string | null
}) {
  const isActive = pathname === item.href || pathname?.startsWith(`${item.href}/`);
  const Icon = item.icon;

  return (
    <div>
      <Link
        href={item.href}
        className={cn(
          "flex items-center space-x-3 px-4 py-2 rounded-lg transition-colors w-full",
          isActive
            ? "bg-blue-50 text-blue-600"
            : "text-gray-700 hover:bg-gray-100",
          `pl-${depth * 4}`
        )}
      >
        <Icon className="h-5 w-5" />
        <span>{item.label}</span>
      </Link>
      
      {/* Render sub-items if they exist */}
      {item.subItems && (
        <div className="pl-4">
          {item.subItems.map((subItem) => (
            <NavItem 
              key={subItem.href} 
              item={subItem} 
              depth={depth + 1} 
              pathname={pathname}
            />
          ))}
        </div>
      )}
    </div>
  );
}

function NavItems() {
  const pathname = usePathname();

  return (
    <nav className="space-y-1">
      {menuItems.map((item) => (
        <NavItem 
          key={item.href} 
          item={item} 
          pathname={pathname}
        />
      ))}
    </nav>
  );
}

export function Sidebar() {
  const isMobile = useIsMobile();

  // On desktop: render full sidebar without logo
  if (!isMobile) {
    return (
      <aside className="w-64 bg-white rounded-lg shadow-sm h-fit sticky top-24 overflow-y-auto max-h-[calc(100vh-6rem)]">
        <div className="p-4">
          <NavItems />
        </div>
      </aside>
    );
  }

  return (
    <Sheet>
      <SheetTrigger asChild>
        <Button variant="ghost" size="default" className="md:hidden">
          <Menu className="h-6 w-6" />
        </Button>
      </SheetTrigger>
      <SheetContent side="left" className="w-[280px] sm:w-[320px] overflow-y-auto">
        <SheetHeader className="px-1">
          <SheetTitle>
            <ModernMinimalistLogo />
          </SheetTitle>
        </SheetHeader>
        <div className="mt-8 px-1">
          <NavItems />
        </div>
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="src/components/dashboard/UserMenu.tsx">
"use client";

import { usePermissions } from "@/features/rbac/hooks";
import { useSession } from "@/features/auth/hooks";
import { authService } from "@/features/auth/api/services/authService";
import { useRouter } from "next/navigation";
import Link from "next/link";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import {
  User,
  Settings,
  LogOut,
  ChevronDown,
  Shield,
  Key,
  Loader2
} from "lucide-react";
import { useState } from "react";

export function UserMenu() {
  const { session } = useSession();
  const { isAdmin, isManager } = usePermissions();
  const router = useRouter();
  const [isLoggingOut, setIsLoggingOut] = useState(false);
  const user = session?.user;

  const handleSignOut = async () => {
    try {
      setIsLoggingOut(true);
      
      // Logout using authService
      await authService.logout();
      
      // Clear local storage
      localStorage.clear();
      
      // Clear session cookies
      document.cookie.split(";").forEach(function(c) {
        document.cookie = c.replace(/^ +/, "")
          .replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
      });
      
      // Redirect to login
      router.push('/login');
      
      // Force reload to clear any remaining state
      window.location.reload();
    } catch (error) {
      console.error('Logout error:', error);
      // Still try to redirect even if logout fails
      router.push('/login');
    } finally {
      setIsLoggingOut(false);
    }
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" className="flex items-center space-x-2">
          <div className="flex items-center space-x-2">
            <User className="h-5 w-5" />
            <span className="hidden md:inline-block">
              {user?.name || user?.email}
            </span>
          </div>
          <ChevronDown className="h-4 w-4" />
        </Button>
      </DropdownMenuTrigger>
      
      <DropdownMenuContent align="end" className="w-56">
        <DropdownMenuLabel>
          <div className="flex flex-col space-y-1">
            <p className="text-sm font-medium">{user?.name}</p>
            <p className="text-xs text-gray-500">{user?.email}</p>
          </div>
        </DropdownMenuLabel>
        
        <DropdownMenuSeparator />
        
        {/* Role Badges */}
        <div className="px-2 py-1.5 text-xs">
          <div className="flex flex-wrap gap-1">
            {isAdmin && (
              <span className="px-2 py-1 rounded-full bg-blue-100 text-blue-800">
                Admin
              </span>
            )}
            {isManager && (
              <span className="px-2 py-1 rounded-full bg-green-100 text-green-800">
                Manager
              </span>
            )}
          </div>
        </div>

        <DropdownMenuSeparator />
        
        <Link href="/profile">
          <DropdownMenuItem className="cursor-pointer">
            <User className="mr-2 h-4 w-4" />
            Profile
          </DropdownMenuItem>
        </Link>
        
        {isAdmin && (
          <Link href="/settings">
            <DropdownMenuItem className="cursor-pointer">
              <Settings className="mr-2 h-4 w-4" />
              Settings
            </DropdownMenuItem>
          </Link>
        )}

        {(isAdmin || isManager) && (
          <Link href="/permissions">
            <DropdownMenuItem className="cursor-pointer">
              <Shield className="mr-2 h-4 w-4" />
              Permissions
            </DropdownMenuItem>
          </Link>
        )}

        <Link href="/change-password">
          <DropdownMenuItem className="cursor-pointer">
            <Key className="mr-2 h-4 w-4" />
            Change Password
          </DropdownMenuItem>
        </Link>
        
        <DropdownMenuSeparator />
        
        <DropdownMenuItem 
          className="cursor-pointer text-red-600 focus:text-red-600"
          onClick={handleSignOut}
          disabled={isLoggingOut}
        >
          {isLoggingOut ? (
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          ) : (
            <LogOut className="mr-2 h-4 w-4" />
          )}
          {isLoggingOut ? 'Signing out...' : 'Sign Out'}
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="src/components/layout/container.tsx">
'use client';

import React from 'react';

interface ContainerProps {
  children: React.ReactNode;
  className?: string;
}

export function Container({ children, className = '' }: ContainerProps) {
  return (
    <div className={`container mx-auto px-4 max-w-7xl ${className}`}>
      {children}
    </div>
  );
}
</file>

<file path="src/components/ui/accordion.tsx">
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="src/components/ui/alert-dialog.tsx">
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="src/components/ui/aspect-ratio.tsx">
"use client"

import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }
</file>

<file path="src/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import {cn} from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({className, ...props}, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({className, ...props}, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({className, ...props}, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export {Avatar, AvatarImage, AvatarFallback}
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
</file>

<file path="src/components/ui/breadcrumb.tsx">
import * as React from "react"
import {Slot} from "@radix-ui/react-slot"
import {ChevronRight, MoreHorizontal} from "lucide-react"

import {cn} from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
  separator?: React.ReactNode
}
>(({...props}, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({className, ...props}, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({className, ...props}, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
  asChild?: boolean
}
>(({asChild, className, ...props}, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({className, ...props}, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
                               children,
                               className,
                               ...props
                             }: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight/>}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
                              className,
                              ...props
                            }: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4"/>
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "underline-offset-4 hover:underline text-primary",
      },
      size: {
        default: "h-10 py-2 px-4",
        sm: "h-9 px-3 rounded-md",
        lg: "h-11 px-8 rounded-md",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { buttonVariants }
</file>

<file path="src/components/ui/calendar.tsx">
"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("h-4 w-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("h-4 w-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"

import {cn} from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({className, ...props}, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({className, ...props}, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({className, ...props}, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({className, ...props}, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({className, ...props}, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({className, ...props}, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export {Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent}
</file>

<file path="src/components/ui/carousel.tsx">
"use client"

import * as React from "react"
import useEmblaCarousel, {type UseEmblaCarouselType,} from "embla-carousel-react"
import {ArrowLeft, ArrowRight} from "lucide-react"

import {cn} from "@/lib/utils"
import {Button} from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({className, ...props}, ref) => {
  const {carouselRef, orientation} = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({className, ...props}, ref) => {
  const {orientation} = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({className, variant = "outline", size = "default", ...props}, ref) => {
  const {orientation, scrollPrev, canScrollPrev} = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4"/>
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({className, variant = "outline", size = "default", ...props}, ref) => {
  const {orientation, scrollNext, canScrollNext} = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4"/>
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
</file>

<file path="src/components/ui/chart.tsx">
"use client"

import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }

      const [item] = payload
      const key = `${labelKey || item.dataKey || item.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }

      if (!value) {
        return null
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])

    if (!active || !payload?.length) {
      return null
    }

    const nestLabel = payload.length === 1 && indicator !== "dot"

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()

    if (!payload?.length) {
      return null
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}
</file>

<file path="src/components/ui/checkbox.tsx">
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-3.5 w-3.5" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }
</file>

<file path="src/components/ui/collapsible.tsx">
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export {Collapsible, CollapsibleTrigger, CollapsibleContent}
</file>

<file path="src/components/ui/command.tsx">
"use client"

import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
</file>

<file path="src/components/ui/confirm-dialog.tsx">
"use client";

import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

interface ConfirmDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  title: string;
  description: string;
  onConfirm: () => void;
  confirmText?: string;
  cancelText?: string;
}

export function ConfirmDialog({
  open,
  onOpenChange,
  title,
  description,
  onConfirm,
  confirmText = "Continue",
  cancelText = "Cancel"
}: ConfirmDialogProps) {
  return (
    <AlertDialog open={open} onOpenChange={onOpenChange}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>{title}</AlertDialogTitle>
          <AlertDialogDescription>
            {description}
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel>{cancelText}</AlertDialogCancel>
          <AlertDialogAction onClick={onConfirm}>
            {confirmText}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
</file>

<file path="src/components/ui/context-menu.tsx">
"use client"

import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}
</file>

<file path="src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import {X} from "lucide-react"

import {cn} from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({className, ...props}, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({className, children, ...props}, ref) => (
  <DialogPortal>
    <DialogOverlay/>
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close
        className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4"/>
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
                        className,
                        ...props
                      }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
                        className,
                        ...props
                      }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({className, ...props}, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({className, ...props}, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="src/components/ui/drawer.tsx">
"use client"

import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import {Check, ChevronRight, Circle} from "lucide-react"

import {cn} from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}
>(({className, inset, children, ...props}, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto"/>
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({className, ...props}, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({className, sideOffset = 4, ...props}, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
}
>(({className, inset, ...props}, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({className, children, checked, ...props}, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4"/>
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({className, children, ...props}, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current"/>
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}
>(({className, inset, ...props}, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({className, ...props}, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
                                className,
                                ...props
                              }: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="src/components/ui/form.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="src/components/ui/hover-card.tsx">
"use client"

import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }
</file>

<file path="src/components/ui/icons.tsx">
'use client';

import React from 'react';

// Navigation icons
export function ChevronLeftIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      {...props}
    >
      <path d="m15 18-6-6 6-6" />
    </svg>
  );
}

export function ChevronRightIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      {...props}
    >
      <path d="m9 18 6-6-6-6" />
    </svg>
  );
}

// Status icons
export function CheckCircleIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      {...props}
    >
      <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" />
      <polyline points="22 4 12 14.01 9 11.01" />
    </svg>
  );
}

export function XCircleIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      {...props}
    >
      <circle cx="12" cy="12" r="10" />
      <line x1="15" y1="9" x2="9" y2="15" />
      <line x1="9" y1="9" x2="15" y2="15" />
    </svg>
  );
}

export function CircleIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      {...props}
    >
      <circle cx="12" cy="12" r="10" />
    </svg>
  );
}

// Flag/bookmark icons
export function BookmarkIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      {...props}
    >
      <path d="m19 21-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z" />
    </svg>
  );
}

export function BookmarkFilledIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="currentColor"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      {...props}
    >
      <path d="m19 21-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z" />
    </svg>
  );
}

// Timer/clock icons
export function ClockIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      {...props}
    >
      <circle cx="12" cy="12" r="10" />
      <polyline points="12 6 12 12 16 14" />
    </svg>
  );
}

export function PauseIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      {...props}
    >
      <rect x="6" y="4" width="4" height="16" />
      <rect x="14" y="4" width="4" height="16" />
    </svg>
  );
}

export function PlayIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      {...props}
    >
      <polygon points="5 3 19 12 5 21 5 3" />
    </svg>
  );
}
</file>

<file path="src/components/ui/input-otp.tsx">
"use client"

import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"

import { cn } from "@/lib/utils"

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react"

import {cn} from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({className, type, ...props}, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export {Input}
</file>

<file path="src/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import {cva, type VariantProps} from "class-variance-authority"

import {cn} from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
  VariantProps<typeof labelVariants>
>(({className, ...props}, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export {Label}
</file>

<file path="src/components/ui/loading-spinner.tsx">
"use client";

import { cn } from "@/lib/utils";

interface LoadingSpinnerProps extends React.HTMLAttributes<HTMLDivElement> {
  size?: "sm" | "md" | "lg";
  variant?: "light" | "dark";
}

const sizeClasses = {
  sm: "h-4 w-4 border-2",
  md: "h-8 w-8 border-3",
  lg: "h-12 w-12 border-4"
};

const variantClasses = {
  light: "border-white/20 border-t-white",
  dark: "border-gray-200 border-t-gray-600"
};

export function LoadingSpinner({
  size = "md",
  variant = "dark",
  className,
  ...props
}: LoadingSpinnerProps) {
  return (
    <div
      className={cn(
        "animate-spin rounded-full",
        sizeClasses[size],
        variantClasses[variant],
        className
      )}
      {...props}
    />
  );
}

export function LoadingOverlay({
  message = "Loading...",
  className,
  ...props
}: {
  message?: string;
} & React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn(
        "fixed inset-0 flex flex-col items-center justify-center bg-white/80 backdrop-blur-sm z-50",
        className
      )}
      {...props}
    >
      <LoadingSpinner size="lg" />
      {message && (
        <p className="mt-4 text-gray-600 font-medium">{message}</p>
      )}
    </div>
  );
}

// Example usage:
/*
// Basic spinner
<LoadingSpinner />

// Custom size and variant
<LoadingSpinner size="lg" variant="light" />

// Full overlay
<LoadingOverlay message="Please wait..." />
*/
</file>

<file path="src/components/ui/menubar.tsx">
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return <MenubarPrimitive.RadioGroup {...props} />
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}
</file>

<file path="src/components/ui/navigation-menu.tsx">
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import {cva} from "class-variance-authority"
import {ChevronDown} from "lucide-react"

import {cn} from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({className, children, ...props}, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport/>
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({className, ...props}, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({className, children, ...props}, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({className, ...props}, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({className, ...props}, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({className, ...props}, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md"/>
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}
</file>

<file path="src/components/ui/pagination.tsx">
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "default",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}
</file>

<file path="src/components/ui/popover.tsx">
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }
</file>

<file path="src/components/ui/progress.tsx">
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }
</file>

<file path="src/components/ui/radio-group.tsx">
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import {Circle} from "lucide-react"

import {cn} from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({className, ...props}, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({className, ...props}, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current"/>
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export {RadioGroup, RadioGroupItem}
</file>

<file path="src/components/ui/resizable.tsx">
"use client"

import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }
</file>

<file path="src/components/ui/scroll-area.tsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import {cn} from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({className, children, ...props}, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar/>
    <ScrollAreaPrimitive.Corner/>
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({className, orientation = "vertical", ...props}, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
      "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
      "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border"/>
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export {ScrollArea, ScrollBar}
</file>

<file path="src/components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import {Check, ChevronDown, ChevronUp} from "lucide-react"

import {cn} from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({className, children, ...props}, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50"/>
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({className, ...props}, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4"/>
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({className, ...props}, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4"/>
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({className, children, position = "popper", ...props}, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
        "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton/>
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
          "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton/>
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({className, ...props}, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({className, children, ...props}, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4"/>
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({className, ...props}, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
</file>

<file path="src/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import {cn} from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    {className, orientation = "horizontal", decorative = true, ...props},
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export {Separator}
</file>

<file path="src/components/ui/sheet.tsx">
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import {cva, type VariantProps} from "class-variance-authority"
import {X} from "lucide-react"

import {cn} from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({className, ...props}, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {
}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({side = "right", className, children, ...props}, ref) => (
  <SheetPortal>
    <SheetOverlay/>
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({side}), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close
        className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4"/>
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
                       className,
                       ...props
                     }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
                       className,
                       ...props
                     }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({className, ...props}, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({className, ...props}, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="src/components/ui/sidebar.tsx">
"use client"

import * as React from "react"
import {Slot} from "@radix-ui/react-slot"
import {cva, VariantProps} from "class-variance-authority"
import {PanelLeft} from "lucide-react"

import {useIsMobile} from "@/features/ui/hooks"
import {cn} from "@/lib/utils"
import {Button} from "@/components/ui/button"
import {Input} from "@/components/ui/input"
import {Separator} from "@/components/ui/separator"
import {Sheet, SheetContent} from "@/components/ui/sheet"
import {Skeleton} from "@/components/ui/skeleton"
import {Tooltip, TooltipContent, TooltipProvider, TooltipTrigger,} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar:state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContext = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContext | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
  defaultOpen?: boolean
  open?: boolean
  onOpenChange?: (open: boolean) => void
}
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContext>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
  side?: "left" | "right"
  variant?: "sidebar" | "floating" | "inset"
  collapsible?: "offcanvas" | "icon" | "none"
}
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const {isMobile, state, openMobile, setOpenMobile} = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden md:block text-sidebar-foreground"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ?
              "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              :
              "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({className, onClick, ...props}, ref) => {
  const {toggleSidebar} = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="default"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft/>
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({className, ...props}, ref) => {
  const {toggleSidebar} = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({className, ...props}, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex min-h-svh flex-1 flex-col bg-background",
        "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({className, ...props}, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({className, ...props}, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({className, ...props}, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({className, ...props}, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({className, ...props}, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({className, ...props}, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({className, asChild = false, ...props}, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({className, asChild = false, ...props}, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({className, ...props}, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({className, ...props}, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({className, ...props}, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
  asChild?: boolean
  isActive?: boolean
  tooltip?: string | React.ComponentProps<typeof TooltipContent>
} & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const {isMobile, state} = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({variant, size}), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
  asChild?: boolean
  showOnHover?: boolean
}
>(({className, asChild = false, showOnHover = false, ...props}, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
        "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({className, ...props}, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
  showIcon?: boolean
}
>(({className, showIcon = false, ...props}, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("rounded-md h-8 flex gap-2 px-2 items-center", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 flex-1 max-w-[--skeleton-width]"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({className, ...props}, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({...props}, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
  asChild?: boolean
  size?: "sm" | "md"
  isActive?: boolean
}
>(({asChild = false, size = "md", isActive, className, ...props}, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
</file>

<file path="src/components/ui/skeleton.tsx">
import {cn} from "@/lib/utils"

function Skeleton({
                    className,
                    ...props
                  }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export {Skeleton}
</file>

<file path="src/components/ui/slider.tsx">
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }
</file>

<file path="src/components/ui/sonner.tsx">
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="src/components/ui/switch.tsx">
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
</file>

<file path="src/components/ui/table.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="src/components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import {cn} from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({className, ...props}, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({className, ...props}, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({className, ...props}, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export {Tabs, TabsList, TabsTrigger, TabsContent}
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }
</file>

<file path="src/components/ui/toast-context.tsx">
"use client"

import * as React from "react"
import { ToastActionElement, ToastProps } from "./toast"

type ToastContextType = {
  toasts: Toast[]
  addToast: (toast: Toast) => void
  removeToast: (id: string) => void
}

export type Toast = {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
  variant?: "default" | "destructive"
  duration?: number
}

const ToastContext = React.createContext<ToastContextType | undefined>(undefined)

export function ToastProvider({ children }: { children: React.ReactNode }) {
  const [toasts, setToasts] = React.useState<Toast[]>([])

  const addToast = React.useCallback((toast: Toast) => {
    setToasts((prev) => [...prev, toast])
  }, [])

  const removeToast = React.useCallback((id: string) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id))
  }, [])

  // Clean up toasts after they expire
  React.useEffect(() => {
    const interval = setInterval(() => {
      setToasts((toasts) => {
        return toasts.filter((toast) => {
          if (toast.duration === undefined || toast.duration === Infinity) {
            return true
          }
          return false
        })
      })
    }, 1000)
    return () => clearInterval(interval)
  }, [])

  return (
    <ToastContext.Provider value={{ toasts, addToast, removeToast }}>
      {children}
    </ToastContext.Provider>
  )
}

export function useToast() {
  const context = React.useContext(ToastContext)
  
  if (!context) {
    throw new Error("useToast must be used within a ToastProvider")
  }
  
  return {
    toasts: context.toasts,
    toast: (props: Omit<Toast, "id">) => {
      const id = Math.random().toString(36).substring(2, 9)
      context.addToast({ id, ...props })
    },
    dismiss: (id: string) => {
      context.removeToast(id)
    }
  }
}
</file>

<file path="src/components/ui/toast.tsx">
import * as React from "react";
import { Cross2Icon } from "@radix-ui/react-icons";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <Cross2Icon className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};

export type ToastInstance = {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
  variant?: "default" | "destructive";
  duration?: number;
};

type ToastContextValue = {
  toast: (props: Omit<ToastInstance, "id">) => void;
  dismiss: (id: string) => void;
};

const ToastContext = React.createContext<ToastContextValue | undefined>(
  undefined
);

export const useToast = (): ToastContextValue => {
  const context = React.useContext(ToastContext);
  if (!context) {
    throw new Error("useToast must be used within a ToastProvider");
  }
  return context;
};

export function ToastContainer() {
  const [toasts, setToasts] = React.useState<ToastInstance[]>([]);

  React.useEffect(() => {
    // Clean up expired toasts
    const timer = setInterval(() => {
      setToasts((prevToasts) => prevToasts.filter((toast) => toast.id));
    }, 1000);
    return () => clearInterval(timer);
  }, []);

  const toast = React.useCallback((props: Omit<ToastInstance, "id">) => {
    const id = Math.random().toString(36).substring(2, 9);
    setToasts((prevToasts) => [...prevToasts, { id, ...props }]);
    return id;
  }, []);

  const dismiss = React.useCallback((id: string) => {
    setToasts((prevToasts) => prevToasts.filter((toast) => toast.id !== id));
  }, []);

  return (
    <ToastContext.Provider value={{ toast, dismiss }}>
      <ToastProvider>
        {toasts.map(({ id, title, description, action, variant, duration = 5000 }) => (
          <Toast
            key={id}
            variant={variant}
            onOpenChange={(open) => {
              if (!open) dismiss(id);
            }}
            duration={duration}
          >
            {title && <ToastTitle>{title}</ToastTitle>}
            {description && <ToastDescription>{description}</ToastDescription>}
            {action}
            <ToastClose />
          </Toast>
        ))}
        <ToastViewport />
      </ToastProvider>
    </ToastContext.Provider>
  );
}
</file>

<file path="src/components/ui/toaster.tsx">
"use client"

import { useToast as useToastContext } from "./toast-context"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToastContext()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
</file>

<file path="src/components/ui/toggle-group.tsx">
"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }
</file>

<file path="src/components/ui/toggle.tsx">
"use client"

import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3 min-w-10",
        sm: "h-9 px-2.5 min-w-9",
        lg: "h-11 px-5 min-w-11",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }
</file>

<file path="src/components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import {cn} from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({className, sideOffset = 4, ...props}, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export {Tooltip, TooltipTrigger, TooltipContent, TooltipProvider}
</file>

<file path="src/components/ui/use-toast.ts">
"use client"

import { Toast, useToast as useToastContext } from "./toast-context"

export type ToastProps = {
  title?: string
  description?: string
  action?: React.ReactNode
  duration?: number
  variant?: "default" | "destructive"
}

export function useToast() {
  const { toast, dismiss } = useToastContext()

  return {
    toast: (props: ToastProps) => {
      const { title, description, action, variant = "default", duration = 5000 } = props
      toast({ title, description, action, variant, duration })
    },
    dismiss
  }
}

export type { Toast }
</file>

<file path="src/features/auth/api/apiConfig.ts">
/**
 * API configuration for authentication
 * 
 * Contains constants and config values used throughout
 * the auth feature.
 */

// Base URL for authentication requests
export const AUTH_API_URL = process.env.NEXT_PUBLIC_AUTH_API_URL || '/api/auth';

// Local storage key constants for auth tokens
export const TOKEN_CONFIG = {
  // Main token keys (preferred)
  ACCESS_TOKEN_KEY: 'accessToken',
  REFRESH_TOKEN_KEY: 'refreshToken',
  TOKEN_EXPIRY_KEY: 'tokenExpiry',
  
  // Legacy token keys (for compatibility)
  LEGACY_ACCESS_TOKEN_KEY: 'auth_token',
  LEGACY_ACCESS_TOKEN_KEY2: 'access_token',
  LEGACY_REFRESH_TOKEN_KEY: 'refresh_token',
  LEGACY_TOKEN_EXPIRY_KEY: 'token_expiry',
};

// Authentication endpoints
export const AUTH_ENDPOINTS = {
  LOGIN: '/login',
  REGISTER: '/register',
  LOGOUT: '/logout',
  REFRESH_TOKEN: '/token/refresh',
  VERIFY_EMAIL: '/verify-email',
  REQUEST_PASSWORD_RESET: '/forgot-password',
  RESET_PASSWORD: '/reset-password',
  VALIDATE_RESET_TOKEN: '/reset-password/validate',
  ME: '/me',
};

// Token configuration
export const TOKEN_SETTINGS = {
  // Refresh token 5 minutes before expiry
  REFRESH_THRESHOLD: 5 * 60 * 1000,
  
  // Default expiry time if not provided by API (8 hours)
  DEFAULT_EXPIRY: 8 * 60 * 60 * 1000,
  
  // Refresh token storage time (30 days)
  REFRESH_TOKEN_LIFETIME: 30 * 24 * 60 * 60 * 1000,
};
</file>

<file path="src/features/auth/api/hooks/index.ts">
export * from './mutations';
export * from './queries';
</file>

<file path="src/features/auth/api/hooks/mutations.ts">
import { useApiMutation } from '@/features/tanstack-query-api';
import { AUTH_ROUTES } from '../../constants/routes';
import type { 
  AuthResponse, 
  AuthTokens, 
  LoginRequest, 
  RegisterRequest 
} from '../services/authService';

/**
 * Hook for handling login mutations
 */
export const useLoginMutation = () => {
  return useApiMutation<AuthResponse, LoginRequest>(
    AUTH_ROUTES.LOGIN,
    {
      onSuccess: (data) => {
        // Save tokens on successful login
        if (data.tokens) {
          // Store tokens using authService
          const authService = require('../services/authService').default;
          authService.storeTokens(data.tokens);
        }
      }
    }
  );
};

/**
 * Hook for handling registration mutations
 */
export const useRegisterMutation = () => {
  return useApiMutation<AuthResponse, RegisterRequest>(
    AUTH_ROUTES.REGISTER,
    {
      onSuccess: (data) => {
        // Save tokens on successful registration
        if (data.tokens) {
          const authService = require('../services/authService').default;
          authService.storeTokens(data.tokens);
        }
      }
    }
  );
};

/**
 * Hook for handling password reset request
 */
export const usePasswordResetRequestMutation = () => {
  return useApiMutation<{ success: boolean }, { email: string }>(
    AUTH_ROUTES.REQUEST_PASSWORD_RESET
  );
};

/**
 * Hook for handling password reset completion
 */
export const usePasswordResetCompleteMutation = () => {
  return useApiMutation<void, { token: string; newPassword: string; confirmPassword: string }>(
    AUTH_ROUTES.RESET_PASSWORD
  );
};

/**
 * Hook for handling logout
 */
export const useLogoutMutation = () => {
  return useApiMutation<void, void>(
    AUTH_ROUTES.LOGOUT,
    {
      onSuccess: () => {
        const authService = require('../services/authService').default;
        authService.clearTokens();
        window.location.href = '/login';
      }
    }
  );
};

/**
 * Hook for refreshing auth token
 */
export const useRefreshTokenMutation = () => {
  return useApiMutation<AuthTokens, { refreshToken: string }>(
    AUTH_ROUTES.REFRESH_TOKEN,
    {
      onSuccess: (data) => {
        if (data) {
          const authService = require('../services/authService').default;
          authService.storeTokens(data);
        }
      }
    }
  );
};
</file>

<file path="src/features/auth/api/hooks/queries.ts">
import { useApiQuery } from '@/features/tanstack-query-api';
import { authKeys } from '../queryKeys';
import { AUTH_ROUTES } from '../../constants/routes';
import type { User } from '../services/userService';
import { tokenManager } from '../../core/tokenManager';

/**
 * Hook for fetching the current user's profile
 * Only enabled when user is authenticated
 */
export const useUserProfile = () => {
  // Check if user is authenticated to prevent unnecessary API calls
  const isAuthenticated = tokenManager.hasToken();
  
  return useApiQuery<User>(
    authKeys.me(),
    AUTH_ROUTES.PROFILE,
    {
      // Only enable the query if the user is authenticated
      enabled: isAuthenticated,
      staleTime: 5 * 60 * 1000, // Consider profile data fresh for 5 minutes
      gcTime: 30 * 60 * 1000, // Keep in cache for 30 minutes
      // Don't retry on public pages if auth fails
      retry: isAuthenticated ? 3 : 0,
      // Suppress error notifications on login/public pages
      useErrorBoundary: isAuthenticated,
    }
  );
};

/**
 * Hook for validating password reset token
 */
export const useResetTokenValidation = (token: string) => {
  return useApiQuery<{ valid: boolean }>(
    authKeys.resetToken(token),
    `${AUTH_ROUTES.RESET_PASSWORD}/validate/${token}`,
    {
      enabled: !!token,
      // Don't cache or retry invalid tokens
      gcTime: 0,
      retry: false
    }
  );
};
</file>

<file path="src/features/auth/api/index.ts">
export * from './hooks';
export * from './queryKeys';
export * from './services/auth.service';

// Re-export types that consumers might need
export type { 
  LoginCredentials, 
  LoginResponse, 
  RegistrationData, 
  RegisterResponse,
  VerificationResponse
} from '../model/types';
</file>

<file path="src/features/auth/api/mutations/index.ts">
/**
 * Auth mutations for handling API requests
 */
import { useMutation } from '@tanstack/react-query';
import { authService } from '../services/authService';
import { queryClient } from '@/features/tanstack-query-api/core/queryClient';

/**
 * Hook for handling login requests
 */
export const useLoginMutation = () => {
  return useMutation({
    mutationFn: (credentials: { email: string; password: string }) => {
      return authService.login(credentials);
    },
    onSuccess: (data) => {
      // Store tokens
      if (data?.data?.tokens) {
        authService.storeTokens(data.data.tokens);
      }
      
      // Invalidate user data queries
      queryClient.invalidateQueries({ queryKey: ['user'] });
    }
  });
};

/**
 * Hook for handling registration requests
 */
export const useRegisterMutation = () => {
  return useMutation({
    mutationFn: (userData: any) => {
      return authService.register(userData);
    },
    onSuccess: (data) => {
      // Store tokens if auto-login
      if (data?.data?.tokens) {
        authService.storeTokens(data.data.tokens);
      }
      
      // Invalidate user data queries
      queryClient.invalidateQueries({ queryKey: ['user'] });
    }
  });
};

/**
 * Hook for handling logout requests
 */
export const useLogoutMutation = () => {
  return useMutation({
    mutationFn: () => {
      return authService.logout();
    },
    onSuccess: () => {
      // Remove tokens
      authService.clearTokens();
      
      // Reset query cache
      queryClient.clear();
    }
  });
};

/**
 * Hook for handling password reset requests
 */
export const usePasswordResetRequestMutation = () => {
  return useMutation({
    mutationFn: ({ email }: { email: string }) => {
      return authService.requestPasswordReset(email);
    }
  });
};

/**
 * Hook for handling password reset completion
 */
export const usePasswordResetCompleteMutation = () => {
  return useMutation({
    mutationFn: ({ token, newPassword }: { token: string; newPassword: string }) => {
      return authService.resetPassword(token, newPassword, newPassword);
    }
  });
};

/**
 * Hook for handling email verification
 */
export const useVerifyEmailMutation = () => {
  return useMutation({
    mutationFn: (token: string) => {
      return authService.verifyEmail(token);
    }
  });
};

/**
 * Export all mutations
 */
export default {
  useLoginMutation,
  useRegisterMutation,
  useLogoutMutation,
  usePasswordResetRequestMutation,
  usePasswordResetCompleteMutation,
  useVerifyEmailMutation
};
</file>

<file path="src/features/auth/api/queryKeys.ts">
import { createQueryKeys } from '@/features/tanstack-query-api/hooks/useApi';
import { QueryKey } from '@tanstack/react-query';

/**
 * Type definitions for auth query keys
 */
type AuthQueryKeys = {
  all: () => QueryKey;
  me: () => QueryKey;
  validation: () => QueryKey;
  resetToken: (token: string) => QueryKey;
  verificationStatus: (email: string) => QueryKey;
};

/**
 * Type-safe query keys for auth feature
 */
export const authKeys: AuthQueryKeys = createQueryKeys({
  all: () => ['auth'] as const,
  me: () => [...authKeys.all(), 'me'] as const,
  validation: () => [...authKeys.all(), 'validation'] as const,
  resetToken: (token: string) => [...authKeys.validation(), 'reset', token] as const,
  verificationStatus: (email: string) => [...authKeys.validation(), 'verification', email] as const,
});

export default authKeys;
</file>

<file path="src/features/auth/api/services/auth.service.ts">
import { createExtendedApiService } from '@/features/tanstack-query-api/services/createService';
import { apiClient } from '@/features/tanstack-query-api/core/apiClient';
import { 
  LoginCredentials, 
  LoginResponse, 
  RegistrationData, 
  RegisterResponse,
  VerificationResponse
} from '../../model/types';

// Define custom auth methods beyond standard CRUD
const customMethods = {
  /**
   * Login with email and password
   */
  login: async (credentials: LoginCredentials) => {
    return apiClient.post<LoginResponse>('/auth/login', credentials);
  },

  /**
   * Register a new user
   */
  register: async (data: RegistrationData) => {
    return apiClient.post<RegisterResponse>('/auth/register', data);
  },

  /**
   * Request a password reset
   */
  requestPasswordReset: async (email: string) => {
    return apiClient.post<{ success: boolean }>('/auth/forgot-password', { email });
  },

  /**
   * Validate a password reset token
   */
  validateResetToken: async (token: string) => {
    return apiClient.get<{ valid: boolean }>(`/auth/reset-password/validate/${token}`);
  },

  /**
   * Complete the password reset process
   */
  completePasswordReset: async (token: string, newPassword: string) => {
    return apiClient.post<{ success: boolean }>('/auth/reset-password', { 
      token, 
      newPassword 
    });
  },

  /**
   * Verify email address
   */
  verifyEmail: async (token: string) => {
    return apiClient.post<VerificationResponse>('/auth/verify-email', { token });
  },

  /**
   * Resend verification email
   */
  resendVerification: async (email: string) => {
    return apiClient.post<{ success: boolean }>('/auth/resend-verification', { 
      email 
    });
  }
};

// Create service with both standard CRUD and custom auth methods
export const authService = createExtendedApiService('/auth', customMethods);

export default authService;
</file>

<file path="src/features/auth/api/services/authService.ts">
import { apiClient } from '@/features/tanstack-query-api/core/apiClient';
import type { ApiResponse } from '@/features/tanstack-query-api/core/apiClient';
import { User } from './userService';
import { AUTH_ROUTES } from '../../constants/routes';

/**
 * Login request interface
 */
export interface LoginRequest {
  emailAddress: string;
  password: string;
  rememberMe?: boolean;
}

/**
 * Registration request interface
 */
export interface RegisterRequest {
  email: string;
  password: string;
  confirmPassword: string;
  firstName: string;
  lastName: string;
  termsAccepted: boolean;
}

/**
 * Auth token response
 */
export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
  tokenType: string;
}

/**
 * Authentication response
 */
export interface AuthResponse {
  user: User;
  tokens: AuthTokens;
}

/**
 * Authentication service for handling login, registration, and tokens
 */
export const authService = {
  /**
   * Login with email and password
   */
  login: async (data: LoginRequest): Promise<ApiResponse<AuthResponse>> => {
    return apiClient.post<AuthResponse>(AUTH_ROUTES.LOGIN, data, { requiresAuth: false });
  },

  /**
   * Register a new user
   */
  register: async (data: RegisterRequest): Promise<ApiResponse<AuthResponse>> => {
    return apiClient.post<AuthResponse>(AUTH_ROUTES.REGISTER, data, { requiresAuth: false });
  },

  /**
   * Logout the current user
   */
  logout: async (): Promise<ApiResponse<void>> => {
    return apiClient.post<void>(AUTH_ROUTES.LOGOUT);
  },

  /**
   * Refresh the authentication token
   */
  refreshToken: async (refreshToken: string): Promise<ApiResponse<AuthTokens>> => {
    return apiClient.post<AuthTokens>(AUTH_ROUTES.REFRESH_TOKEN, { refreshToken }, { requiresAuth: false });
  },

  /**
   * Verify email with token
   */
  verifyEmail: async (token: string): Promise<ApiResponse<void>> => {
    return apiClient.post<void>(AUTH_ROUTES.VERIFY_EMAIL, { token }, { requiresAuth: false });
  },

  /**
   * Request password reset
   */
  requestPasswordReset: async (email: string): Promise<ApiResponse<void>> => {
    return apiClient.post<void>(AUTH_ROUTES.REQUEST_PASSWORD_RESET, { email }, { requiresAuth: false });
  },

  /**
   * Reset password with token
   */
  resetPassword: async (token: string, newPassword: string, confirmPassword: string): Promise<ApiResponse<void>> => {
    return apiClient.post<void>(
      AUTH_ROUTES.RESET_PASSWORD, 
      { token, newPassword, confirmPassword }, 
      { requiresAuth: false }
    );
  },

  /**
   * Get the current user profile
   */
  getCurrentUser: async (): Promise<ApiResponse<User>> => {
    return apiClient.get<User>(AUTH_ROUTES.PROFILE);
  },

  /**
   * Store auth tokens in local storage
   */
  storeTokens: (tokens: AuthTokens): void => {
    if (typeof window === 'undefined') return;
    
    localStorage.setItem('accessToken', tokens.accessToken);
    localStorage.setItem('refreshToken', tokens.refreshToken);
    
    // Store token expiry
    const expiryTime = Date.now() + (tokens.expiresIn * 1000);
    localStorage.setItem('tokenExpiry', expiryTime.toString());
  },

  /**
   * Remove auth tokens from storage
   */
  clearTokens: (): void => {
    if (typeof window === 'undefined') return;
    
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
    localStorage.removeItem('tokenExpiry');
  },

  /**
   * Check if the user is authenticated
   */
  isAuthenticated: (): boolean => {
    if (typeof window === 'undefined') return false;
    
    const token = localStorage.getItem('accessToken');
    if (!token) return false;
    
    // Check token expiration
    const expiryStr = localStorage.getItem('tokenExpiry');
    if (expiryStr) {
      const expiry = parseInt(expiryStr, 10);
      if (Date.now() >= expiry) {
        // Token has expired
        return false;
      }
    }
    
    return true;
  }
};

export default authService;
</file>

<file path="src/features/auth/api/services/index.ts">
export * from './auth.service';
</file>

<file path="src/features/auth/api/services/userService.ts">
/**
 * Basic user type definition
 */
export interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  roles: string[];
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

export default User;
</file>

<file path="src/features/auth/config/auth.ts">
// This file is deprecated.
// The content has been moved to src/features/auth/constants/config.ts
// Please update your imports to use the new location.

import { AUTH_CONFIG, PASSWORD_CONFIG } from '../constants/config';

export const ROUTES = {}; // Deprecated, use AUTH_ROUTES from constants/routes.ts
export { AUTH_CONFIG, PASSWORD_CONFIG };
export default { AUTH_CONFIG, PASSWORD_CONFIG };
</file>

<file path="src/features/auth/constants/config.ts">
/**
 * Authentication configuration constants
 * 
 * This file contains all authentication-related configuration values
 * to ensure consistency across the application.
 */
import { AUTH_ROUTES } from './routes';

// Authentication configuration
export const AUTH_CONFIG = {
  // Session configuration
  sessionStorage: 'localStorage', // 'localStorage' or 'sessionStorage'
  tokenKey: 'auth_token',
  refreshTokenKey: 'refresh_token',
  
  // Token configuration
  tokenExpiration: 60 * 60 * 1000, // 1 hour in milliseconds
  refreshThreshold: 5 * 60 * 1000, // 5 minutes in milliseconds
  
  // Authentication behavior
  redirectWhenAuthenticated: '/dashboard',
  redirectWhenUnauthenticated: '/login',
  
  // API endpoints (linked to AUTH_ROUTES for consistency)
  apiEndpoints: {
    login: AUTH_ROUTES.LOGIN,
    register: AUTH_ROUTES.REGISTER,
    refreshToken: AUTH_ROUTES.REFRESH_TOKEN,
    forgotPassword: AUTH_ROUTES.REQUEST_PASSWORD_RESET,
    resetPassword: AUTH_ROUTES.RESET_PASSWORD,
    verifyEmail: AUTH_ROUTES.VERIFY_EMAIL,
    logout: AUTH_ROUTES.LOGOUT,
    profile: AUTH_ROUTES.PROFILE,
  },
};

// Password validation configuration
export const PASSWORD_CONFIG = {
  minLength: 8,
  requireUppercase: true,
  requireLowercase: true,
  requireNumbers: true,
  requireSpecialChars: true,
  maxLength: 128,
};

// Export default configuration object
export default {
  AUTH_CONFIG,
  PASSWORD_CONFIG,
};
</file>

<file path="src/features/auth/constants/flags/index.ts">
/**
 * Auth Feature Flags
 * 
 * Defines feature flags for the auth feature with clear, easy-to-configure settings.
 */

/**
 * Feature flags for authentication and user management
 */
export enum AuthFeatureFlag {
  // Authentication methods
  MULTI_FACTOR_AUTH = 'auth:multi-factor',
  SOCIAL_LOGIN = 'auth:social-login',
  
  // Security features
  PASSWORD_POLICIES = 'auth:password-policies',
  SESSION_MANAGEMENT = 'auth:session-management',
  ACCOUNT_VERIFICATION = 'auth:account-verification',
  ACCOUNT_LOCKING = 'auth:account-locking',
  
  // User management
  USER_INVITATIONS = 'auth:user-invitations',
  SELF_REGISTRATION = 'auth:self-registration'
}

/**
 * Default values for all feature flags
 * Each flag has a separate, clearly named constant for easier configuration
 */

// Basic authentication features
export const FEATURE_MULTI_FACTOR_AUTH_ENABLED = true;
export const FEATURE_SOCIAL_LOGIN_ENABLED = true;

// Security features
export const FEATURE_PASSWORD_POLICIES_ENABLED = true;
export const FEATURE_SESSION_MANAGEMENT_ENABLED = true;
export const FEATURE_ACCOUNT_VERIFICATION_ENABLED = true;
export const FEATURE_ACCOUNT_LOCKING_ENABLED = true;

// User management features
export const FEATURE_USER_INVITATIONS_ENABLED = true;
export const FEATURE_SELF_REGISTRATION_ENABLED = true;

/**
 * Feature flag metadata with names, descriptions, and default settings
 */
export const AUTH_FEATURE_FLAGS = {
  [AuthFeatureFlag.MULTI_FACTOR_AUTH]: {
    name: 'Multi-Factor Authentication',
    description: 'Enables additional security verification using SMS or authenticator apps',
    defaultEnabled: FEATURE_MULTI_FACTOR_AUTH_ENABLED
  },
  [AuthFeatureFlag.SOCIAL_LOGIN]: {
    name: 'Social Login',
    description: 'Allow users to log in using social media accounts',
    defaultEnabled: FEATURE_SOCIAL_LOGIN_ENABLED
  },
  [AuthFeatureFlag.PASSWORD_POLICIES]: {
    name: 'Password Policies',
    description: 'Enforce strong password requirements and periodic password changes',
    defaultEnabled: FEATURE_PASSWORD_POLICIES_ENABLED
  },
  [AuthFeatureFlag.SESSION_MANAGEMENT]: {
    name: 'Session Management',
    description: 'Allow users to view and manage their active sessions',
    defaultEnabled: FEATURE_SESSION_MANAGEMENT_ENABLED
  },
  [AuthFeatureFlag.ACCOUNT_VERIFICATION]: {
    name: 'Account Verification',
    description: 'Require email verification for new accounts',
    defaultEnabled: FEATURE_ACCOUNT_VERIFICATION_ENABLED
  },
  [AuthFeatureFlag.ACCOUNT_LOCKING]: {
    name: 'Account Locking',
    description: 'Automatically lock accounts after multiple failed login attempts',
    defaultEnabled: FEATURE_ACCOUNT_LOCKING_ENABLED
  },
  [AuthFeatureFlag.USER_INVITATIONS]: {
    name: 'User Invitations',
    description: 'Allow administrators to invite new users by email',
    defaultEnabled: FEATURE_USER_INVITATIONS_ENABLED
  },
  [AuthFeatureFlag.SELF_REGISTRATION]: {
    name: 'Self Registration',
    description: 'Allow users to register accounts themselves',
    defaultEnabled: FEATURE_SELF_REGISTRATION_ENABLED
  }
};
</file>

<file path="src/features/auth/constants/index.ts">
/**
 * Auth Feature Constants
 * 
 * Defines the auth feature's permissions, feature flags, and requirements.
 */
import { defineFeature } from '@/features/rbac/registry';
import { Role } from '@/features/rbac/constants/roles';
import { registerFeature } from '@/features/rbac/registry';

// Feature definition
export const AUTH_FEATURE = defineFeature(
  'auth',
  'Authentication & Authorization',
  'User authentication, session management, and access control'
);

import {
  AuthPermission,
  AUTH_ADMIN_PERMISSIONS,
  AUTH_COMMON_PERMISSIONS
} from './permissions';


import {
  AuthFeatureFlag,
  AUTH_FEATURE_FLAGS
} from './flags';


import { AUTH_REQUIRED_ROLES } from './roles';

// Export all auth-related constants
export * from './routes';
export * from './config';


/**
 * Feature initializer
 * Call this to register the feature with the registry
 */
export function initializeAuthFeature() {
  // Register this feature with the registry
  registerFeature(
    AUTH_FEATURE,
    AuthPermission,
    AUTH_REQUIRED_ROLES,
    AuthFeatureFlag,
    AUTH_FEATURE_FLAGS
  );
  
  console.log('Auth feature registered');
}
</file>

<file path="src/features/auth/constants/permissions/index.ts">
/**
 * Auth Feature Permissions
 * 
 * Defines all permissions related to the authentication feature.
 */

/**
 * Auth-specific permissions
 */
export enum AuthPermission {
  // User account permissions
  LOGIN = 'auth:login',
  LOGOUT = 'auth:logout',
  REGISTER = 'auth:register',
  MANAGE_ACCOUNT = 'auth:manage-account',
  VERIFY_EMAIL = 'auth:verify-email',
  RESET_PASSWORD = 'auth:reset-password',
  
  // Profile permissions
  VIEW_PROFILE = 'auth:view-profile',
  EDIT_PROFILE = 'auth:edit-profile',
  
  // Session permissions
  MANAGE_SESSIONS = 'auth:manage-sessions',
  VIEW_SESSIONS = 'auth:view-sessions',
  
  // Admin permissions
  MANAGE_USERS = 'auth:manage-users',
  VIEW_USERS = 'auth:view-users',
  EDIT_USERS = 'auth:edit-users',
  DELETE_USERS = 'auth:delete-users',
  IMPERSONATE_USER = 'auth:impersonate-user'
}

/**
 * Admin-only permissions within this feature
 */
export const AUTH_ADMIN_PERMISSIONS = [
  AuthPermission.MANAGE_USERS,
  AuthPermission.EDIT_USERS,
  AuthPermission.DELETE_USERS,
  AuthPermission.IMPERSONATE_USER
];

/**
 * Permissions that all roles have
 */
export const AUTH_COMMON_PERMISSIONS = [
  AuthPermission.LOGIN,
  AuthPermission.LOGOUT,
  AuthPermission.VIEW_PROFILE,
  AuthPermission.EDIT_PROFILE,
  AuthPermission.RESET_PASSWORD
];
</file>

<file path="src/features/auth/constants/roles/index.ts">
/**
 * Auth Feature Role Requirements
 * 
 * Defines which roles have access to the auth feature.
 */
import { Role } from '@/features/rbac/constants/roles';

/**
 * Roles that have access to the auth feature by default
 * (basically all roles since auth is a core feature)
 */
export const AUTH_REQUIRED_ROLES = [
  Role.USER,
  Role.PHARMACIST,
  Role.PHARMACY_MANAGER,
  Role.TECHNICIAN,
  Role.PROPRIETOR,
  Role.ADMIN,
  Role.SUPER_ADMIN
];

/**
 * Roles that have user management privileges
 */
export const AUTH_ADMIN_ROLES = [
  Role.ADMIN,
  Role.SUPER_ADMIN
];
</file>

<file path="src/features/auth/constants/routes.ts">
/**
 * Authentication API routes constants
 * 
 * This file contains all authentication-related API route paths
 * to ensure consistency across the application.
 */

export const AUTH_ROUTES = {
  // Auth endpoints
  LOGIN: '/api/auth/login',
  REGISTER: '/auth/register',
  LOGOUT: '/auth/logout',
  REFRESH_TOKEN: '/auth/token/refresh',
  VERIFY_EMAIL: '/auth/verify-email',
  REQUEST_PASSWORD_RESET: '/auth/request-password-reset',
  RESET_PASSWORD: '/auth/reset-password',
  
  // User profile endpoints
  PROFILE: '/v1/users/profile',
  
  // Health check
  HEALTH: '/auth/health',
};

/**
 * Helper function to get the full API path with base URL
 */
export function getAuthApiUrl(route: keyof typeof AUTH_ROUTES): string {
  return `/api${AUTH_ROUTES[route]}`;
}

export default AUTH_ROUTES;
</file>

<file path="src/features/auth/core/AuthContext.tsx">
"use client";

import React, { createContext, useContext, useEffect, useState, useCallback, useRef } from 'react';
import { authService } from '../api/services/authService';
import { tokenManager } from './tokenManager';
import { UserProfile } from '../types';
import { logger } from '@/shared/lib/logger';

interface AuthContextType {
  user: UserProfile | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: Error | null;
  login: (username: string, password: string) => Promise<UserProfile>;
  logout: () => Promise<void>;
  refreshUserProfile: () => Promise<UserProfile | null>;
  
  // Legacy RBAC methods for backward compatibility
  // These methods will use the new RBAC feature internally
  hasRole: (role: string) => boolean;
  hasPermission: (permission: string) => boolean;
  hasAccess: (roles: string[], permissions: string[]) => boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

interface AuthProviderProps {
  children: React.ReactNode;
}

// Check browser storage for existing auth state
const checkInitialAuthState = (): boolean => {
  if (typeof window === 'undefined') return false;
  
  const token = localStorage.getItem('auth_token') || localStorage.getItem('access_token');
  if (!token) return false;
  
  // Check if token is expired (if expiry is stored)
  const expiry = localStorage.getItem('token_expiry');
  if (expiry && Date.now() > parseInt(expiry)) {
    return false;
  }
  
  return !!token;
};

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [user, setUser] = useState<UserProfile | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(checkInitialAuthState());
  const profileRequestRef = useRef<Promise<UserProfile | null> | null>(null);

  // Implement a memoized fetchProfile function that uses a ref to store the promise
  // This ensures multiple concurrent calls get the same promise
  const fetchProfile = useCallback(async (): Promise<UserProfile | null> => {
    // If a profile request is already in progress, return that promise
    if (profileRequestRef.current) {
      return profileRequestRef.current;
    }

    // Create a new promise for the profile request
    profileRequestRef.current = (async () => {
      try {
        if (!tokenManager.hasToken()) {
          setIsAuthenticated(false);
          return null;
        }

        const response = await authService.getCurrentUser();
        if (response.error) {
          throw response.error;
        }
        
        if (!response.data) {
          throw new Error('No profile data returned');
        }
        
        // Convert to UserProfile format
        const profile: UserProfile = {
          id: response.data.id,
          username: response.data.email,
          email: response.data.email,
          firstName: response.data.firstName,
          lastName: response.data.lastName,
          roles: response.data.roles || [],
          permissions: [],
          userType: null
        };
        
        setUser(profile);
        setIsAuthenticated(true);
        return profile;
      } catch (err) {
        logger.error('Error fetching user profile', { error: err });
        setError(err instanceof Error ? err : new Error('Failed to fetch user profile'));
        // Only set isAuthenticated to false if it's an auth error (401, 403)
        if (err instanceof Error && 
            (err.message.includes('401') || 
             err.message.includes('403') || 
             err.message.includes('Unauthorized') || 
             err.message.includes('Forbidden'))) {
          setIsAuthenticated(false);
        }
        return null;
      } finally {
        // Clear the request ref when done
        profileRequestRef.current = null;
      }
    })();

    return profileRequestRef.current;
  }, []);

  // Initialize auth state on mount
  useEffect(() => {
    const initializeAuth = async () => {
      setIsLoading(true);
      setError(null);

      try {
        if (tokenManager.hasToken()) {
          try {
            await fetchProfile();
          } catch (profileErr) {
            // If profile fetch fails, just set authenticated to false
            logger.warn('Failed to fetch profile on init, clearing auth state', { error: profileErr });
            setIsAuthenticated(false);
            tokenManager.removeToken();
            tokenManager.removeRefreshToken();
          }
        } else {
          setIsAuthenticated(false);
        }
      } catch (err) {
        logger.error('Authentication initialization error', { error: err });
        setError(err instanceof Error ? err : new Error('Authentication failed'));
        setIsAuthenticated(false);
      } finally {
        setIsLoading(false);
      }
    };

    initializeAuth();
    
    // Set up an interval to check token expiration
    const checkTokenInterval = setInterval(() => {
      const isValid = tokenManager.hasToken();
      if (!isValid && isAuthenticated) {
        setIsAuthenticated(false);
        setUser(null);
      }
    }, 60000); // Check every minute
    
    return () => clearInterval(checkTokenInterval);
  }, [fetchProfile]);

  // Login function
  const login = async (username: string, password: string): Promise<UserProfile> => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await authService.login({ 
        emailAddress: username,
        password 
      });
      
      if (response.error) {
        throw response.error;
      }
      
      if (!response.data || !response.data.tokens || !response.data.user) {
        throw new Error('Invalid login response');
      }
      
      // Store tokens
      const { tokens, user: userData } = response.data;
      
      // Store tokens in tokenManager and localStorage
      tokenManager.setToken(tokens.accessToken);
      tokenManager.setRefreshToken(tokens.refreshToken);
      tokenManager.setTokenExpiry(Date.now() + (tokens.expiresIn * 1000));
      
      // Create user profile
      const userProfile: UserProfile = {
        id: userData.id,
        username: userData.email,
        email: userData.email,
        firstName: userData.firstName,
        lastName: userData.lastName,
        roles: userData.roles || [],
        permissions: [],
        userType: null
      };
      
      setUser(userProfile);
      setIsAuthenticated(true);
      
      return userProfile;
    } catch (err) {
      logger.error('Login error', { error: err });
      const error = err instanceof Error ? err : new Error('Login failed');
      setError(error);
      setIsAuthenticated(false);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Logout function
  const logout = async (): Promise<void> => {
    try {
      await authService.logout();
    } catch (err) {
      logger.error('Logout error', { error: err });
    } finally {
      setUser(null);
      setIsAuthenticated(false);
      // Clear tokens
      tokenManager.removeToken();
      tokenManager.removeRefreshToken();
    }
  };

  // Function to refresh user profile
  const refreshUserProfile = async (): Promise<UserProfile | null> => {
    return fetchProfile();
  };

  // RBAC helper functions for backward compatibility
  const hasRole = useCallback((role: string): boolean => {
    if (!user || !user.roles) return false;
    return user.roles.includes(role);
  }, [user]);
  
  const hasPermission = useCallback((permission: string): boolean => {
    if (!user || !user.permissions) return false;
    return user.permissions.includes(permission);
  }, [user]);
  
  const hasAccess = useCallback((roles: string[] = [], permissions: string[] = []): boolean => {
    if (!user) return false;
    
    // If no roles or permissions specified, deny access
    if (roles.length === 0 && permissions.length === 0) return false;
    
    // Check roles
    const hasRequiredRole = roles.length === 0 || roles.some(role => hasRole(role));
    
    // Check permissions
    const hasRequiredPermission = permissions.length === 0 || 
      permissions.some(permission => hasPermission(permission));
      
    // User must satisfy both role and permission requirements
    return hasRequiredRole && hasRequiredPermission;
  }, [user, hasRole, hasPermission]);
  
  const contextValue: AuthContextType = {
    user,
    isAuthenticated,
    isLoading,
    error,
    login,
    logout,
    refreshUserProfile,
    hasRole,
    hasPermission,
    hasAccess
  };

  return (
    <AuthContext.Provider value={contextValue}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export default AuthContext;
</file>

<file path="src/features/auth/core/index.ts">
/**
 * Core auth module
 * 
 * Exports the core functionality of the auth feature
 */

export * from './AuthContext';
export * from './tokenManager';
</file>

<file path="src/features/auth/core/tokenManager.ts">
/**
 * Token management utilities for handling
 * authentication tokens securely.
 */

// Define storage keys for tokens
export const TOKEN_CONFIG = {
  ACCESS_TOKEN_KEY: 'accessToken',
  REFRESH_TOKEN_KEY: 'refreshToken',
  TOKEN_EXPIRY_KEY: 'tokenExpiry',
};

/**
 * Token manager for handling auth tokens
 */
export const tokenManager = {
  /**
   * Set the access token in storage
   */
  setToken: (token: string): void => {
    if (typeof window === 'undefined') return;
    
    // Store in standard location
    localStorage.setItem(TOKEN_CONFIG.ACCESS_TOKEN_KEY, token);
    
    // Store in legacy locations for compatibility
    localStorage.setItem('auth_token', token);
    localStorage.setItem('access_token', token);
  },
  
  /**
   * Get the current access token
   */
  getToken: (): string | null => {
    if (typeof window === 'undefined') return null;
    
    // Try all possible storage locations
    return (
      localStorage.getItem(TOKEN_CONFIG.ACCESS_TOKEN_KEY) ||
      localStorage.getItem('auth_token') ||
      localStorage.getItem('access_token')
    );
  },
  
  /**
   * Remove the access token
   */
  removeToken: (): void => {
    if (typeof window === 'undefined') return;
    
    // Remove from all possible storage locations
    localStorage.removeItem(TOKEN_CONFIG.ACCESS_TOKEN_KEY);
    localStorage.removeItem('auth_token');
    localStorage.removeItem('access_token');
  },
  
  /**
   * Set the refresh token
   */
  setRefreshToken: (token: string): void => {
    if (typeof window === 'undefined') return;
    
    localStorage.setItem(TOKEN_CONFIG.REFRESH_TOKEN_KEY, token);
    localStorage.setItem('refresh_token', token); // Legacy
  },
  
  /**
   * Get the current refresh token
   */
  getRefreshToken: (): string | null => {
    if (typeof window === 'undefined') return null;
    
    return (
      localStorage.getItem(TOKEN_CONFIG.REFRESH_TOKEN_KEY) ||
      localStorage.getItem('refresh_token')
    );
  },
  
  /**
   * Remove the refresh token
   */
  removeRefreshToken: (): void => {
    if (typeof window === 'undefined') return;
    
    localStorage.removeItem(TOKEN_CONFIG.REFRESH_TOKEN_KEY);
    localStorage.removeItem('refresh_token');
  },
  
  /**
   * Set the token expiry timestamp
   */
  setTokenExpiry: (expiryTime: number): void => {
    if (typeof window === 'undefined') return;
    
    localStorage.setItem(TOKEN_CONFIG.TOKEN_EXPIRY_KEY, expiryTime.toString());
    localStorage.setItem('token_expiry', expiryTime.toString()); // Legacy
  },
  
  /**
   * Get the token expiry timestamp
   */
  getTokenExpiry: (): number | null => {
    if (typeof window === 'undefined') return null;
    
    const expiry = (
      localStorage.getItem(TOKEN_CONFIG.TOKEN_EXPIRY_KEY) ||
      localStorage.getItem('token_expiry')
    );
    
    return expiry ? parseInt(expiry, 10) : null;
  },
  
  /**
   * Check if a valid token exists
   */
  hasToken: (): boolean => {
    const token = tokenManager.getToken();
    if (!token) return false;
    
    // Check expiry
    const expiry = tokenManager.getTokenExpiry();
    if (expiry && Date.now() >= expiry) {
      return false;
    }
    
    return true;
  },
  
  /**
   * Format a token for Authorization header
   */
  getAuthHeader: (): string | null => {
    const token = tokenManager.getToken();
    if (!token) return null;
    
    return `Bearer ${token}`;
  }
};

export default tokenManager;
</file>

<file path="src/features/auth/core/types.ts">
/**
 * Token Manager Interface
 */
export interface TokenManager {
  /**
   * Get the current access token with Bearer prefix
   */
  getToken(): string | null;
  
  /**
   * Set a new access token
   */
  setToken(token: string): void;
  
  /**
   * Set a new refresh token
   */
  setRefreshToken(token: string): void;
  
  /**
   * Get the stored refresh token
   */
  getStoredRefreshToken(): string | null;
  
  /**
   * Set token expiration timestamp
   */
  setTokenExpiry(expiryTime: number): void;
  
  /**
   * Remove all tokens from storage
   */
  removeToken(): void;
  
  /**
   * Check if a valid token exists
   */
  hasToken(): boolean;
  
  /**
   * Refresh the access token using the refresh token
   */
  refreshToken(): Promise<string | null>;
}
</file>

<file path="src/features/auth/hooks/index.ts">
export * from './useAuth';
export { useAuth as useSession } from './useAuth';
// Export the auth hooks with different names for legacy compatibility
</file>

<file path="src/features/auth/hooks/useAuth.ts">
import { useCallback } from 'react';
import { 
  useLoginMutation, 
  useLogoutMutation, 
  useRegisterMutation,
  usePasswordResetRequestMutation,
  usePasswordResetCompleteMutation
} from '../api/hooks/mutations';
import { useUserProfile } from '../api/hooks/queries';
import { tokenManager } from '../core';
import type { RegistrationData } from '../types';

/**
 * Main auth hook that combines all auth-related functionality
 */
export const useAuth = () => {
  const loginMutation = useLoginMutation();
  const logoutMutation = useLogoutMutation();
  const registerMutation = useRegisterMutation();
  const resetRequestMutation = usePasswordResetRequestMutation();
  const resetCompleteMutation = usePasswordResetCompleteMutation();
  const { data: profile, isLoading: isLoadingProfile } = useUserProfile();

  const login = useCallback(async (email: string, password: string) => {
    try {
      const response = await loginMutation.mutateAsync({ emailAddress: email, password });
      return response;
    } catch (error) {
      throw error;
    }
  }, [loginMutation]);

  const register = useCallback(async (data: RegistrationData) => {
    try {
      await registerMutation.mutateAsync(data);
    } catch (error) {
      throw error;
    }
  }, [registerMutation]);

  const logout = useCallback(async () => {
    try {
      await logoutMutation.mutateAsync();
    } catch (error) {
      console.error('Logout error:', error);
      // Still clear tokens even if server call fails
      tokenManager.removeToken();
      window.location.href = '/login';
    }
  }, [logoutMutation]);

  const requestPasswordReset = useCallback(async (email: string) => {
    try {
      const response = await resetRequestMutation.mutateAsync({ email });
      return response;
    } catch (error) {
      throw error;
    }
  }, [resetRequestMutation]);

  const resetPassword = useCallback(async (token: string, newPassword: string) => {
    try {
      await resetCompleteMutation.mutateAsync({ token, newPassword });
    } catch (error) {
      throw error;
    }
  }, [resetCompleteMutation]);

  const isAuthenticated = useCallback(() => {
    return tokenManager.hasToken();
  }, []);

  return {
    // User state
    user: profile,
    isLoadingUser: isLoadingProfile,
    isAuthenticated,

    // Auth actions
    login,
    register,
    logout,
    requestPasswordReset,
    resetPassword,

    // Loading states
    isLoggingIn: loginMutation.isPending,
    isRegistering: registerMutation.isPending,
    isLoggingOut: logoutMutation.isPending,
    isRequestingReset: resetRequestMutation.isPending,
    isResettingPassword: resetCompleteMutation.isPending,

    // Error states
    loginError: loginMutation.error,
    registerError: registerMutation.error,
    logoutError: logoutMutation.error,
    resetRequestError: resetRequestMutation.error,
    resetPasswordError: resetCompleteMutation.error
  };
};
</file>

<file path="src/features/auth/hooks/useAuthWithQuery.ts">
/**
 * Auth Hooks with Query Integration
 * 
 * Hooks for authentication and authorization using TanStack Query
 */
import { Permission, Role } from "@/types/auth";
import { redirect } from "next/navigation";
import { useEffect, useState } from "react";
import { queryClient } from '@/features/tanstack-query-api';
import { useUserProfile } from "../api/hooks/queries";
import authKeys from "../api/queryKeys";
import { useAuth as useBaseAuth } from './useAuth';
import { tokenManager } from '../core';

/**
 * Main hook for auth state and operations with query integration
 */
export function useAuth() {
  const baseAuth = useBaseAuth();

  // Use TanStack Query to fetch the user profile
  const { 
    data: extendedProfile, 
    isLoading: isProfileLoading, 
    refetch: refetchProfile
  } = useUserProfile();

  // Get roles from extended profile or base auth
  const getRoles = (): Role[] => {
    if (extendedProfile?.roles) {
      return extendedProfile.roles as Role[];
    }
    return baseAuth.user?.roles as Role[] || [];
  };

  // Get permissions from extended profile or base auth
  const getPermissions = (): Permission[] => {
    if (extendedProfile?.permissions) {
      return extendedProfile.permissions as Permission[];
    }
    return baseAuth.user?.permissions as Permission[] || [];
  };

  const hasPermission = (permission: Permission) => {
    const permissions = getPermissions();
    return permissions.includes(permission);
  };

  const hasRole = (role: Role) => {
    const roles = getRoles();
    return roles.includes(role);
  };

  const hasAccess = (requiredRoles?: Role[], requiredPermissions?: Permission[]) => {
    if (!requiredRoles?.length && !requiredPermissions?.length) {
      return true;
    }

    const hasRequiredRole = requiredRoles?.some(role => hasRole(role)) ?? true;
    const hasRequiredPermission = requiredPermissions?.every(permission =>
      hasPermission(permission)
    ) ?? true;

    return hasRequiredRole && hasRequiredPermission;
  };

  const refreshProfile = async () => {
    try {
      // Use the refetch function provided by useQuery
      const result = await refetchProfile();
      
      // Return the fresh data
      return result.data;
    } catch (error) {
      console.error('Failed to refresh user profile', error);
      throw error;
    }
  };

  const extendedLogout = async () => {
    try {
      // Clear query cache for auth-related queries
      queryClient.removeQueries({ queryKey: authKeys.me() });
      
      // Call base auth logout
      await baseAuth.logout();
    } catch (error) {
      console.error('Logout error:', error);
      // Still clear tokens even if server call fails
      tokenManager.removeToken();
      window.location.href = '/login';
    }
  };

  const combinedAuth = {
    ...baseAuth,
    user: extendedProfile ? {
      ...baseAuth.user,
      ...extendedProfile,
    } : baseAuth.user,
    isLoading: baseAuth.isLoggingIn || isProfileLoading,
    hasPermission,
    hasRole,
    hasAccess,
    refreshProfile,
    logout: extendedLogout,
  };

  return combinedAuth;
}

type BackendVerification = {
  error?: string;
  data?: {
    hasAccess: boolean;
  };
};

/**
 * Custom hook to protect components
 */
export function useRequireAuth(
  requiredRoles?: Role[],
  requiredPermissions?: Permission[],
  options?: { verifyOnBackend?: boolean }
) {
  const { hasAccess, isLoading, refreshProfile } = useAuth();
  const [backendVerified, setBackendVerified] = useState(false);
  const [isVerifying, setIsVerifying] = useState(false);

  useEffect(() => {
    // If backend verification is requested, check with the backend
    const verifyAccess = async () => {
      if (options?.verifyOnBackend && !isLoading && !backendVerified) {
        setIsVerifying(true);
        try {
          // Make API call to verify access
          const response = await fetch('/api/auth/verify-access', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              roles: requiredRoles || [],
              permissions: requiredPermissions || [],
            }),
          });

          const result = (await response.json()) as BackendVerification;
          
          if (result.error) {
            console.error('Error verifying access:', result.error);
            redirect("/unauthorized");
          }
          
          if (!result.data?.hasAccess) {
            redirect("/unauthorized");
          }
          
          setBackendVerified(true);
        } catch (error) {
          console.error('Failed to verify access with backend', error);
          redirect("/unauthorized");
        } finally {
          setIsVerifying(false);
        }
      }
    };

    verifyAccess();
  }, [isLoading, options?.verifyOnBackend, backendVerified, requiredRoles, requiredPermissions]);

  // First do client-side check
  if (isLoading || isVerifying) {
    return { isLoading: true };
  }

  // If not verifying with backend, just check client-side
  if (!options?.verifyOnBackend) {
    const hasRequiredAccess = hasAccess(requiredRoles, requiredPermissions);
    if (!hasRequiredAccess) {
      redirect("/unauthorized");
    }
  }

  return { isLoading: false, refreshProfile };
}
</file>

<file path="src/features/auth/hooks/useSession.ts">
/**
 * Custom hook for session management
 */
import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { useAuth } from '@/features/auth/hooks';
import { ROUTES } from '@/features/auth/config/auth';

interface UseSessionOptions {
  required?: boolean;
  redirectTo?: string;
  onUnauthenticated?: () => void;
}

export function useSession(options: UseSessionOptions = {}) {
  const { user, isLoadingUser, logout } = useAuth();
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);
  const router = useRouter();

  const {
    required = false,
    redirectTo = ROUTES.LOGIN,
    onUnauthenticated,
  } = options;

  useEffect(() => {
    // Still loading, don't do anything yet
    if (isLoadingUser) return;

    // Check authentication status
    const authenticated = !!user;
    setIsAuthenticated(authenticated);

    // Handle unauthenticated state
    if (required && !authenticated) {
      if (onUnauthenticated) {
        onUnauthenticated();
      } else if (redirectTo) {
        router.replace(redirectTo);
      }
    }
  }, [user, isLoadingUser, required, redirectTo, onUnauthenticated, router]);

  return {
    user,
    isLoadingUser,
    isAuthenticated,
    logout,
  };
}
</file>

<file path="src/features/auth/index.ts">
/**
 * Auth feature index file
 * 
 * This file exports all components, hooks, and utilities
 * from the auth feature for easy access from other parts
 * of the application.
 */

// Export core functionality
export * from './core/AuthContext';
export * from './core/tokenManager';

// Export API services
export * from './api/services/authService';

// Export types
export * from './types';

// Export constants 
// Note: RBAC permissions moved to @/features/rbac
export { AUTH_ENDPOINTS as apiRoutes } from './api/apiConfig';

// Export utility functions
export * from './utils';

// Export UI components
// Note: RBAC components moved to @/features/rbac
export * from './ui/protection/RequireAuth';
</file>

<file path="src/features/auth/lib/validation.ts">
/**
 * Password and authentication validation utilities
 */
import { PASSWORD_CONFIG } from '../config/auth';

interface PasswordValidationResult {
  isValid: boolean;
  errors: string[];
}

interface ValidationErrors {
  [key: string]: string;
}

/**
 * Password strength assessment
 */
export interface PasswordStrength {
  score: number; // 0-4 (very weak to very strong)
  label: 'very-weak' | 'weak' | 'medium' | 'strong' | 'very-strong';
  suggestions: string[];
}

/**
 * Validate password against security requirements
 */
export const validatePassword = (password: string): PasswordValidationResult => {
  const errors: string[] = [];

  // Check minimum length
  if (password.length < PASSWORD_CONFIG.minLength) {
    errors.push(`Password must be at least ${PASSWORD_CONFIG.minLength} characters long`);
  }

  // Check for uppercase letters
  if (PASSWORD_CONFIG.requireUppercase && !/[A-Z]/.test(password)) {
    errors.push('Password must contain at least one uppercase letter');
  }

  // Check for lowercase letters
  if (PASSWORD_CONFIG.requireLowercase && !/[a-z]/.test(password)) {
    errors.push('Password must contain at least one lowercase letter');
  }

  // Check for numbers
  if (PASSWORD_CONFIG.requireNumbers && !/\d/.test(password)) {
    errors.push('Password must contain at least one number');
  }

  // Check for special characters
  if (PASSWORD_CONFIG.requireSpecialChars && !/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    errors.push('Password must contain at least one special character');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

/**
 * Calculate password strength
 */
export const calculatePasswordStrength = (password: string): PasswordStrength => {
  let score = 0;
  const suggestions: string[] = [];

  // No score for empty passwords
  if (!password) {
    return {
      score: 0,
      label: 'very-weak',
      suggestions: ['Enter a password']
    };
  }

  // Length contribution (up to 2 points)
  if (password.length >= PASSWORD_CONFIG.minLength) {
    score += 1;
    if (password.length >= PASSWORD_CONFIG.minLength * 1.5) {
      score += 1;
    }
  } else {
    suggestions.push(`Make the password at least ${PASSWORD_CONFIG.minLength} characters long`);
  }

  // Character variety contribution (up to 2 points)
  let varietyScore = 0;
  
  if (/[A-Z]/.test(password)) varietyScore++;
  else suggestions.push('Add uppercase letters');
  
  if (/[a-z]/.test(password)) varietyScore++;
  else suggestions.push('Add lowercase letters');
  
  if (/\d/.test(password)) varietyScore++;
  else suggestions.push('Add numbers');
  
  if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) varietyScore++;
  else suggestions.push('Add special characters');

  score += Math.min(2, varietyScore / 2);

  // Determine label based on score
  let label: PasswordStrength['label'] = 'very-weak';
  if (score >= 3.5) label = 'very-strong';
  else if (score >= 3) label = 'strong';
  else if (score >= 2) label = 'medium';
  else if (score >= 1) label = 'weak';

  return {
    score,
    label,
    suggestions
  };
};

/**
 * Validate password reset form
 */
export const validatePasswordReset = (
  password: string, 
  confirmPassword: string
): ValidationErrors => {
  const errors: ValidationErrors = {};

  // Check password strength
  const passwordValidation = validatePassword(password);
  if (!passwordValidation.isValid) {
    errors.password = passwordValidation.errors[0];
    return errors;
  }

  // Check password confirmation
  if (password !== confirmPassword) {
    errors.confirmPassword = 'Passwords do not match';
  }

  return errors;
};

/**
 * Validate login form
 */
export const validateLogin = (
  email: string,
  password: string
): ValidationErrors => {
  const errors: ValidationErrors = {};

  // Basic email validation
  if (!email) {
    errors.email = 'Email is required';
  } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(email)) {
    errors.email = 'Invalid email address';
  }

  // Basic password validation
  if (!password) {
    errors.password = 'Password is required';
  }

  return errors;
};

/**
 * Validate registration form
 */
export const validateRegistration = (
  email: string,
  password: string,
  confirmPassword: string,
  firstName: string,
  lastName: string,
  acceptTerms: boolean
): ValidationErrors => {
  const errors: ValidationErrors = {};

  // Email validation
  if (!email) {
    errors.email = 'Email is required';
  } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(email)) {
    errors.email = 'Invalid email address';
  }

  // First name validation
  if (!firstName) {
    errors.firstName = 'First name is required';
  }

  // Last name validation
  if (!lastName) {
    errors.lastName = 'Last name is required';
  }

  // Password validation
  const passwordValidation = validatePassword(password);
  if (!passwordValidation.isValid) {
    errors.password = passwordValidation.errors[0];
  }

  // Password confirmation validation
  if (password !== confirmPassword) {
    errors.confirmPassword = 'Passwords do not match';
  }

  // Terms acceptance validation
  if (!acceptTerms) {
    errors.acceptTerms = 'You must accept the terms and conditions';
  }

  return errors;
};

export default {
  validatePassword,
  calculatePasswordStrength,
  validatePasswordReset,
  validateLogin,
  validateRegistration
};
</file>

<file path="src/features/auth/model/authState.ts">
/**
 * Auth State Management
 * 
 * This module provides utilities for managing auth state
 * including token storage and retrieval.
 */
import { User } from './types';

interface AuthStorageState {
  token: string;
  user?: User;
  expires?: string;
}

interface AuthStorage {
  state: AuthStorageState;
}

const AUTH_STORAGE_KEY = 'auth-storage';

/**
 * Get the current auth state from storage
 */
export function getAuthState(): AuthStorageState | null {
  if (typeof window === 'undefined') return null;
  
  try {
    const storageData = localStorage.getItem(AUTH_STORAGE_KEY);
    if (!storageData) return null;
    
    const parsedData = JSON.parse(storageData) as AuthStorage;
    return parsedData.state;
  } catch (error) {
    console.error('Failed to parse auth state:', error);
    return null;
  }
}

/**
 * Save auth state to storage
 */
export function saveAuthState(state: AuthStorageState): void {
  if (typeof window === 'undefined') return;
  
  try {
    localStorage.setItem(AUTH_STORAGE_KEY, JSON.stringify({ state }));
  } catch (error) {
    console.error('Failed to save auth state:', error);
  }
}

/**
 * Clear auth state from storage
 */
export function clearAuthState(): void {
  if (typeof window === 'undefined') return;
  
  try {
    localStorage.removeItem(AUTH_STORAGE_KEY);
  } catch (error) {
    console.error('Failed to clear auth state:', error);
  }
}

/**
 * Get the current auth token
 */
export function getAuthToken(): string | null {
  const state = getAuthState();
  return state?.token || null;
}

/**
 * Check if the user is authenticated based on storage
 */
export function isAuthenticated(): boolean {
  return !!getAuthToken();
}
</file>

<file path="src/features/auth/model/guards.ts">
import { ReactNode } from 'react';
import { Permission } from './types';

export interface GuardProps {
  children: ReactNode;
}

export interface FeatureGuardProps extends GuardProps {
  permissions: Permission[];
}
</file>

<file path="src/features/auth/model/store.ts">
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { User } from './types';

interface AuthState {
  token: string | null;
  user: User | null;
  isAuthenticated: boolean;
  login: (token: string) => void;
  logout: () => void;
  setUser: (user: User) => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      token: null,
      user: null,
      isAuthenticated: false,
      login: (token) => set({ token, isAuthenticated: true }),
      logout: () => set({ token: null, user: null, isAuthenticated: false }),
      setUser: (user) => set({ user }),
    }),
    { name: 'auth-storage' }
  )
);
</file>

<file path="src/features/auth/model/types.ts">
/**
 * Auth Types for UI components
 */

// Password reset form steps
export type ResetStep = 'request' | 'verification' | 'success';

// Password reset status
export type ResetStatus = 'validating' | 'valid' | 'invalid' | 'resetting' | 'success';
export interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  phoneNumber?: string;
  role: UserRole;
}

export type UserRole = 'admin' | 'pharmacist' | 'manager' | 'proprietor' | 'salesman';

export interface LoginCredentials {
  emailAddress: string;
  password: string;
  rememberMe?: boolean;
}

export interface LoginResponse {
  jwtToken: string;
  user: User;
}

export interface RegistrationData {
  username: string;
  email: string;
  password: string;
  confirmPassword?: string;
  firstName: string;
  lastName: string;
  phoneNumber?: string;
  userType?: string;
  acceptTerms?: boolean;
  additionalInfo?: Record<string, any>;
}

export interface RegisterResponse {
  user: User;
  verificationSent: boolean;
}

export interface PasswordRecoveryRequest {
  email: string;
}

export interface VerificationRequest {
  token: string;
  code?: string;
}

export interface ResetPasswordData {
  token: string;
  password: string;
  confirmPassword?: string;
}

export interface VerificationResponse {
  email: string;
  verified: boolean;
}

export interface AuthError {
  code: string;
  message: string;
  field?: string;
}

export type ResetStep = 'request' | 'verification' | 'success';
export type VerificationStatus = 'verifying' | 'success' | 'failed';
export type ResetStatus = 'validating' | 'valid' | 'invalid' | 'resetting' | 'success';

export interface PasswordStrength {
  score: number;
  label: 'very-weak' | 'weak' | 'medium' | 'strong' | 'very-strong';
  suggestions: string[];
}
</file>

<file path="src/features/auth/types/index.ts">
/**
 * Auth Types
 */

export type Role = 
  | 'ADMIN'
  | 'SUPER_ADMIN' 
  | 'MANAGER'
  | 'USER'
  | 'STUDENT'
  | 'GUEST'
  | string;

export type Permission = 
  | 'manage_users'
  | 'view_users'
  | 'manage_roles'
  | 'manage_permissions'
  | 'manage_pharmacists'
  | 'manage_pharmacy_managers'
  | 'manage_proprietors'
  | 'manage_salesmen'
  | 'manage_inventory'
  | 'view_products'
  | 'view_reports'
  | string;

export interface UserProfile {
  id: string | number;
  email: string;
  name?: string;
  firstName?: string;
  lastName?: string;
  roles?: Role[];
  permissions?: Permission[];
  avatar?: string;
  verified?: boolean;
  createdAt?: string;
  updatedAt?: string;
  metadata?: Record<string, any>;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface LoginResponse {
  accessToken: string;
  refreshToken?: string;
  user: UserProfile;
  expiresIn?: number;
}

export interface RefreshTokenRequest {
  refreshToken: string;
}

export interface TokenPayload {
  sub: string;
  email: string;
  roles?: Role[];
  permissions?: Permission[];
  exp: number;
  iat: number;
}

export interface RegistrationData {
  email: string;
  password: string;
  firstName?: string;
  lastName?: string;
  name?: string;
  phoneNumber?: string;
  acceptTerms: boolean;
}

export interface ForgotPasswordRequest {
  email: string;
}

export interface ResetPasswordRequest {
  token: string;
  newPassword: string;
}

export interface VerifyEmailRequest {
  token: string;
}

export interface ChangePasswordRequest {
  currentPassword: string;
  newPassword: string;
}

export interface UpdateProfileRequest {
  firstName?: string;
  lastName?: string;
  email?: string;
  phoneNumber?: string;
  avatar?: string;
}
</file>

<file path="src/features/auth/ui/auth-flow/AuthDebug.tsx">
'use client';

import { FC } from 'react';
import { useAuth } from '@/features/auth/hooks';

interface AuthDebugProps {
  showRoles?: boolean;
  showPermissions?: boolean;
}

/**
 * Debug component for displaying auth state
 * Only use in development, not in production
 */
export const AuthDebug: FC<AuthDebugProps> = ({
  showRoles = true,
  showPermissions = true,
}) => {
  const { user, isAuthenticated, isLoading } = useAuth();
  
  if (process.env.NODE_ENV === 'production') {
    return null;
  }
  
  if (isLoading) {
    return <div className="bg-yellow-100 p-4 rounded">Loading auth state...</div>;
  }
  
  if (!isAuthenticated) {
    return <div className="bg-red-100 p-4 rounded">Not authenticated</div>;
  }
  
  return (
    <div className="bg-blue-50 p-4 rounded border border-blue-200 text-sm font-mono">
      <h3 className="font-semibold mb-2">Auth Debug</h3>
      <div>
        <strong>User:</strong> {user?.email || 'No email'} (ID: {user?.id || 'unknown'})
      </div>
      
      {showRoles && user?.roles && (
        <div className="mt-2">
          <strong>Roles:</strong>
          <ul className="list-disc pl-5">
            {user.roles.map((role: string) => (
              <li key={role}>{role}</li>
            ))}
          </ul>
        </div>
      )}
      
      {showPermissions && user?.permissions && (
        <div className="mt-2">
          <strong>Permissions:</strong>
          <ul className="list-disc pl-5">
            {user.permissions.map((perm: string) => (
              <li key={perm}>{perm}</li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/features/auth/ui/auth-flow/index.ts">
export { AuthDebug } from './AuthDebug';
</file>

<file path="src/features/auth/ui/feedback/AuthLoading.tsx">
import { FC } from 'react';

interface AuthLoadingProps {
  message?: string;
}

export const AuthLoading: FC<AuthLoadingProps> = ({
  message = 'Authenticating...'
}) => {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="text-center">
        <div className="relative">
          {/* Spinner */}
          <div className="w-12 h-12 rounded-full border-4 border-blue-200 border-t-blue-600 animate-spin mb-4 mx-auto"></div>
        </div>
        <p className="text-gray-600 text-lg">
          {message}
        </p>
      </div>
    </div>
  );
};

// Create a specialized version for initial auth check
export const InitialAuthCheck: FC = () => (
  <AuthLoading message="Checking authentication..." />
);

// Create a loading state for permission checks
export const PermissionCheck: FC = () => (
  <AuthLoading message="Verifying permissions..." />
);

// Create a loading state for token refresh
export const TokenRefresh: FC = () => (
  <AuthLoading message="Refreshing session..." />
);

// Create a loading state for profile loading
export const ProfileLoading: FC = () => (
  <AuthLoading message="Loading profile..." />
);
</file>

<file path="src/features/auth/ui/feedback/index.ts">
export { 
  AuthLoading, 
  InitialAuthCheck, 
  PermissionCheck, 
  TokenRefresh, 
  ProfileLoading 
} from './AuthLoading';
export { Unauthorized } from './Unauthorized';
</file>

<file path="src/features/auth/ui/feedback/Unauthorized.tsx">
'use client';

import { FC } from 'react';
import { useRouter } from 'next/navigation';

interface UnauthorizedProps {
  message?: string;
  showBackButton?: boolean;
}

export const Unauthorized: FC<UnauthorizedProps> = ({
  message = "You don't have permission to access this page.",
  showBackButton = true,
}) => {
  const router = useRouter();

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="max-w-md w-full px-6 py-8 bg-white rounded-lg shadow-md">
        <div className="text-center">
          <h1 className="text-red-600 text-4xl font-bold mb-4">
            Access Denied
          </h1>
          <p className="text-gray-600 mb-6">
            {message}
          </p>
          <div className="flex flex-col space-y-4">
            {showBackButton && (
              <button
                onClick={() => router.back()}
                className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors"
              >
                Go Back
              </button>
            )}
            <button
              onClick={() => router.push('/dashboard')}
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
            >
              Return to Dashboard
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/features/auth/ui/index.ts">
// Export layout components
export * from './layout';

// Export login components
export * from './login';

// Export verification components
export * from './verification';
</file>

<file path="src/features/auth/ui/layout/AuthLayout.tsx">
"use client";

import { ReactNode } from 'react';

interface AuthLayoutProps {
  children: ReactNode;
}

export const AuthLayout = ({ children }: AuthLayoutProps) => {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50 px-4 py-12 relative overflow-hidden">
      {/* Animated background elements */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -left-40 w-80 h-80 bg-blue-200 rounded-full mix-blend-multiply opacity-70 animate-blob"></div>
        <div className="absolute top-0 -right-20 w-80 h-80 bg-purple-200 rounded-full mix-blend-multiply opacity-70 animate-blob animation-delay-2000"></div>
        <div className="absolute -bottom-40 left-20 w-80 h-80 bg-indigo-200 rounded-full mix-blend-multiply opacity-70 animate-blob animation-delay-4000"></div>
      </div>

      <div className="w-full max-w-md relative z-10">
        {children}
      </div>

      {/* Add keyframes animation styles */}
      <style jsx global>{`
        @keyframes blob {
          0% {
            transform: translate(0px, 0px) scale(1);
          }
          33% {
            transform: translate(30px, -50px) scale(1.1);
          }
          66% {
            transform: translate(-20px, 20px) scale(0.9);
          }
          100% {
            transform: translate(0px, 0px) scale(1);
          }
        }
        .animate-blob {
          animation: blob 7s infinite;
        }
        .animation-delay-2000 {
          animation-delay: 2s;
        }
        .animation-delay-4000 {
          animation-delay: 4s;
        }
        
        @media (prefers-reduced-motion) {
          .animate-blob {
            animation: none;
          }
        }
      `}</style>
    </div>
  );
};
</file>

<file path="src/features/auth/ui/layout/index.ts">
export * from './AuthLayout';
</file>

<file path="src/features/auth/ui/login/index.ts">
export * from './LoginForm';
</file>

<file path="src/features/auth/ui/login/LoginForm.tsx">
"use client";

import {useState} from 'react';
import {useRouter} from 'next/navigation';
import Link from 'next/link';
import {useAuth} from '@/shared/auth';

// Import shadcn UI components
import {Button} from '@/components/ui/button';
import {Input} from '@/components/ui/input';
import {Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle} from '@/components/ui/card';
import {Label} from '@/components/ui/label';
import {Separator} from '@/components/ui/separator';
import {Checkbox} from '@/components/ui/checkbox';

// Import icons
import {AlertCircle, Loader2, LockKeyhole, LogIn, Mail} from 'lucide-react';

export const LoginForm = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [rememberMe, setRememberMe] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  const router = useRouter();
  const {login} = useAuth();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setIsLoading(true);

    try {
      await login(email, password);
      router.push('/dashboard');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Invalid email or password');
    } finally {
      setIsLoading(false);
    }
  };

  const handleSocialLogin = (provider: 'google' | 'facebook') => {
    // For social login, we'll redirect to Keycloak's login page with the selected provider
    const KEYCLOAK_BASE_URL = process.env.NEXT_PUBLIC_KEYCLOAK_BASE_URL || 'http://localhost:8080';
    const KEYCLOAK_REALM = process.env.NEXT_PUBLIC_KEYCLOAK_REALM || 'pharmacyhub';
    const KEYCLOAK_CLIENT_ID = process.env.NEXT_PUBLIC_KEYCLOAK_CLIENT_ID || 'pharmacyhub-client';

    // Direct backend callback URL
    const redirectUri = encodeURIComponent(`${window.location.origin}/auth/callback`);
    const identityProvider = provider === 'google' ? 'google' : 'facebook';

    window.location.href = `${KEYCLOAK_BASE_URL}/realms/${KEYCLOAK_REALM}/protocol/openid-connect/auth?client_id=${KEYCLOAK_CLIENT_ID}&redirect_uri=${redirectUri}&response_type=code&scope=openid&kc_idp_hint=${identityProvider}`;
  };

  return (
    <Card className="border-none shadow-2xl backdrop-blur-sm bg-white/90">
      <CardHeader className="space-y-1 pb-6">
        <div className="flex justify-center mb-4">
          <div
            className="size-20 rounded-full bg-gradient-to-br from-blue-600 to-indigo-600 flex items-center justify-center p-5 shadow-lg">
            <LogIn className="text-white h-10 w-10"/>
          </div>
        </div>
        <CardTitle className="text-2xl font-bold text-center text-gray-800">
          Welcome to PharmacyHub
        </CardTitle>
        <CardDescription className="text-center text-gray-600">
          Sign in to access your pharmacy dashboard
        </CardDescription>
      </CardHeader>

      <CardContent>
        {error && (
          <div className="mb-6 p-3 rounded flex items-center space-x-2 bg-red-50 border border-red-200 text-red-700">
            <AlertCircle className="h-5 w-5 text-red-600 flex-shrink-0"/>
            <p className="text-sm">{error}</p>
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-5">
          <div className="space-y-2">
            <Label htmlFor="email" className="text-gray-700 font-medium">
              Email
            </Label>
            <div className="relative group">
              <Mail
                className="absolute left-3 top-3 h-4 w-4 text-gray-500 group-focus-within:text-blue-500 transition-colors"/>
              <Input
                id="email"
                type="email"
                placeholder="name@example.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className="pl-10 border-gray-300 bg-white focus:border-blue-500 transition-all"
                required
              />
            </div>
          </div>

          <div className="space-y-2">
            <div className="flex items-center justify-between">
              <Label htmlFor="password" className="text-gray-700 font-medium">
                Password
              </Label>
              <Link
                href="/forgot-password"
                className="text-xs font-medium text-blue-600 hover:text-blue-700 transition-colors"
              >
                Forgot password?
              </Link>
            </div>
            <div className="relative group">
              <LockKeyhole
                className="absolute left-3 top-3 h-4 w-4 text-gray-500 group-focus-within:text-blue-500 transition-colors"/>
              <Input
                id="password"
                type="password"
                placeholder="••••••••"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="pl-10 border-gray-300 bg-white focus:border-blue-500 transition-all"
                required
              />
            </div>
          </div>

          <div className="flex items-center space-x-2">
            <Checkbox
              id="remember_me"
              checked={rememberMe}
              onCheckedChange={(checked) => setRememberMe(!!checked)}
              className="text-blue-600 border-gray-300"
            />
            <Label
              htmlFor="remember_me"
              className="text-sm font-normal text-gray-600 cursor-pointer"
            >
              Remember me for 30 days
            </Label>
          </div>

          <Button
            type="submit"
            disabled={isLoading}
            className="w-full h-11 font-semibold bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 transition-all duration-300"
          >
            {isLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin"/>
                Signing in...
              </>
            ) : (
              'Sign in'
            )}
          </Button>
        </form>

        <div className="mt-8">
          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <Separator className="w-full"/>
            </div>
            <div className="relative flex justify-center text-xs uppercase">
              <span className="px-2 bg-white text-gray-500">
                Or continue with
              </span>
            </div>
          </div>

          <div className="mt-6 grid grid-cols-2 gap-3">
            <Button
              type="button"
              variant="outline"
              onClick={() => handleSocialLogin('google')}
              className="bg-white font-normal hover:bg-gray-50 transition-colors"
            >
              <svg className="mr-2 h-4 w-4" viewBox="0 0 24 24">
                <path
                  d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                  fill="#4285F4"
                />
                <path
                  d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                  fill="#34A853"
                />
                <path
                  d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                  fill="#FBBC05"
                />
                <path
                  d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                  fill="#EA4335"
                />
                <path d="M1 1h22v22H1z" fill="none"/>
              </svg>
              Google
            </Button>
            <Button
              type="button"
              variant="outline"
              onClick={() => handleSocialLogin('facebook')}
              className="bg-white font-normal hover:bg-gray-50 transition-colors"
            >
              <svg className="mr-2 h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path fill="#1877F2"
                      d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/>
              </svg>
              Facebook
            </Button>
          </div>
        </div>
      </CardContent>

      <CardFooter className="flex flex-col items-center justify-center p-6 border-t bg-gray-50 rounded-b-lg">
        <p className="text-sm text-gray-600">
          Don&apos;t have an account?{' '}
          <Link
            href="/register"
            className="font-medium text-blue-600 hover:text-blue-700 transition-colors"
          >
            Sign up now
          </Link>
        </p>
      </CardFooter>
    </Card>
  );
};
</file>

<file path="src/features/auth/ui/password-recovery/ForgotPasswordForm.tsx">
"use client";

import { useState } from 'react';
import Link from 'next/link';
import { usePasswordResetRequestMutation as useRequestPasswordReset } from '@/features/auth/api/mutations';
import { ResetStep } from '../../model/types';

// Import shadcn UI components
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Label } from '@/components/ui/label';

// Import icons
import { 
  KeyRound, 
  Mail, 
  AlertCircle, 
  Loader2,
  ArrowRight,
  CheckCircle,
  Lock
} from 'lucide-react';

export const ForgotPasswordForm = () => {
  const [email, setEmail] = useState('');
  const [verificationCode, setVerificationCode] = useState('');
  const [newPassword, setNewPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');
  const [currentStep, setCurrentStep] = useState<ResetStep>('request');
  
  const requestResetMutation = useRequestPasswordReset();

  const handleRequestReset = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    if (!email) {
      setError('Please enter your email address');
      return;
    }

    try {
      await requestResetMutation.mutateAsync({ email });
      setCurrentStep('verification');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to send reset email');
    }
  };

  const handleVerifyCode = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    if (!verificationCode) {
      setError('Please enter the verification code');
      return;
    }

    if (!newPassword || !confirmPassword) {
      setError('Please enter and confirm your new password');
      return;
    }

    if (newPassword !== confirmPassword) {
      setError('Passwords do not match');
      return;
    }

    try {
      // In a real implementation, we would call an API endpoint here
      // For now, we'll just simulate a successful verification
      setCurrentStep('success');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to reset password');
    }
  };

  const renderRequestStep = () => (
    <form onSubmit={handleRequestReset} className="space-y-6">
      <div className="space-y-2">
        <Label htmlFor="email" className="text-gray-700">
          Email address
        </Label>
        <div className="relative">
          <Mail className="absolute left-3 top-3 h-4 w-4 text-gray-500" />
          <Input
            id="email"
            type="email"
            placeholder="Enter your email address"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            className="pl-10 border-gray-300 bg-white"
            required
          />
        </div>
        <p className="text-xs text-gray-500">
          We'll send a password reset link to this email address
        </p>
      </div>

      <Button
        type="submit"
        disabled={requestResetMutation.isPending}
        className="w-full bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700"
      >
        {requestResetMutation.isPending ? (
          <>
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            Sending reset link...
          </>
        ) : (
          <>
            Send reset link
            <ArrowRight className="ml-2 h-4 w-4" />
          </>
        )}
      </Button>
    </form>
  );

  const renderVerificationStep = () => (
    <form onSubmit={handleVerifyCode} className="space-y-6">
      <div className="bg-blue-50 p-4 rounded-lg border border-blue-100 mb-4">
        <p className="text-sm text-blue-800">
          We&apos;ve sent a verification code to <strong>{email}</strong>. 
          Please check your inbox and enter the code below.
        </p>
      </div>
      
      <div className="space-y-4">
        <div className="space-y-2">
          <Label htmlFor="verification-code" className="text-gray-700">
            Verification code
          </Label>
          <div className="relative">
            <KeyRound className="absolute left-3 top-3 h-4 w-4 text-gray-500" />
            <Input
              id="verification-code"
              type="text"
              placeholder="Enter verification code"
              value={verificationCode}
              onChange={(e) => setVerificationCode(e.target.value)}
              className="pl-10 border-gray-300 bg-white"
              required
            />
          </div>
        </div>
        
        <div className="space-y-2">
          <Label htmlFor="new-password" className="text-gray-700">
            New password
          </Label>
          <div className="relative">
            <Lock className="absolute left-3 top-3 h-4 w-4 text-gray-500" />
            <Input
              id="new-password"
              type="password"
              placeholder="Enter new password"
              value={newPassword}
              onChange={(e) => setNewPassword(e.target.value)}
              className="pl-10 border-gray-300 bg-white"
              required
            />
          </div>
        </div>
        
        <div className="space-y-2">
          <Label htmlFor="confirm-password" className="text-gray-700">
            Confirm new password
          </Label>
          <div className="relative">
            <Lock className="absolute left-3 top-3 h-4 w-4 text-gray-500" />
            <Input
              id="confirm-password"
              type="password"
              placeholder="Confirm new password"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              className="pl-10 border-gray-300 bg-white"
              required
            />
          </div>
        </div>
      </div>

      <div className="pt-2">
        <Button
          type="submit"
          className="w-full bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700"
        >
          Reset password
        </Button>
        
        <div className="mt-4 text-center">
          <button
            type="button"
            onClick={() => setCurrentStep('request')}
            className="text-sm text-blue-600 hover:text-blue-700"
          >
            Different email? Go back
          </button>
        </div>
      </div>
    </form>
  );

  const renderSuccessStep = () => (
    <div className="space-y-6 text-center">
      <div className="flex justify-center">
        <div className="rounded-full bg-green-100 p-3">
          <CheckCircle className="h-10 w-10 text-green-600" />
        </div>
      </div>
      
      <div className="space-y-2">
        <h3 className="text-xl font-medium text-gray-900">Password reset successful</h3>
        <p className="text-sm text-gray-600">
          Your password has been reset successfully. You can now log in with your new password.
        </p>
      </div>
      
      <Button
        onClick={() => window.location.href = '/login'}
        className="bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700"
      >
        Return to login
      </Button>
    </div>
  );

  const renderCurrentStep = () => {
    switch (currentStep) {
      case 'request':
        return renderRequestStep();
      case 'verification':
        return renderVerificationStep();
      case 'success':
        return renderSuccessStep();
      default:
        return renderRequestStep();
    }
  };

  return (
    <Card className="border-none shadow-2xl backdrop-blur-sm bg-white/90">
      <CardHeader className="space-y-1 pb-6">
        <div className="flex justify-center mb-4">
          <div className="size-16 rounded-full bg-gradient-to-br from-blue-600 to-indigo-600 flex items-center justify-center p-4 shadow-lg">
            <KeyRound className="text-white h-8 w-8" />
          </div>
        </div>
        <CardTitle className="text-2xl font-bold text-center text-gray-800">
          {currentStep === 'success' ? 'Password Reset Complete' : 'Reset your password'}
        </CardTitle>
        <CardDescription className="text-center text-gray-600">
          {currentStep === 'request' && "Enter your email to receive a password reset link"}
          {currentStep === 'verification' && "Enter the verification code and set a new password"}
          {currentStep === 'success' && "You&apos;ve successfully reset your password"}
        </CardDescription>
      </CardHeader>

      <CardContent>
        {error && (
          <div className="mb-6 p-3 rounded flex items-center space-x-2 bg-red-50 border border-red-200 text-red-700">
            <AlertCircle className="h-5 w-5 text-red-600 flex-shrink-0" />
            <p className="text-sm">{error}</p>
          </div>
        )}

        {renderCurrentStep()}
      </CardContent>

      <CardFooter className="flex flex-col items-center justify-center p-6 border-t bg-gray-50 rounded-b-lg">
        <p className="text-sm text-gray-600">
          {currentStep !== 'success' && (
            <>
              Remember your password?{' '}
              <Link
                href="/login"
                className="font-medium text-blue-600 hover:text-blue-700 transition-colors"
              >
                Back to login
              </Link>
            </>
          )}
        </p>
      </CardFooter>
    </Card>
  );
};
</file>

<file path="src/features/auth/ui/password-recovery/ResetPasswordForm.tsx">
"use client";

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import { 
  usePasswordResetCompleteMutation as useResetPassword 
} from '@/features/auth/api/mutations';
import { ResetStatus } from '../../model/types';
import { calculatePasswordStrength, validatePasswordReset } from '../../lib/validation';

// Mock validate token function since it doesn't exist in our mutations
const useValidateResetToken = () => {
  return {
    mutateAsync: async (token: string) => {
      // Simulate API call to validate token
      return { valid: true };
    },
    isPending: false
  };
};

// Import shadcn UI components
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Label } from '@/components/ui/label';

// Import icons
import { 
  AlertCircle, 
  Loader2,
  CheckCircle,
  Lock,
  ShieldCheck,
  XCircle
} from 'lucide-react';

interface ResetPasswordFormProps {
  token: string;
}

export const ResetPasswordForm = ({ token }: ResetPasswordFormProps) => {
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');
  const [status, setStatus] = useState<ResetStatus>('validating');
  const [passwordStrength, setPasswordStrength] = useState(calculatePasswordStrength(''));
  
  const router = useRouter();
  const validateTokenMutation = useValidateResetToken();
  const resetPasswordMutation = useResetPassword();

  useEffect(() => {
    const validateToken = async () => {
      try {
        const result = await validateTokenMutation.mutateAsync(token);
        setStatus(result.valid ? 'valid' : 'invalid');
      } catch (err) {
        setStatus('invalid');
        setError('Invalid or expired reset link');
      }
    };
    
    validateToken();
  }, [token, validateTokenMutation]);

  const handlePasswordChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newPassword = e.target.value;
    setPassword(newPassword);
    setPasswordStrength(calculatePasswordStrength(newPassword));
  };

  const handleResetPassword = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    // Password validation
    const validationErrors = validatePasswordReset(password, confirmPassword);
    if (Object.keys(validationErrors).length > 0) {
      setError(Object.values(validationErrors)[0]);
      return;
    }

    try {
      setStatus('resetting');
      await resetPasswordMutation.mutateAsync({ token, password });
      setStatus('success');
    } catch (err) {
      setStatus('valid');
      setError(err instanceof Error ? err.message : 'Failed to reset password');
    }
  };

  const getPasswordStrengthColor = () => {
    switch(passwordStrength.label) {
      case 'very-weak': return 'bg-red-500';
      case 'weak': return 'bg-orange-500';
      case 'medium': return 'bg-yellow-500';
      case 'strong': return 'bg-green-500';
      case 'very-strong': return 'bg-green-600';
      default: return 'bg-gray-200';
    }
  };

  const renderContent = () => {
    switch (status) {
      case 'validating':
        return (
          <div className="text-center py-8">
            <Loader2 className="h-12 w-12 text-blue-600 mx-auto animate-spin" />
            <p className="mt-4 text-gray-600">Validating your reset link...</p>
          </div>
        );
        
      case 'invalid':
        return (
          <div className="text-center py-8 space-y-6">
            <div className="flex justify-center">
              <div className="rounded-full bg-red-100 p-3">
                <XCircle className="h-12 w-12 text-red-600" />
              </div>
            </div>
            <div className="space-y-2">
              <h3 className="text-xl font-medium text-gray-900">Invalid Reset Link</h3>
              <p className="text-sm text-gray-600">
                This password reset link is invalid or has expired. Please request a new password reset link.
              </p>
            </div>
            <Button
              onClick={() => router.push('/forgot-password')}
              className="bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700"
            >
              Request New Link
            </Button>
          </div>
        );
        
      case 'valid':
        return (
          <form onSubmit={handleResetPassword} className="space-y-6">
            <div className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="password" className="text-gray-700 flex items-center">
                  <ShieldCheck className="h-4 w-4 mr-1.5 text-blue-600" />
                  New password
                </Label>
                <div className="relative">
                  <Lock className="absolute left-3 top-3 h-4 w-4 text-gray-500" />
                  <Input
                    id="password"
                    type="password"
                    placeholder="Enter new password"
                    value={password}
                    onChange={handlePasswordChange}
                    className="pl-10 border-gray-300 bg-white"
                    required
                  />
                </div>
                
                {/* Password strength indicator */}
                <div className="mt-2">
                  <div className="flex items-center">
                    <div className="flex-1 h-2 bg-gray-200 rounded-full overflow-hidden">
                      <div
                        className={`h-full rounded-full transition-all ${getPasswordStrengthColor()} ${
                          passwordStrength.label === 'very-weak' ? 'w-1/5' :
                          passwordStrength.label === 'weak' ? 'w-2/5' :
                          passwordStrength.label === 'medium' ? 'w-3/5' :
                          passwordStrength.label === 'strong' ? 'w-4/5' : 'w-full'
                        }`}
                      />
                    </div>
                    <span className="ml-2 text-xs font-medium text-gray-500 min-w-20">
                      {passwordStrength.label.replace(/-/g, ' ')}
                    </span>
                  </div>
                  {passwordStrength.suggestions.length > 0 && (
                    <p className="mt-1 text-xs text-gray-500">
                      {passwordStrength.suggestions[0]}
                    </p>
                  )}
                </div>
              </div>
              
              <div className="space-y-2">
                <Label htmlFor="confirm-password" className="text-gray-700">
                  Confirm new password
                </Label>
                <div className="relative">
                  <Lock className="absolute left-3 top-3 h-4 w-4 text-gray-500" />
                  <Input
                    id="confirm-password"
                    type="password"
                    placeholder="Confirm new password"
                    value={confirmPassword}
                    onChange={(e) => setConfirmPassword(e.target.value)}
                    className="pl-10 border-gray-300 bg-white"
                    required
                  />
                </div>
              </div>
            </div>

            <Button
              type="submit"
              disabled={resetPasswordMutation.isPending}
              className="w-full bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700"
            >
              {resetPasswordMutation.isPending ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Updating password...
                </>
              ) : (
                'Reset password'
              )}
            </Button>
          </form>
        );
        
      case 'success':
        return (
          <div className="text-center py-8 space-y-6">
            <div className="flex justify-center">
              <div className="rounded-full bg-green-100 p-3">
                <CheckCircle className="h-12 w-12 text-green-600" />
              </div>
            </div>
            <div className="space-y-2">
              <h3 className="text-xl font-medium text-gray-900">Password Updated Successfully</h3>
              <p className="text-sm text-gray-600">
                Your password has been reset successfully. You can now log in with your new password.
              </p>
            </div>
            <Button
              onClick={() => router.push('/login')}
              className="bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700"
            >
              Log in
            </Button>
          </div>
        );
        
      default:
        return null;
    }
  };

  return (
    <Card className="border-none shadow-2xl backdrop-blur-sm bg-white/90">
      <CardHeader className="space-y-1 pb-6">
        <div className="flex justify-center mb-4">
          <div className="size-16 rounded-full bg-gradient-to-br from-blue-600 to-indigo-600 flex items-center justify-center p-4 shadow-lg">
            <ShieldCheck className="text-white h-8 w-8" />
          </div>
        </div>
        <CardTitle className="text-2xl font-bold text-center text-gray-800">
          {status === 'success' ? 'Password Updated' : 'Reset Your Password'}
        </CardTitle>
        <CardDescription className="text-center text-gray-600">
          {status === 'validating' && "Verifying your reset link..."}
          {status === 'valid' && "Create a new secure password for your account"}
          {status === 'invalid' && "This link has expired or is invalid"}
          {status === 'resetting' && "Processing your request..."}
          {status === 'success' && "Your password has been updated successfully"}
        </CardDescription>
      </CardHeader>

      <CardContent>
        {error && (
          <div className="mb-6 p-3 rounded flex items-center space-x-2 bg-red-50 border border-red-200 text-red-700">
            <AlertCircle className="h-5 w-5 text-red-600 flex-shrink-0" />
            <p className="text-sm">{error}</p>
          </div>
        )}

        {renderContent()}
      </CardContent>

      {(status !== 'success' && status !== 'invalid') && (
        <CardFooter className="flex flex-col items-center justify-center p-6 border-t bg-gray-50 rounded-b-lg">
          <p className="text-sm text-gray-600">
            Remember your password?{' '}
            <Link
              href="/login"
              className="font-medium text-blue-600 hover:text-blue-700 transition-colors"
            >
              Back to login
            </Link>
          </p>
        </CardFooter>
      )}
    </Card>
  );
};
</file>

<file path="src/features/auth/ui/protection/AuthGuard.tsx">
'use client';

import React from 'react';
import { RequireAuth } from './RequireAuth';

interface AuthGuardProps {
  children: React.ReactNode;
  fallback?: React.ReactNode;
  requiredRoles?: string[];
  requiredPermissions?: string[];
  requireAll?: boolean;
}

/**
 * Route guard that combines authentication and authorization
 * 
 * Redirects to login if user is not authenticated
 * Redirects to unauthorized if user is authenticated but doesn't have required access
 */
export const AuthGuard: React.FC<AuthGuardProps> = ({
  children,
  fallback,
  requiredRoles = [],
  requiredPermissions = [],
  requireAll = true
}) => {
  return (
    <RequireAuth
      requiredRoles={requiredRoles}
      requiredPermissions={requiredPermissions}
      requireAll={requireAll}
      fallback={fallback}
    >
      {children}
    </RequireAuth>
  );
};

export default AuthGuard;
</file>

<file path="src/features/auth/ui/protection/index.ts">
/**
 * Auth Protection Components
 */
export * from './RequireAuth';
export * from './AuthGuard';
</file>

<file path="src/features/auth/ui/protection/RequireAuth.tsx">
/**
 * Authentication guard component
 * 
 * This component protects routes by checking if a user is authenticated
 * and redirecting to the login page if not.
 */
import React from 'react';
import { useRouter } from 'next/navigation';
import { useAuth } from '../../core/AuthContext';
import { useAccess } from '@/features/rbac/hooks';

interface RequireAuthProps {
  children: React.ReactNode;
  fallback?: React.ReactNode;
  
  // RBAC parameters
  requiredRoles?: string[];
  requiredPermissions?: string[];
  requireAll?: boolean;
}

/**
 * Component that redirects to login if user is not authenticated
 * or if user doesn't have required roles or permissions
 */
export const RequireAuth: React.FC<RequireAuthProps> = ({ 
  children, 
  fallback = null,
  requiredRoles = [],
  requiredPermissions = [],
  requireAll = true
}) => {
  const { isAuthenticated, isLoading } = useAuth();
  const { hasAccess } = useAccess();
  const router = useRouter();
  
  // Check if user has the required access
  const hasRequiredAccess = React.useMemo(() => {
    // If no roles or permissions are required, just check auth
    if (requiredRoles.length === 0 && requiredPermissions.length === 0) {
      return isAuthenticated;
    }
    
    // Otherwise, check if user has the required roles and permissions
    return isAuthenticated && hasAccess(requiredRoles, requiredPermissions, { requireAll });
  }, [isAuthenticated, hasAccess, requiredRoles, requiredPermissions, requireAll]);

  React.useEffect(() => {
    if (!isLoading) {
      if (!isAuthenticated) {
        // Save the current URL to redirect back after login
        if (typeof window !== 'undefined') {
          const currentPath = window.location.pathname;
          sessionStorage.setItem('redirectAfterLogin', currentPath);
        }
        
        // Redirect to login page
        router.push('/login');
      } else if (!hasRequiredAccess) {
        // User is authenticated but doesn't have required access
        // Redirect to unauthorized page or home
        router.push('/unauthorized');
      }
    }
  }, [isAuthenticated, isLoading, hasRequiredAccess, router]);

  // Show nothing while checking auth
  if (isLoading) {
    return null;
  }

  // Show fallback or children based on auth and access status
  return (isAuthenticated && hasRequiredAccess) ? <>{children}</> : <>{fallback}</>;
};

export default RequireAuth;
</file>

<file path="src/features/auth/ui/protection/types.ts">
import { ReactNode } from 'react';
import { Permission } from '@/types/auth';

export interface GuardProps {
  children: ReactNode;
}

export interface FeatureGuardProps extends GuardProps {
  permissions: Permission[];
}

export interface AuthGuardProps {
  children: ReactNode;
  requiredRoles?: string[];
  requiredPermissions?: string[];
  loadingComponent?: ReactNode;
  unauthorizedComponent?: ReactNode;
}
</file>

<file path="src/features/auth/ui/rbac/index.ts">
/**
 * RBAC UI Components (Deprecated)
 * 
 * These components are maintained for backward compatibility.
 * Please use the new components from @/features/rbac instead.
 */

export * from './PermissionGuard.deprecated';
export * from './PermissionCheck.deprecated';
export * from './RoleGuards.deprecated';
</file>

<file path="src/features/auth/ui/register/RegisterForm.tsx">
"use client";

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import { useAuth, RegistrationData, USER_TYPE_PERMISSIONS } from '@/shared/auth';
import { calculatePasswordStrength } from '../../lib/validation';

// Import shadcn UI components
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Separator } from '@/components/ui/separator';
import { Checkbox } from '@/components/ui/checkbox';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';

// Import icons
import { 
  User, 
  Mail, 
  Lock, 
  Phone, 
  AlertCircle, 
  Loader2,
  UserPlus,
  ShieldCheck,
  CheckCircle2,
  ChevronRight,
  ChevronLeft
} from 'lucide-react';

type FormStep = 'account' | 'personal' | 'confirmation';

const initialFormData = {
  username: '',
  email: '',
  password: '',
  confirmPassword: '',
  firstName: '',
  lastName: '',
  phoneNumber: '',
  userType: 'GENERAL_USER',
  acceptTerms: false
};

// Helper function to validate form data
const validateRegistrationForm = (data: typeof initialFormData) => {
  const errors: Partial<Record<keyof typeof initialFormData, string>> = {};
  
  // Email validation
  if (!data.email) {
    errors.email = 'Email is required';
  } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(data.email)) {
    errors.email = 'Invalid email address';
  }
  
  // Username validation
  if (!data.username) {
    errors.username = 'Username is required';
  } else if (data.username.length < 4) {
    errors.username = 'Username must be at least 4 characters';
  }
  
  // Password validation
  if (!data.password) {
    errors.password = 'Password is required';
  } else if (data.password.length < 8) {
    errors.password = 'Password must be at least 8 characters';
  }
  
  // Confirm password validation
  if (data.password !== data.confirmPassword) {
    errors.confirmPassword = 'Passwords do not match';
  }
  
  // Name validation
  if (!data.firstName) {
    errors.firstName = 'First name is required';
  }
  
  if (!data.lastName) {
    errors.lastName = 'Last name is required';
  }
  
  // Phone validation
  if (data.phoneNumber && !/^\+?\d{10,15}$/.test(data.phoneNumber.replace(/[\s()-]/g, ''))) {
    errors.phoneNumber = 'Invalid phone number';
  }
  
  // Terms validation
  if (!data.acceptTerms) {
    errors.acceptTerms = 'You must accept the Terms and Privacy Policy';
  }
  
  return errors;
};

export const RegisterForm = () => {
  const [formData, setFormData] = useState(initialFormData);
  const [errors, setErrors] = useState<Partial<Record<keyof typeof initialFormData, string>>>({});
  const [currentStep, setCurrentStep] = useState<FormStep>('account');
  const [passwordStrength, setPasswordStrength] = useState(calculatePasswordStrength(''));
  const [showSuccessAnimation, setShowSuccessAnimation] = useState(false);
  
  const { register, login, connectivityStatus = { hasIssues: false } } = useAuth();
  const router = useRouter();

  const validateStep = (step: FormStep): boolean => {
    let fieldsToValidate: Array<keyof typeof initialFormData> = [];
    
    switch(step) {
      case 'account':
        fieldsToValidate = ['username', 'email', 'password', 'confirmPassword'];
        break;
      case 'personal':
        fieldsToValidate = ['firstName', 'lastName', 'phoneNumber', 'userType'];
        break;
      case 'confirmation':
        fieldsToValidate = ['acceptTerms'];
        break;
    }
    
    // Run validation on all fields
    const validationErrors = validateRegistrationForm(formData);
    
    // Filter validation errors to only include fields relevant to this step
    const stepErrors: Partial<Record<keyof typeof initialFormData, string>> = {};
    fieldsToValidate.forEach(field => {
      if (validationErrors[field]) {
        stepErrors[field] = validationErrors[field];
      }
    });
    
    setErrors(stepErrors);
    return Object.keys(stepErrors).length === 0;
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));

    // Update password strength when password changes
    if (name === 'password') {
      setPasswordStrength(calculatePasswordStrength(value));
    }

    // Clear error when field is modified
    if (errors[name as keyof typeof initialFormData]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };

  const handleSelectChange = (name: string, value: string) => {
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const nextStep = () => {
    if (currentStep === 'account' && validateStep('account')) {
      setCurrentStep('personal');
    } else if (currentStep === 'personal' && validateStep('personal')) {
      setCurrentStep('confirmation');
    }
  };

  const prevStep = () => {
    if (currentStep === 'personal') {
      setCurrentStep('account');
    } else if (currentStep === 'confirmation') {
      setCurrentStep('personal');
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!validateStep('confirmation')) {
      return;
    }

    try {
      // Prepare data for API
      const registrationData: RegistrationData = {
        username: formData.username,
        email: formData.email,
        password: formData.password,
        firstName: formData.firstName,
        lastName: formData.lastName,
        userType: formData.userType as any,
        phoneNumber: formData.phoneNumber || undefined,
      };
      
      await register(registrationData);
      
      // Show success animation
      setShowSuccessAnimation(true);
      
      // Delay login to show success animation
      setTimeout(async () => {
        try {
          // Automatically log in after successful registration
          await login(formData.email, formData.password);
          router.push('/dashboard');
        } catch (loginErr) {
          console.error("Auto-login failed", loginErr);
          // If auto-login fails, redirect to login page
          router.push('/login');
        }
      }, 1500);
    } catch (err) {
      console.error("Registration failed", err);
      
      // Determine user-friendly error message based on error
      let errorMessage = 'Registration failed';
      
      if (err instanceof Error) {
        const errorText = err.message.toLowerCase();
        
        if (errorText.includes('failed to fetch') || 
            errorText.includes('typeerror') || 
            errorText.includes('network') ||
            errorText.includes('cors')) {
          errorMessage = 'Could not connect to authentication server. Please check your network connection or try again later.';
        } else if (errorText.includes('already exists')) {
          errorMessage = 'An account with this username or email already exists.';
        } else if (errorText.includes('admin token') || errorText.includes('authentication')) {
          errorMessage = 'Authentication service error. Our team has been notified. Please try again later.';
        } else if (errorText.includes('timeout')) {
          errorMessage = 'Registration timed out. Please check your internet connection and try again.';
        } else {
          // Use the original error message
          errorMessage = err.message;
        }
      }
      
      setErrors({
        email: errorMessage
      });
      setCurrentStep('account'); // Return to first step on error
    }
  };
  
  const getPasswordStrengthColor = () => {
    switch(passwordStrength.label) {
      case 'very-weak': return 'bg-red-500';
      case 'weak': return 'bg-orange-500';
      case 'medium': return 'bg-yellow-500';
      case 'strong': return 'bg-green-500';
      case 'very-strong': return 'bg-green-600';
      default: return 'bg-gray-200';
    }
  };

  const renderStepIndicator = () => (
    <div className="flex justify-between items-center w-full mb-8 relative">
      <div className="absolute h-1 bg-gray-200 left-0 top-1/2 transform -translate-y-1/2 w-full z-0" />
      
      {['account', 'personal', 'confirmation'].map((step, index) => {
        const isActive = currentStep === step;
        const isCompleted = 
          (step === 'account' && ['personal', 'confirmation'].includes(currentStep)) ||
          (step === 'personal' && currentStep === 'confirmation');
        
        return (
          <div key={step} className="z-10 flex flex-col items-center">
            <div 
              className={`flex items-center justify-center size-10 rounded-full border-2 transition-all ${
                isActive 
                  ? 'border-blue-600 bg-blue-100 text-blue-700'
                  : isCompleted
                    ? 'border-green-500 bg-green-500 text-white' 
                    : 'border-gray-300 bg-white text-gray-400'
              }`}
            >
              {isCompleted ? (
                <CheckCircle2 className="h-5 w-5" />
              ) : (
                <span className="text-sm font-medium">{index + 1}</span>
              )}
            </div>
            <span className={`text-xs mt-2 font-medium ${
              isActive ? 'text-blue-700' :
              isCompleted ? 'text-green-600' : 'text-gray-500'
            }`}>
              {step.charAt(0).toUpperCase() + step.slice(1)}
            </span>
          </div>
        );
      })}
    </div>
  );

  const renderAccountStep = () => (
    <div className="space-y-6">
      <div className="space-y-2">
        <Label htmlFor="username" className={errors.username ? "text-red-500" : "text-gray-700"}>
          Username
        </Label>
        <div className="relative">
          <User className="absolute left-3 top-3 h-4 w-4 text-gray-500" />
          <Input
            id="username"
            name="username"
            type="text"
            autoComplete="username"
            placeholder="johndoe"
            value={formData.username}
            onChange={handleChange}
            className={`pl-10 border-gray-300 bg-white ${errors.username ? "border-red-500 ring-red-500" : ""}`}
            required
          />
          {errors.username && (
            <p className="mt-1 text-sm text-red-500">{errors.username}</p>
          )}
        </div>
      </div>
      
      <div className="space-y-2">
        <Label htmlFor="email" className={errors.email ? "text-red-500" : "text-gray-700"}>
          Email address
        </Label>
        <div className="relative">
          <Mail className="absolute left-3 top-3 h-4 w-4 text-gray-500" />
          <Input
            id="email"
            name="email"
            type="email"
            autoComplete="email"
            placeholder="name@example.com"
            value={formData.email}
            onChange={handleChange}
            className={`pl-10 border-gray-300 bg-white ${errors.email ? "border-red-500 ring-red-500" : ""}`}
            required
          />
          {errors.email && (
            <p className="mt-1 text-sm text-red-500">{errors.email}</p>
          )}
        </div>
      </div>
      
      <div className="space-y-2">
        <Label htmlFor="password" className={errors.password ? "text-red-500" : "text-gray-700"}>
          Password
        </Label>
        <div className="relative">
          <Lock className="absolute left-3 top-3 h-4 w-4 text-gray-500" />
          <Input
            id="password"
            name="password"
            type="password"
            placeholder="••••••••"
            value={formData.password}
            onChange={handleChange}
            className={`pl-10 border-gray-300 bg-white ${errors.password ? "border-red-500 ring-red-500" : ""}`}
            required
          />
          {errors.password && (
            <p className="mt-1 text-sm text-red-500">{errors.password}</p>
          )}
        </div>
        
        {/* Password strength indicator */}
        <div className="mt-2">
          <div className="flex items-center">
            <div className="flex-1 h-2 bg-gray-200 rounded-full overflow-hidden">
              <div
                className={`h-full rounded-full transition-all ${getPasswordStrengthColor()} ${
                  passwordStrength.label === 'very-weak' ? 'w-1/5' :
                  passwordStrength.label === 'weak' ? 'w-2/5' :
                  passwordStrength.label === 'medium' ? 'w-3/5' :
                  passwordStrength.label === 'strong' ? 'w-4/5' : 'w-full'
                }`}
              />
            </div>
            <span className="ml-2 text-xs font-medium text-gray-500 min-w-20">
              {passwordStrength.label.replace(/-/g, ' ')}
            </span>
          </div>
          {passwordStrength.suggestions.length > 0 && (
            <p className="mt-1 text-xs text-gray-500">
              {passwordStrength.suggestions[0]}
            </p>
          )}
        </div>
      </div>

      <div className="space-y-2">
        <Label htmlFor="confirmPassword" className={errors.confirmPassword ? "text-red-500" : "text-gray-700"}>
          Confirm password
        </Label>
        <div className="relative">
          <Lock className="absolute left-3 top-3 h-4 w-4 text-gray-500" />
          <Input
            id="confirmPassword"
            name="confirmPassword"
            type="password"
            placeholder="••••••••"
            value={formData.confirmPassword}
            onChange={handleChange}
            className={`pl-10 border-gray-300 bg-white ${errors.confirmPassword ? "border-red-500 ring-red-500" : ""}`}
            required
          />
          {errors.confirmPassword && (
            <p className="mt-1 text-sm text-red-500">{errors.confirmPassword}</p>
          )}
        </div>
      </div>

      <div className="flex justify-end pt-4">
        <Button
          type="button"
          onClick={nextStep}
          className="w-full sm:w-auto"
        >
          Continue
          <ChevronRight className="ml-2 h-4 w-4" />
        </Button>
      </div>
    </div>
  );

  const renderPersonalStep = () => (
    <div className="space-y-6">
      <div className="space-y-4">
        <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
          <div className="space-y-2">
            <Label htmlFor="firstName" className={errors.firstName ? "text-red-500" : "text-gray-700"}>
              First name
            </Label>
            <Input
              id="firstName"
              name="firstName"
              type="text"
              autoComplete="given-name"
              value={formData.firstName}
              onChange={handleChange}
              className={`border-gray-300 bg-white ${errors.firstName ? "border-red-500 ring-red-500" : ""}`}
              required
            />
            {errors.firstName && (
              <p className="mt-1 text-sm text-red-500">{errors.firstName}</p>
            )}
          </div>

          <div className="space-y-2">
            <Label htmlFor="lastName" className={errors.lastName ? "text-red-500" : "text-gray-700"}>
              Last name
            </Label>
            <Input
              id="lastName"
              name="lastName"
              type="text"
              autoComplete="family-name"
              value={formData.lastName}
              onChange={handleChange}
              className={`border-gray-300 bg-white ${errors.lastName ? "border-red-500 ring-red-500" : ""}`}
              required
            />
            {errors.lastName && (
              <p className="mt-1 text-sm text-red-500">{errors.lastName}</p>
            )}
          </div>
        </div>
      </div>
      
      <div className="space-y-2">
        <Label htmlFor="phoneNumber" className={errors.phoneNumber ? "text-red-500" : "text-gray-700"}>
          Phone number
        </Label>
        <div className="relative">
          <Phone className="absolute left-3 top-3 h-4 w-4 text-gray-500" />
          <Input
            id="phoneNumber"
            name="phoneNumber"
            type="tel"
            placeholder="+1 (555) 123-4567"
            autoComplete="tel"
            value={formData.phoneNumber}
            onChange={handleChange}
            className={`pl-10 border-gray-300 bg-white ${errors.phoneNumber ? "border-red-500 ring-red-500" : ""}`}
          />
          {errors.phoneNumber && (
            <p className="mt-1 text-sm text-red-500">{errors.phoneNumber}</p>
          )}
        </div>
        <p className="text-xs text-gray-500 mt-1">We'll use this number for account verification and important notifications</p>
      </div>
      
      <div className="space-y-2">
        <Label htmlFor="userType" className="text-gray-700">
          Account type
        </Label>
        <Select 
          value={formData.userType} 
          onValueChange={(value) => handleSelectChange('userType', value)}
        >
          <SelectTrigger className="w-full border-gray-300 bg-white">
            <SelectValue placeholder="Select account type" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="GENERAL_USER">General User</SelectItem>
            <SelectItem value="PHARMACIST">Pharmacist</SelectItem>
            <SelectItem value="PROPRIETOR">Pharmacy Proprietor</SelectItem>
            <SelectItem value="MANAGER">Pharmacy Manager</SelectItem>
            <SelectItem value="SALESMAN">Pharmacy Salesperson</SelectItem>
            <SelectItem value="INSTRUCTOR">Instructor</SelectItem>
          </SelectContent>
        </Select>
        <p className="text-xs text-gray-500 mt-1">Your account type determines which features you can access</p>
      </div>

      <div className="flex justify-between pt-4">
        <Button
          type="button"
          variant="outline"
          onClick={prevStep}
        >
          <ChevronLeft className="mr-2 h-4 w-4" />
          Back
        </Button>
        <Button
          type="button"
          onClick={nextStep}
        >
          Continue
          <ChevronRight className="ml-2 h-4 w-4" />
        </Button>
      </div>
    </div>
  );

  const renderConfirmationStep = () => (
    <div className="space-y-6">
      <div className="bg-blue-50 border border-blue-100 rounded-lg p-4">
        <h3 className="font-medium text-blue-800 mb-2">Account Summary</h3>
        <div className="space-y-3 text-sm">
          <div className="grid grid-cols-3 gap-2">
            <span className="text-gray-500">Username:</span>
            <span className="col-span-2 font-medium text-gray-800">{formData.username}</span>
          </div>
          <div className="grid grid-cols-3 gap-2">
            <span className="text-gray-500">Email:</span>
            <span className="col-span-2 font-medium text-gray-800">{formData.email}</span>
          </div>
          <div className="grid grid-cols-3 gap-2">
            <span className="text-gray-500">Name:</span>
            <span className="col-span-2 font-medium text-gray-800">{formData.firstName} {formData.lastName}</span>
          </div>
          {formData.phoneNumber && (
            <div className="grid grid-cols-3 gap-2">
              <span className="text-gray-500">Phone:</span>
              <span className="col-span-2 font-medium text-gray-800">{formData.phoneNumber}</span>
            </div>
          )}
          <div className="grid grid-cols-3 gap-2">
            <span className="text-gray-500">Account Type:</span>
            <span className="col-span-2 font-medium text-gray-800">
              {formData.userType.replace(/_/g, ' ')}
            </span>
          </div>
        </div>
      </div>

      <div className="pt-2">
        <div className="flex items-start space-x-2">
          <Checkbox
            id="acceptTerms"
            checked={formData.acceptTerms}
            onCheckedChange={(checked) => {
              setFormData(prev => ({ ...prev, acceptTerms: !!checked }));
              if (errors.acceptTerms) {
                setErrors(prev => ({ ...prev, acceptTerms: '' }));
              }
            }}
            className={errors.acceptTerms ? "border-red-500" : ""}
          />
          <Label
            htmlFor="acceptTerms"
            className={`text-sm font-normal ${errors.acceptTerms ? "text-red-500" : "text-gray-600"}`}
          >
            I accept the{' '}
            <Link href="/terms" className="text-blue-600 hover:text-blue-800 underline">
              Terms of Service
            </Link>{' '}
            and{' '}
            <Link href="/privacy" className="text-blue-600 hover:text-blue-800 underline">
              Privacy Policy
            </Link>
          </Label>
        </div>
        {errors.acceptTerms && (
          <p className="mt-1 text-xs text-red-500 pl-6">{errors.acceptTerms}</p>
        )}
      </div>

      <div className="flex justify-between pt-4">
        <Button
          type="button"
          variant="outline"
          onClick={prevStep}
        >
          <ChevronLeft className="mr-2 h-4 w-4" />
          Back
        </Button>
        <Button
          type="submit"
          disabled={showSuccessAnimation}
          className="bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700"
        >
          {showSuccessAnimation ? (
            <div className="flex items-center justify-center">
              <svg className="w-5 h-5 text-white" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
              </svg>
              <span className="ml-2">Success!</span>
            </div>
          ) : (
            'Create account'
          )}
        </Button>
      </div>
    </div>
  );

  const renderCurrentStep = () => {
    switch (currentStep) {
      case 'account':
        return renderAccountStep();
      case 'personal':
        return renderPersonalStep();
      case 'confirmation':
        return renderConfirmationStep();
      default:
        return renderAccountStep();
    }
  };

  return (
    <Card className="border-none shadow-2xl backdrop-blur-sm bg-white/90">
      {connectivityStatus?.hasIssues && (
        <div className="bg-amber-50 border-l-4 border-amber-500 p-4 mb-4">
          <div className="flex items-start">
            <div className="flex-shrink-0">
              <AlertCircle className="h-5 w-5 text-amber-500" />
            </div>
            <div className="ml-3">
              <p className="text-sm text-amber-700">
                Connection issues detected. Registration may not work correctly. 
                {connectivityStatus.message && (
                  <span className="block mt-1 text-xs">{connectivityStatus.message}</span>
                )}
              </p>
            </div>
          </div>
        </div>
      )}

      <CardHeader className="space-y-1 pb-6">
        <div className="flex justify-center mb-2">
          <div className="size-16 rounded-full bg-gradient-to-br from-blue-600 to-indigo-600 flex items-center justify-center p-4 shadow-lg">
            <UserPlus className="text-white h-8 w-8" />
          </div>
        </div>
        <CardTitle className="text-2xl font-bold text-center text-gray-800">
          Create your account
        </CardTitle>
        <CardDescription className="text-center text-gray-600">
          Join PharmacyHub to manage your pharmacy efficiently
        </CardDescription>
      </CardHeader>

      <CardContent>
        {renderStepIndicator()}
        <form onSubmit={(e) => {
          e.preventDefault();
          if (currentStep === 'confirmation') {
            handleSubmit(e);
          }
        }}>
          {renderCurrentStep()}
        </form>
      </CardContent>

      <CardFooter className="flex flex-col items-center justify-center p-6 border-t bg-gray-50 rounded-b-lg">
        <p className="text-sm text-gray-600">
          Already have an account?{' '}
          <Link
            href="/login"
            className="font-medium text-blue-600 hover:text-blue-700 transition-colors"
          >
            Sign in
          </Link>
        </p>
      </CardFooter>
    </Card>
  );
};
</file>

<file path="src/features/auth/ui/verification/EmailVerificationView.tsx">
import React, { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import { authService } from '../../api/services/authService';
import { Button } from '@/components/ui/button';
import { ROUTES } from '../../config/auth';

interface EmailVerificationViewProps {
  token: string;
}

export const EmailVerificationView: React.FC<EmailVerificationViewProps> = ({ token }) => {
  const [isLoading, setIsLoading] = useState(true);
  const [isVerified, setIsVerified] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  useEffect(() => {
    const verifyEmail = async () => {
      if (!token) {
        setError('No verification token provided');
        setIsLoading(false);
        return;
      }

      try {
        setIsLoading(true);
        await authService.verifyEmail(token);
        setIsVerified(true);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to verify email');
      } finally {
        setIsLoading(false);
      }
    };

    verifyEmail();
  }, [token]);

  const handleRedirect = () => {
    router.push(ROUTES.LOGIN);
  };

  if (isLoading) {
    return (
      <div className="flex flex-col items-center justify-center p-4">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500"></div>
        <p className="mt-4 text-gray-600">Verifying your email...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex flex-col items-center justify-center p-4">
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4 max-w-md">
          <p className="font-bold">Verification Failed</p>
          <p>{error}</p>
        </div>
        <p className="mb-4 text-gray-600">
          The email verification link may have expired or is invalid.
        </p>
        <div className="flex flex-col sm:flex-row gap-4">
          <Button variant="outline" onClick={() => router.push(ROUTES.FORGOT_PASSWORD)}>
            Request New Link
          </Button>
          <Button onClick={() => router.push(ROUTES.LOGIN)}>
            Return to Login
          </Button>
        </div>
      </div>
    );
  }

  if (isVerified) {
    return (
      <div className="flex flex-col items-center justify-center p-4">
        <div className="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded mb-4 max-w-md">
          <p className="font-bold">Email Verified Successfully!</p>
          <p>Your email has been verified. You can now log in to your account.</p>
        </div>
        <Button onClick={handleRedirect} className="mt-4">
          Proceed to Login
        </Button>
      </div>
    );
  }

  return null;
};
</file>

<file path="src/features/auth/ui/verification/index.ts">
export * from './EmailVerificationView';
</file>

<file path="src/features/auth/utils.ts">
/**
 * Authentication Utilities
 * 
 * Common utility functions used across the authentication system,
 * with proper type definitions for security and maintainability.
 */

/**
 * Creates standard authentication headers for API requests
 */
export const createAuthHeaders = (token: string): Record<string, string> => ({
  'Authorization': `Bearer ${token}`,
  'Content-Type': 'application/json'
});

interface JwtPayload {
  sub: string;
  email: string;
  name?: string;
  roles: string[];
  permissions: string[];
  exp: number;
}

/**
 * Parse JWT token and extract payload
 */
export const parseJwtToken = (token: string): JwtPayload | null => {
  try {
    if (!token) return null;
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    return JSON.parse(window.atob(base64));
  } catch (error) {
    console.error('Failed to parse JWT token:', error);
    return null;
  }
};

/**
 * Check if a JWT token is expired
 */
export const isTokenExpired = (token: string): boolean => {
  const payload = parseJwtToken(token);
  if (!payload?.exp) return true;
  return Date.now() >= payload.exp * 1000;
};

interface KeycloakError {
  error?: string;
  error_description?: string;
  message?: string;
}

function isKeycloakError(error: unknown): error is KeycloakError {
  return typeof error === 'object' && 
         error !== null && 
         ('error_description' in error || 'message' in error);
}

/**
 * Format error messages from Keycloak responses
 */
export const formatAuthError = (error: unknown): string => {
  if (typeof error === 'string') return error;
  
  if (isKeycloakError(error)) {
    if (error.error_description) return error.error_description;
    if (error.message) return error.message;
    if (error.error) return error.error;
  }
  
  return 'An unexpected authentication error occurred';
};

/**
 * Debug and validate JWT token structure
 * Returns information about the token for troubleshooting
 */
export const debugJwtToken = (token: string | null): { valid: boolean, message: string, payload?: any } => {
  if (!token) {
    return { valid: false, message: 'No token provided' };
  }
  
  const parts = token.split('.');
  if (parts.length !== 3) {
    return { valid: false, message: `Invalid JWT structure - expected 3 parts, got ${parts.length}` };
  }
  
  try {
    const payload = parseJwtToken(token);
    if (!payload) {
      return { valid: false, message: 'Failed to parse token payload' };
    }
    
    return { 
      valid: true, 
      message: 'Token structure is valid', 
      payload: {
        // Only include non-sensitive parts for logging
        sub: payload.sub,
        exp: payload.exp ? new Date(payload.exp * 1000).toISOString() : 'not set',
        roles: payload.roles || [],
        hasRoles: Array.isArray(payload.roles) && payload.roles.length > 0,
        // If token expiry exists, check if token is expired
        expired: payload.exp ? (Date.now() >= payload.exp * 1000) : false
      }
    };
  } catch (error) {
    return { valid: false, message: `Error parsing token: ${error}` };
  }
};
</file>

<file path="src/features/dashboard/api/dashboardApi.ts">
import { 
  useApiQuery, 
  ApiResponse,
  apiQueryKeys 
} from '@/lib/api';
import { apiClient } from '@/lib/api/apiClient';
import { UseApiQueryOptions } from '@/lib/api/hooks';

/**
 * Dashboard statistics interface
 */
export interface DashboardStats {
  recentExams: {
    id: string;
    title: string;
    completedDate: string;
    score: number;
    passingScore: number;
    passed: boolean;
  }[];
  examProgress: {
    total: number;
    completed: number;
    inProgress: number;
    passed: number;
    failed: number;
  };
  performanceByCategory: {
    categoryName: string;
    attemptedQuestions: number;
    correctAnswers: number;
    score: number;
  }[];
  studyTime: {
    today: number;
    thisWeek: number;
    thisMonth: number;
    total: number;
  };
  upcomingDeadlines: {
    id: string;
    title: string;
    type: 'EXAM' | 'ASSIGNMENT' | 'DEADLINE';
    dueDate: string;
    daysLeft: number;
  }[];
  leaderboard: {
    userId: string;
    userName: string;
    score: number;
    rank: number;
  }[];
}

/**
 * Fetch dashboard statistics
 */
async function getDashboardStats(): Promise<ApiResponse<DashboardStats>> {
  return apiClient.get<DashboardStats>('/dashboard/stats');
}

/**
 * Hook for fetching dashboard statistics
 */
export function useDashboardStats(
  options?: UseApiQueryOptions<DashboardStats>
) {
  return useApiQuery<DashboardStats>(
    apiQueryKeys.dashboard.stats(),
    '/dashboard/stats',
    {
      staleTime: 5 * 60 * 1000, // 5 minutes
      ...options
    }
  );
}

/**
 * Progress timeline interface
 */
export interface ProgressTimeline {
  timeline: {
    date: string;
    exams: {
      id: string;
      title: string;
      score: number;
      passed: boolean;
    }[];
    studyTime: number; // in minutes
  }[];
  totalStudyTime: number;
  averageScore: number;
  examsTaken: number;
  examsPassed: number;
}

/**
 * Fetch progress timeline
 */
async function getProgressTimeline(
  period: 'week' | 'month' | 'year' = 'month'
): Promise<ApiResponse<ProgressTimeline>> {
  return apiClient.get<ProgressTimeline>(`/dashboard/timeline?period=${period}`);
}

/**
 * Hook for fetching progress timeline
 */
export function useProgressTimeline(
  period: 'week' | 'month' | 'year' = 'month',
  options?: UseApiQueryOptions<ProgressTimeline>
) {
  return useApiQuery<ProgressTimeline>(
    apiQueryKeys.dashboard.timeline(period),
    `/dashboard/timeline?period=${period}`,
    {
      staleTime: 15 * 60 * 1000, // 15 minutes
      ...options
    }
  );
}

/**
 * Recommendations interface
 */
export interface Recommendations {
  recommendedExams: {
    id: string;
    title: string;
    difficulty: 'BEGINNER' | 'INTERMEDIATE' | 'ADVANCED';
    category: string;
    reason: string;
  }[];
  recommendedTopics: {
    topic: string;
    category: string;
    reason: string;
    resources: {
      title: string;
      type: 'VIDEO' | 'ARTICLE' | 'QUIZ';
      url?: string;
      id?: string;
    }[];
  }[];
}

/**
 * Fetch personalized recommendations
 */
async function getRecommendations(): Promise<ApiResponse<Recommendations>> {
  return apiClient.get<Recommendations>('/dashboard/recommendations');
}

/**
 * Hook for fetching personalized recommendations
 */
export function useRecommendations(
  options?: UseApiQueryOptions<Recommendations>
) {
  return useApiQuery<Recommendations>(
    apiQueryKeys.dashboard.recommendations(),
    '/dashboard/recommendations',
    {
      staleTime: 60 * 60 * 1000, // 1 hour
      ...options
    }
  );
}

// Define dashboard-specific query keys
apiQueryKeys.dashboard = {
  stats: () => ['dashboard', 'stats'],
  timeline: (period: string) => ['dashboard', 'timeline', period],
  recommendations: () => ['dashboard', 'recommendations'],
};

// Export the API methods
export const dashboardApi = {
  getDashboardStats,
  getProgressTimeline,
  getRecommendations,
};

export default dashboardApi;
</file>

<file path="src/features/exams/api/adapter.ts">
import {
  Exam,
  ExamOption,
  ExamPaper,
  ExamPaperMetadata,
  ExamQuestion,
  ExamStatus,
  ExamStatusType
} from '../types';

// Define the backend API response types
export interface BackendExamPaper {
  id: string;
  title: string;
  description: string;
  difficulty: string;
  questionCount: number;
  durationMinutes: number;
  tags: string[];
  premium: boolean;
  attemptCount: number;
  successRatePercent: number;
  lastUpdatedDate: string;
  type: 'MODEL' | 'PAST';
}

export interface BackendExam {
  id: number;
  title: string;
  description: string;
  duration: number;
  totalMarks: number;
  passingMarks: number;
  status: string;
  questions: {
    id: number;
    questionNumber: number;
    questionText: string;
    options: {
      id: number;
      optionKey: string;
      optionText: string;
      isCorrect: boolean;
    }[];
    correctAnswer: string;
    explanation: string;
    marks: number;
  }[];
}

export interface BackendExamQuestion {
  id: number;
  text: string;
  options: BackendExamOption[];
  explanation: string;
  maxPoints: number;
}

export interface BackendExamOption {
  id: string;
  text: string;
  isCorrect: boolean;
}

// Adapter functions
export function adaptBackendExamPaper(backendPaper: BackendExamPaper): ExamPaper {
  return {
    id: backendPaper.id,
    title: backendPaper.title,
    description: backendPaper.description,
    difficulty: backendPaper.difficulty as 'easy' | 'medium' | 'hard',
    totalQuestions: backendPaper.questionCount,
    duration: backendPaper.durationMinutes,
    topics: backendPaper.tags,
    isPremium: backendPaper.premium,
    attempts: backendPaper.attemptCount,
    successRate: backendPaper.successRatePercent,
    lastUpdated: backendPaper.lastUpdatedDate,
    source: backendPaper.type.toLowerCase() as 'model' | 'past'
  };
}

export function adaptToExamPaperMetadata(backendPaper: BackendExamPaper): ExamPaperMetadata {
  return {
    id: backendPaper.id,
    title: backendPaper.title,
    description: backendPaper.description,
    difficulty: backendPaper.difficulty as 'easy' | 'medium' | 'hard',
    topics_covered: backendPaper.tags,
    total_questions: backendPaper.questionCount,
    time_limit: backendPaper.durationMinutes,
    is_premium: backendPaper.premium,
    source: backendPaper.type.toLowerCase() as 'model' | 'past'
  };
}

export function adaptBackendExam(backendExam: BackendExam): Exam {
  return {
    id: backendExam.id,
    title: backendExam.title,
    description: backendExam.description,
    duration: backendExam.duration,
    maxScore: backendExam.totalMarks,
    passingScore: backendExam.passingMarks,
    status: mapBackendStatus(backendExam.status),
    questions: backendExam.questions.map(q => ({
      id: q.id,
      text: q.questionText,
      options: q.options.map(o => ({
        id: o.id.toString(),
        text: o.optionText,
        key: o.optionKey,
        isCorrect: o.isCorrect
      })),
      explanation: q.explanation,
      points: q.marks
    }))
  };
}

export function adaptBackendQuestion(backendQuestion: BackendExamQuestion): ExamQuestion {
  return {
    id: backendQuestion.id,
    text: backendQuestion.text,
    options: backendQuestion.options.map(adaptBackendOption),
    explanation: backendQuestion.explanation,
    points: backendQuestion.maxPoints
  };
}

function adaptBackendOption(backendOption: BackendExamOption): ExamOption {
  return {
    id: backendOption.id,
    text: backendOption.text,
    isCorrect: backendOption.isCorrect
  };
}

function mapBackendStatus(status: string): ExamStatusType {
  switch (status.toUpperCase()) {
    case 'DRAFT':
      return ExamStatus.DRAFT;
    case 'PUBLISHED':
      return ExamStatus.PUBLISHED;
    case 'ARCHIVED':
      return ExamStatus.ARCHIVED;
    default:
      return ExamStatus.DRAFT;
  }
}
</file>

<file path="src/features/exams/api/core/examService.ts">
import { 
  createExtendedApiService, 
  apiClient
} from '@/features/tanstack-query-api';

import { 
  Exam, 
  ExamStatusType, 
  ExamAttempt, 
  UserAnswer, 
  ExamResult, 
  FlaggedQuestion 
} from '../../model/mcqTypes';

import { adaptBackendExam, BackendExam } from '../adapter';

// Default API path
const BASE_PATH = '/api/v1/exams';

// Define custom methods for the exam service
const customMethods = {
  /**
   * Get all published exams
   */
  getPublishedExams: async () => {
    return apiClient.get<BackendExam[]>(`${BASE_PATH}/published`).then(response => {
      if (response.error) {
        throw response.error;
      }
      return (response.data || []).map(adaptBackendExam);
    });
  },

  /**
   * Get exam by ID
   */
  getExamById: async (examId: number) => {
    return apiClient.get<BackendExam>(`${BASE_PATH}/${examId}`).then(response => {
      if (response.error) {
        throw response.error;
      }
      return adaptBackendExam(response.data);
    });
  },

  /**
   * Get user's exam attempts
   */
  getUserAttempts: async (userId: string) => {
    return apiClient.get<ExamAttempt[]>(`${BASE_PATH}/user/${userId}/attempts`).then(response => {
      if (response.error) {
        throw response.error;
      }
      return response.data || [];
    });
  },

  /**
   * Get a specific attempt
   */
  getAttempt: async (attemptId: number) => {
    return apiClient.get<ExamAttempt>(`${BASE_PATH}/attempts/${attemptId}`).then(response => {
      if (response.error) {
        throw response.error;
      }
      return response.data;
    });
  },

  /**
   * Start an exam attempt
   */
  startExam: async (examId: number) => {
    return apiClient.post<ExamAttempt>(
      `${BASE_PATH}/${examId}/start`, 
      undefined
    ).then(response => {
      if (response.error) {
        throw response.error;
      }
      return response.data as ExamAttempt;
    });
  },

  /**
   * Submit an exam attempt
   */
  submitExam: async (attemptId: number, answers: UserAnswer[]) => {
    if (!answers || answers.length === 0) {
      throw new Error('Cannot submit an exam with no answers');
    }
    
    return apiClient.post<ExamResult>(
      `${BASE_PATH}/attempts/${attemptId}/submit`,
      { answers }
    ).then(response => {
      if (response.error) {
        throw response.error;
      }
      return response.data as ExamResult;
    });
  },

  /**
   * Get exams by status
   */
  getExamsByStatus: async (status: ExamStatusType) => {
    return apiClient.get<BackendExam[]>(`${BASE_PATH}/status/${status}`).then(response => {
      if (response.error) {
        throw response.error;
      }
      return (response.data || []).map(adaptBackendExam);
    });
  },

  /**
   * Flag a question for review later
   */
  flagQuestion: async (attemptId: number, questionId: number) => {
    return apiClient.post<void>(
      `${BASE_PATH}/attempts/${attemptId}/flag/${questionId}`
    ).then(response => {
      if (response.error) {
        throw response.error;
      }
    });
  },

  /**
   * Unflag a previously flagged question
   */
  unflagQuestion: async (attemptId: number, questionId: number) => {
    return apiClient.delete<void>(
      `${BASE_PATH}/attempts/${attemptId}/flag/${questionId}`
    ).then(response => {
      if (response.error) {
        throw response.error;
      }
    });
  },

  /**
   * Get all flagged questions for an attempt
   */
  getFlaggedQuestions: async (attemptId: number) => {
    return apiClient.get<FlaggedQuestion[]>(`${BASE_PATH}/attempts/${attemptId}/flags`).then(response => {
      if (response.error) {
        throw response.error;
      }
      return response.data || [];
    });
  }
};

// Create the extended service combining standard CRUD operations with custom methods
export const examService = createExtendedApiService<
  Exam,
  typeof customMethods
>(BASE_PATH, customMethods);

export default examService;
</file>

<file path="src/features/exams/api/core/index.ts">
/**
 * Core API types and services
 */
export * from './examService';
export * from './queryKeys';
</file>

<file path="src/features/exams/api/core/queryKeys.ts">
import { createQueryKeys } from '@/features/tanstack-query-api';
import { ExamStatusType } from '../../model/mcqTypes';

/**
 * Exam-related query keys for TanStack Query cache management
 */
export const examQueryKeys = createQueryKeys({
  all: () => ['exams'] as const,
  lists: () => [...examQueryKeys.all(), 'list'] as const,
  list: (filters: Record<string, unknown> = {}) => [...examQueryKeys.lists(), filters] as const,
  published: () => [...examQueryKeys.lists(), 'published'] as const,
  details: () => [...examQueryKeys.all(), 'detail'] as const,
  detail: (id: number) => [...examQueryKeys.details(), id] as const,
  attempts: () => [...examQueryKeys.all(), 'attempts'] as const,
  attempt: (id: number) => [...examQueryKeys.attempts(), id] as const,
  flags: (attemptId: number) => [...examQueryKeys.attempts(), attemptId, 'flags'] as const,
  results: () => [...examQueryKeys.all(), 'results'] as const,
  result: (attemptId: number) => [...examQueryKeys.results(), attemptId] as const,
  byStatus: (status: ExamStatusType) => [...examQueryKeys.lists(), 'status', status] as const,
});

export default examQueryKeys;
</file>

<file path="src/features/exams/api/hooks/index.ts">
/**
 * Main hooks module that exports all exam-related hooks.
 */

// Re-export query hooks
export * from './useExamQueries';

// Re-export mutation hooks
export * from './useExamMutations';
</file>

<file path="src/features/exams/api/hooks/useExamMutations.ts">
import { useApiMutation, useQueryClient } from '@/features/tanstack-query-api';
import { examQueryKeys } from '../core/queryKeys';
import { ExamAttempt, ExamResult, UserAnswer } from '../../model/mcqTypes';

/**
 * Hook for starting an exam attempt
 */
export const useStartExamMutation = () => {
  const queryClient = useQueryClient();
  
  return useApiMutation<ExamAttempt, { examId: number }>(
    `/api/v1/exams/:examId/start`,
    {
      onMutate: async ({ examId }) => {
        // Update the URL before the mutation completes
        return { examId };
      },
      onSuccess: (data, { examId }) => {
        // Invalidate relevant queries
        queryClient.invalidateQueries(examQueryKeys.detail(examId));
      }
    }
  );
};

/**
 * Hook for submitting an exam attempt
 */
export const useSubmitExamMutation = (attemptId: number) => {
  const queryClient = useQueryClient();
  
  return useApiMutation<ExamResult, UserAnswer[]>(
    `/api/v1/exams/attempts/${attemptId}/submit`,
    {
      onSuccess: () => {
        // Invalidate results queries
        queryClient.invalidateQueries(examQueryKeys.result(attemptId));
      }
    }
  );
};

/**
 * Hook for flagging a question
 */
export const useFlagQuestionMutation = (attemptId: number) => {
  const queryClient = useQueryClient();
  
  return useApiMutation<void, { questionId: number }>(
    `/api/v1/exams/attempts/${attemptId}/flag/:questionId`,
    {
      onSuccess: () => {
        // Invalidate flagged questions query
        queryClient.invalidateQueries(examQueryKeys.flags(attemptId));
      }
    }
  );
};

/**
 * Hook for unflagging a question
 */
export const useUnflagQuestionMutation = (attemptId: number) => {
  const queryClient = useQueryClient();
  
  return useApiMutation<void, { questionId: number }>(
    `/api/v1/exams/attempts/${attemptId}/flag/:questionId`,
    {
      onSuccess: () => {
        // Invalidate flagged questions query
        queryClient.invalidateQueries(examQueryKeys.flags(attemptId));
      }
    }
  );
};
</file>

<file path="src/features/exams/api/hooks/useExamQueries.ts">
/**
 * These hooks provides query functionality for exams using the TanStack Query API
 * They handle data fetching for various exam-related entities
 */

import { useApiQuery } from '@/features/tanstack-query-api';
import { examQueryKeys } from '../core/queryKeys';
import { Exam, ExamResult, ExamStatusType, FlaggedQuestion } from '../../model/mcqTypes';

/**
 * Hook for fetching all exams
 */
export const useExams = () => {
  return useApiQuery<Exam[]>(
    examQueryKeys.lists(),
    '/api/v1/exams',
    {
      staleTime: 5 * 60 * 1000, // 5 minutes
    }
  );
};

/**
 * Hook for fetching published exams
 */
export const usePublishedExams = () => {
  return useApiQuery<Exam[]>(
    examQueryKeys.published(),
    '/api/v1/exams/published',
    {
      staleTime: 5 * 60 * 1000, // 5 minutes
    }
  );
};

/**
 * Hook for fetching an exam by ID
 */
export const useExam = (id: number) => {
  return useApiQuery<Exam>(
    examQueryKeys.detail(id),
    `/api/v1/exams/${id}`,
    {
      enabled: !!id,
      staleTime: 5 * 60 * 1000, // 5 minutes
    }
  );
};

/**
 * Hook for fetching exams by status
 */
export const useExamsByStatus = (status: ExamStatusType) => {
  return useApiQuery<Exam[]>(
    examQueryKeys.byStatus(status),
    `/api/v1/exams/status/${status}`,
    {
      staleTime: 5 * 60 * 1000, // 5 minutes
    }
  );
};

/**
 * Hook for fetching exam results
 */
export const useExamResult = (attemptId: number) => {
  return useApiQuery<ExamResult>(
    examQueryKeys.result(attemptId),
    `/api/v1/exams/attempts/${attemptId}/result`,
    {
      enabled: !!attemptId,
      staleTime: 0, // Always get fresh results
    }
  );
};

/**
 * Hook for fetching flagged questions for an attempt
 */
export const useFlaggedQuestions = (attemptId: number) => {
  return useApiQuery<FlaggedQuestion[]>(
    examQueryKeys.flags(attemptId),
    `/api/v1/exams/attempts/${attemptId}/flags`,
    {
      enabled: !!attemptId,
      staleTime: 0, // Always get fresh flags
    }
  );
};
</file>

<file path="src/features/exams/api/index.ts">
/**
 * Unified API Module
 * 
 * This module exports all of the exam-related API functionality
 * in an organized, consistent way.
 */

// Export core API client, service, and query keys
export * from './core';

// Export hooks for React components
export * from './hooks';

// Export adapter functions for backend data
export * from './adapter';

// Export types from the model
export type {
  Exam,
  ExamAttempt,
  ExamResult,
  FlaggedQuestion,
  Question,
  UserAnswer
} from '../model/mcqTypes';
</file>

<file path="src/features/exams/constants/flags/index.ts">
/**
 * Exams Feature Flags
 * 
 * Defines feature flags for the exams feature with clear, easy-to-configure settings.
 */

/**
 * Feature flags for exam creation and management
 */
export enum ExamFeatureFlag {
  // Core exam features
  TIMED_EXAMS = 'exams:timed',
  RANDOMIZED_QUESTIONS = 'exams:randomized',
  QUESTION_FEEDBACK = 'exams:question-feedback',
  PARTIAL_GRADING = 'exams:partial-grading',
  
  // Advanced features
  ADVANCED_QUESTION_TYPES = 'exams:advanced-questions',
  EXAM_CERTIFICATES = 'exams:certificates',
  EXAM_STATISTICS = 'exams:statistics',
  PROCTORING = 'exams:proctoring'
}

/**
 * Default values for all feature flags
 * Each flag has a separate, clearly named constant for easier configuration
 */

// Basic features - enabled by default
export const FEATURE_TIMED_EXAMS_ENABLED = true;
export const FEATURE_RANDOMIZED_QUESTIONS_ENABLED = true;
export const FEATURE_QUESTION_FEEDBACK_ENABLED = true;
export const FEATURE_PARTIAL_GRADING_ENABLED = true;

// Advanced features - some disabled by default
export const FEATURE_ADVANCED_QUESTION_TYPES_ENABLED = true;
export const FEATURE_EXAM_CERTIFICATES_ENABLED = true;
export const FEATURE_EXAM_STATISTICS_ENABLED = true;
export const FEATURE_PROCTORING_ENABLED = false;  // Disabled by default

/**
 * Feature flag metadata with names, descriptions, and default settings
 */
export const EXAM_FEATURE_FLAGS = {
  [ExamFeatureFlag.TIMED_EXAMS]: {
    name: 'Timed Exams',
    description: 'Allow setting time limits for exams',
    defaultEnabled: FEATURE_TIMED_EXAMS_ENABLED
  },
  [ExamFeatureFlag.RANDOMIZED_QUESTIONS]: {
    name: 'Randomized Questions',
    description: 'Randomly order questions for each exam session',
    defaultEnabled: FEATURE_RANDOMIZED_QUESTIONS_ENABLED
  },
  [ExamFeatureFlag.QUESTION_FEEDBACK]: {
    name: 'Question Feedback',
    description: 'Allow feedback and explanations for each question',
    defaultEnabled: FEATURE_QUESTION_FEEDBACK_ENABLED
  },
  [ExamFeatureFlag.PARTIAL_GRADING]: {
    name: 'Partial Grading',
    description: 'Allow partial credit for partially correct answers',
    defaultEnabled: FEATURE_PARTIAL_GRADING_ENABLED
  },
  [ExamFeatureFlag.ADVANCED_QUESTION_TYPES]: {
    name: 'Advanced Question Types',
    description: 'Enable complex question types like matching, ordering, and drag-drop',
    defaultEnabled: FEATURE_ADVANCED_QUESTION_TYPES_ENABLED
  },
  [ExamFeatureFlag.EXAM_CERTIFICATES]: {
    name: 'Completion Certificates',
    description: 'Generate certificates for completed exams',
    defaultEnabled: FEATURE_EXAM_CERTIFICATES_ENABLED
  },
  [ExamFeatureFlag.EXAM_STATISTICS]: {
    name: 'Exam Statistics',
    description: 'Show detailed statistics and analytics for exam results',
    defaultEnabled: FEATURE_EXAM_STATISTICS_ENABLED
  },
  [ExamFeatureFlag.PROCTORING]: {
    name: 'Exam Proctoring',
    description: 'Monitor and prevent cheating during exams',
    defaultEnabled: FEATURE_PROCTORING_ENABLED
  }
};
</file>

<file path="src/features/exams/constants/index.ts">
/**
 * Exams Feature Constants
 * 
 * Defines the exams feature's permissions, feature flags, and requirements.
 */
import { defineFeature } from '@/features/rbac/registry';
import { Role } from '@/features/rbac/constants/roles';
import { registerFeature } from '@/features/rbac/registry';

// Feature definition
export const EXAMS_FEATURE = defineFeature(
  'exams',
  'Examinations',
  'Create, manage, take, and grade exams and assessments'
);

import {
  ExamPermission,
  EXAMS_ADMIN_PERMISSIONS,
  EXAMS_COMMON_PERMISSIONS
} from './permissions';


import {
  ExamFeatureFlag,
  EXAM_FEATURE_FLAGS
} from './flags';


import { EXAMS_REQUIRED_ROLES } from './roles';



/**
 * Feature initializer
 * Call this to register the feature with the registry
 */
export function initializeExamsFeature() {
  // Register this feature with the registry
  registerFeature(
    EXAMS_FEATURE,
    ExamPermission,
    EXAMS_REQUIRED_ROLES,
    ExamFeatureFlag,
    EXAM_FEATURE_FLAGS
  );
  
  console.log('Exams feature registered');
}
</file>

<file path="src/features/exams/constants/permissions/index.ts">
/**
 * Exams Feature Permissions
 * 
 * Defines all permissions related to the exams feature.
 */

/**
 * Exam-specific permissions
 */
export enum ExamPermission {
  // Basic exam access
  VIEW_EXAMS = 'exams:view',
  TAKE_EXAM = 'exams:take',
  
  // Exam creation & management
  CREATE_EXAM = 'exams:create',
  EDIT_EXAM = 'exams:edit',
  DELETE_EXAM = 'exams:delete',
  DUPLICATE_EXAM = 'exams:duplicate',
  
  // Question management
  MANAGE_QUESTIONS = 'exams:manage-questions',
  
  // Exam administration
  PUBLISH_EXAM = 'exams:publish',
  UNPUBLISH_EXAM = 'exams:unpublish',
  ASSIGN_EXAM = 'exams:assign',
  
  // Results & grading
  GRADE_EXAM = 'exams:grade',
  VIEW_RESULTS = 'exams:view-results',
  EXPORT_RESULTS = 'exams:export-results',
  
  // Analytics
  VIEW_ANALYTICS = 'exams:view-analytics'
}

/**
 * Admin-only permissions within this feature
 */
export const EXAMS_ADMIN_PERMISSIONS = [
  ExamPermission.CREATE_EXAM,
  ExamPermission.EDIT_EXAM,
  ExamPermission.DELETE_EXAM,
  ExamPermission.PUBLISH_EXAM,
  ExamPermission.UNPUBLISH_EXAM,
  ExamPermission.EXPORT_RESULTS
];

/**
 * Permissions that all roles have
 */
export const EXAMS_COMMON_PERMISSIONS = [
  ExamPermission.VIEW_EXAMS,
  ExamPermission.TAKE_EXAM,
  ExamPermission.VIEW_RESULTS
];
</file>

<file path="src/features/exams/constants/roles/index.ts">
/**
 * Exams Feature Role Requirements
 * 
 * Defines which roles have access to the exams feature.
 */
import { Role } from '@/features/rbac/constants/roles';

/**
 * Roles that have access to the exams feature by default
 */
export const EXAMS_REQUIRED_ROLES = [
  Role.USER,
  Role.PHARMACIST,
  Role.PHARMACY_MANAGER,
  Role.TECHNICIAN,
  Role.ADMIN,
  Role.SUPER_ADMIN
];

/**
 * Roles that have admin privileges for exams
 */
export const EXAMS_ADMIN_ROLES = [
  Role.ADMIN,
  Role.SUPER_ADMIN,
  Role.PHARMACY_MANAGER
];
</file>

<file path="src/features/exams/hooks/index.ts">
/**
 * Export all exam hooks
 */

export * from './useExamQueries';
</file>

<file path="src/features/exams/hooks/useExamQueries.ts">
/**
 * Exam queries hook
 * Provides queries for fetching exam data
 */
import { useQuery } from '@tanstack/react-query';
import { examService } from '../api/core/examService';
import { examQueryKeys } from '../api/core/queryKeys';

/**
 * Hook for fetching all published exams
 */
export const usePublishedExams = () => {
  return useQuery({
    queryKey: examQueryKeys.lists.published(),
    queryFn: () => examService.getPublishedExams()
  });
};

/**
 * Hook for fetching a specific exam by ID
 */
export const useExam = (examId: number) => {
  return useQuery({
    queryKey: examQueryKeys.detail(examId),
    queryFn: () => examService.getExamById(examId),
    enabled: !!examId
  });
};

/**
 * Hook for fetching exams by status
 */
export const useExamsByStatus = (status: string) => {
  return useQuery({
    queryKey: examQueryKeys.lists.byStatus(status),
    queryFn: () => examService.getExamsByStatus(status),
    enabled: !!status
  });
};

/**
 * Hook for fetching a user's exam attempts
 */
export const useUserExamAttempts = (userId: string) => {
  return useQuery({
    queryKey: examQueryKeys.lists.userAttempts(userId),
    queryFn: () => examService.getUserAttempts(userId),
    enabled: !!userId
  });
};

/**
 * Hook for fetching a specific exam attempt
 */
export const useExamAttempt = (attemptId: number) => {
  return useQuery({
    queryKey: examQueryKeys.attempt(attemptId),
    queryFn: () => examService.getAttempt(attemptId),
    enabled: !!attemptId
  });
};

/**
 * Export named hooks
 */
export const useExamQueries = {
  usePublishedExams,
  useExam,
  useExamsByStatus,
  useUserExamAttempts,
  useExamAttempt
};

export default useExamQueries;
</file>

<file path="src/features/exams/index.ts">
export * from './model';
export * from './ui';
export * from './api';
export * from './hooks';
export * from './lib';
export * from './store';
</file>

<file path="src/features/exams/lib/analysis.ts">
import { MCQPaper, UserAnswer } from '../model/types';

export interface QuestionAnalysis {
    totalQuestions: number;
    attempted: number;
    correct: number;
    incorrect: number;
    score: number;
    percentage: number;
    timeSpent: number;
    topicWiseAnalysis: {
        [topic: string]: {
            total: number;
            attempted: number;
            correct: number;
            accuracy: number;
            averageTime: number;
        };
    };
    difficultyAnalysis: {
        [difficulty: string]: {
            total: number;
            attempted: number;
            correct: number;
            accuracy: number;
        };
    };
}

export function analyzeExamPerformance(
    paper: MCQPaper,
    answers: Record<string, UserAnswer>,
    timeSpent: number
): QuestionAnalysis {
    const totalQuestions = paper.totalQuestions;
    const attempted = Object.keys(answers).length;
    const correct = Object.values(answers).filter(a => a.isCorrect).length;
    const incorrect = attempted - correct;
    const score = correct - (incorrect * 0.25); // -0.25 for incorrect answers
    const percentage = (score / totalQuestions) * 100;

    // Topic-wise analysis
    const topicWiseAnalysis = paper.sections[0].questions.reduce((acc, q) => {
        const topic = q.metadata.topic;
        if (!acc[topic]) {
            acc[topic] = {
                total: 0,
                attempted: 0,
                correct: 0,
                accuracy: 0,
                averageTime: 0,
            };
        }

        acc[topic].total++;
        
        const answer = answers[q.id];
        if (answer) {
            acc[topic].attempted++;
            if (answer.isCorrect) {
                acc[topic].correct++;
            }
            acc[topic].averageTime += answer.timeSpent || 0;
        }

        // Calculate accuracy and average time
        acc[topic].accuracy = (acc[topic].correct / acc[topic].attempted) * 100;
        acc[topic].averageTime = acc[topic].averageTime / acc[topic].attempted;

        return acc;
    }, {} as QuestionAnalysis['topicWiseAnalysis']);

    // Difficulty-wise analysis
    const difficultyAnalysis = paper.sections[0].questions.reduce((acc, q) => {
        const difficulty = q.metadata.difficulty;
        if (!acc[difficulty]) {
            acc[difficulty] = {
                total: 0,
                attempted: 0,
                correct: 0,
                accuracy: 0,
            };
        }

        acc[difficulty].total++;
        
        const answer = answers[q.id];
        if (answer) {
            acc[difficulty].attempted++;
            if (answer.isCorrect) {
                acc[difficulty].correct++;
            }
        }

        // Calculate accuracy
        acc[difficulty].accuracy = 
            (acc[difficulty].correct / acc[difficulty].attempted) * 100;

        return acc;
    }, {} as QuestionAnalysis['difficultyAnalysis']);

    return {
        totalQuestions,
        attempted,
        correct,
        incorrect,
        score,
        percentage,
        timeSpent,
        topicWiseAnalysis,
        difficultyAnalysis,
    };
}

export function generateRecommendations(analysis: QuestionAnalysis): string[] {
    const recommendations: string[] = [];

    // Overall performance recommendations
    if (analysis.percentage < 50) {
        recommendations.push('Focus on understanding fundamental concepts across all topics.');
    }

    // Topic-wise recommendations
    Object.entries(analysis.topicWiseAnalysis).forEach(([topic, stats]) => {
        if (stats.accuracy < 60) {
            recommendations.push(
                `Review ${topic} - consider focusing on practice questions in this area.`
            );
        }
        if (stats.averageTime > 120) { // 2 minutes per question
            recommendations.push(
                `Work on improving speed in ${topic} questions.`
            );
        }
    });

    // Difficulty-based recommendations
    const difficultyLevels = Object.entries(analysis.difficultyAnalysis);
    difficultyLevels.forEach(([difficulty, stats]) => {
        if (stats.accuracy < 50) {
            recommendations.push(
                `Practice more ${difficulty} level questions to improve confidence.`
            );
        }
    });

    // Time management recommendations
    const averageTimePerQuestion = analysis.timeSpent / analysis.attempted;
    if (averageTimePerQuestion > 90) { // 1.5 minutes
        recommendations.push(
            'Work on time management - aim to spend about 1 minute per question initially.'
        );
    }

    // Attempt rate recommendations
    const attemptRate = (analysis.attempted / analysis.totalQuestions) * 100;
    if (attemptRate < 80) {
        recommendations.push(
            'Try to attempt more questions - even educated guesses can help improve your score.'
        );
    }

    return recommendations;
}
</file>

<file path="src/features/exams/mock/mockData.ts">
export interface ExamPaper {
  id: string;
  title: string;
  description: string;
  difficulty: 'easy' | 'medium' | 'hard';
  totalQuestions: number;
  duration: number; // in minutes
  topics: string[];
  isPremium: boolean;
  attempts: number;
  successRate: number;
  lastUpdated: string;
}

export const mockModelPapers: ExamPaper[] = [
  {
    id: 'mp-001',
    title: 'Pharmacology Basics 2024',
    description: 'Comprehensive review of basic pharmacology principles',
    difficulty: 'easy',
    totalQuestions: 50,
    duration: 60,
    topics: ['Basic Pharmacology', 'Drug Classification', 'Mechanisms of Action'],
    isPremium: false,
    attempts: 1250,
    successRate: 78,
    lastUpdated: '2024-02-15'
  },
  {
    id: 'mp-002',
    title: 'Clinical Pharmacy Practice',
    description: 'Advanced clinical pharmacy scenarios and case studies',
    difficulty: 'hard',
    totalQuestions: 75,
    duration: 90,
    topics: ['Patient Care', 'Clinical Decision Making', 'Therapeutic Management'],
    isPremium: true,
    attempts: 850,
    successRate: 65,
    lastUpdated: '2024-02-18'
  },
  {
    id: 'mp-003',
    title: 'Pharmaceutical Calculations',
    description: 'Essential calculations for pharmacy practice',
    difficulty: 'medium',
    totalQuestions: 40,
    duration: 60,
    topics: ['Dosage Calculations', 'Concentration Calculations', 'Compounding'],
    isPremium: false,
    attempts: 2000,
    successRate: 72,
    lastUpdated: '2024-02-10'
  },
  {
    id: 'mp-004',
    title: 'Pharmacy Law & Ethics',
    description: 'Latest updates on pharmacy regulations and ethical practices',
    difficulty: 'medium',
    totalQuestions: 60,
    duration: 75,
    topics: ['Pharmacy Laws', 'Professional Ethics', 'Regulatory Compliance'],
    isPremium: true,
    attempts: 1500,
    successRate: 70,
    lastUpdated: '2024-02-20'
  }
];

export const mockPastPapers: ExamPaper[] = [
  {
    id: 'pp-001',
    title: '2023 Board Exam Paper 1',
    description: 'Official board examination from 2023',
    difficulty: 'hard',
    totalQuestions: 100,
    duration: 180,
    topics: ['Comprehensive', 'Clinical Practice', 'Pharmacy Management'],
    isPremium: true,
    attempts: 3000,
    successRate: 68,
    lastUpdated: '2023-12-01'
  },
  {
    id: 'pp-002',
    title: '2023 Board Exam Paper 2',
    description: 'Second paper from 2023 board examination',
    difficulty: 'hard',
    totalQuestions: 100,
    duration: 180,
    topics: ['Drug Therapy', 'Patient Care', 'Pharmacy Operations'],
    isPremium: true,
    attempts: 2800,
    successRate: 65,
    lastUpdated: '2023-12-01'
  }
];

export interface ExamStats {
  totalPapers: number;
  avgDuration: number;
  completionRate: number;
  activeUsers: number;
}

export const mockStats: ExamStats = {
  totalPapers: mockModelPapers.length + mockPastPapers.length,
  avgDuration: 180,
  completionRate: 75,
  activeUsers: 2500
};
</file>

<file path="src/features/exams/model/index.ts">
export * from './types';
export * from './mcqTypes';
</file>

<file path="src/features/exams/model/mcqTypes.ts">
// Base types for exam entities

export interface Option {
  id: string;
  text: string;
  isCorrect?: boolean; // Only provided during creation or for instructors
}

export interface Question {
  id: number;
  questionNumber: number;
  text: string;
  options: Option[];
  explanation?: string;
  marks: number;
}

export interface Exam {
  id: number;
  title: string;
  description: string;
  duration: number; // in minutes
  totalMarks: number;
  passingMarks: number;
  status: 'DRAFT' | 'PUBLISHED' | 'ARCHIVED';
  questions?: Question[];
}

// Exam attempt related types

export interface ExamAttempt {
  id: number;
  examId: number;
  userId: string;
  startTime: string;
  endTime?: string;
  status: 'IN_PROGRESS' | 'COMPLETED' | 'ABANDONED';
  answers?: UserAnswer[];
}

export interface UserAnswer {
  questionId: number;
  selectedOption: number; // index of the selected option
  timeSpent?: number; // in seconds
}

export interface FlaggedQuestion {
  questionId: number;
  attemptId: number;
}

// Exam result related types

export interface QuestionResult {
  questionId: number;
  questionText: string;
  userAnswerId: string;
  correctAnswerId: string;
  isCorrect: boolean;
  explanation?: string;
  points: number;
  earnedPoints: number;
}

export interface ExamResult {
  attemptId: number;
  examId: number;
  examTitle: string;
  score: number;
  totalMarks: number;
  passingMarks: number;
  isPassed: boolean;
  timeSpent: number; // in seconds
  totalQuestions: number;
  correctAnswers: number;
  incorrectAnswers: number;
  unanswered: number;
  completedAt: string;
  questionResults: QuestionResult[];
}

// Exam statistics and dashboard types

export interface ExamStats {
  totalPapers: number;
  avgDuration: number;
  completionRate: number;
  activeUsers: number;
}

// ExamSession type for Zustand store

export interface ExamSession {
  attemptId: number;
  startTime: string;
  endTime?: string;
  status: 'IN_PROGRESS' | 'COMPLETED' | 'ABANDONED';
}

// Types for MCQ exams

export interface MCQPaper {
  id: number;
  title: string;
  description: string;
  timeLimit: number; // in minutes
  passingCriteria: {
    minimumScore: number;
    minimumQuestions: number;
  };
  totalQuestions: number;
  questions: Question[];
}
</file>

<file path="src/features/exams/model/types.ts">
/**
 * Exam types for the exams feature
 */

/**
 * Question interface for representing a question in the system
 */
export interface MCQuestion {
  id: string | number;
  question: string;
  options: Record<string, string>;
  answer: string;
  explanation?: string;
  metadata?: {
    topic?: string;
    difficulty?: 'easy' | 'medium' | 'hard';
    points?: number;
    timeAllocation?: number;
    tags?: string[];
    keyPoints?: string[];
    references?: string[];
  };
}

/**
 * Section interface for representing a section of questions
 */
export interface MCSection {
  id: string | number;
  title: string;
  description?: string;
  questions: MCQuestion[];
}

/**
 * Paper interface for representing a full exam paper
 */
export interface MCQPaper {
  id: string | number;
  title: string;
  description?: string;
  totalQuestions: number;
  totalMarks: number;
  duration: number; // in minutes
  passingMarks: number;
  sections: MCSection[];
  metadata?: {
    author?: string;
    created?: string;
    lastUpdated?: string;
    category?: string;
    subcategory?: string;
    tags?: string[];
    instructions?: string;
    difficulty?: 'easy' | 'medium' | 'hard';
  };
}

/**
 * User Answer interface for representing a user's answer to a question
 */
export interface UserAnswer {
  questionId: string | number;
  selectedOption: string;
  timeSpent?: number; // seconds spent on this question
  flagged?: boolean;
  isCorrect?: boolean;
  timestamp?: string;
}

/**
 * Exam Stats interface for representing exam statistics
 */
export interface ExamStats {
  totalQuestions: number;
  answeredQuestions: number;
  correctAnswers: number;
  incorrectAnswers: number;
  unansweredQuestions: number;
  totalMarks: number;
  obtainedMarks: number;
  percentageScore: number;
  isPassed: boolean;
  timeSpent: number; // in seconds
  averageTimePerQuestion: number; // in seconds
}

/**
 * Exam Attempt interface for representing a user's attempt at an exam
 */
export interface ExamAttempt {
  id: string | number;
  examId: string | number;
  userId: string | number;
  startedAt: string;
  completedAt?: string;
  isCompleted: boolean;
  timeSpent?: number; // in seconds
  answers: UserAnswer[];
  status: 'in-progress' | 'completed' | 'cancelled';
}

/**
 * Exam Result interface for representing the result of an exam attempt
 */
export interface ExamResult {
  attemptId: string | number;
  examId: string | number;
  userId: string | number;
  score: number;
  totalMarks: number;
  passingMarks: number;
  isPassed: boolean;
  completedAt: string;
  timeSpent: number; // in seconds
  totalQuestions: number;
  correctAnswers: number;
  incorrectAnswers: number;
  unanswered: number;
  examTitle?: string;
  questionResults?: {
    questionId: string | number;
    isCorrect: boolean;
    selectedOption?: string;
    correctOption: string;
    points: number;
  }[];
}
</file>

<file path="src/features/exams/progress/api/progressApi.ts">
import { apiClient } from '@/shared/api/apiClient';

// Define interface for the progress data
export interface Progress {
  completedExams: number;
  inProgressExams: number;
  averageScore: number;
  totalTimeSpent: number;
  // Add other fields as needed
}

// Define interface for analytics data
export interface Analytics {
  studyHours: number[];
  examScores: number[];
  timeSpent: Record<string, number>;
  // Add other fields as needed
}

// Define interface for recommendations
export interface Recommendation {
  id: string;
  title: string;
  type: 'exam' | 'course' | 'resource';
  confidence: number;
  tags: string[];
  // Add other fields as needed
}

const BASE_PATH = '/progress';

export const progressApi = {
  /**
   * Get user progress data
   */
  getUserProgress: async (userId: string): Promise<Progress> => {
    const response = await apiClient.get<Progress>(`${BASE_PATH}/${userId}`);
    if (response.error) throw response.error;
    if (!response.data) throw new Error('Progress data not found');
    return response.data;
  },

  /**
   * Get user analytics data
   */
  getAnalytics: async (
    userId: string, 
    startDate?: string, 
    endDate?: string
  ): Promise<Analytics> => {
    const queryParams = new URLSearchParams();
    if (startDate) queryParams.append('startDate', startDate);
    if (endDate) queryParams.append('endDate', endDate);
    
    const endpoint = `/analytics/${userId}?${queryParams.toString()}`;
    const response = await apiClient.get<Analytics>(endpoint);
    if (response.error) throw response.error;
    if (!response.data) throw new Error('Analytics data not found');
    return response.data;
  },

  /**
   * Get personalized recommendations for user
   */
  getRecommendations: async (userId: string): Promise<Recommendation[]> => {
    const response = await apiClient.get<Recommendation[]>(`/recommendations/${userId}`);
    if (response.error) throw response.error;
    return response.data || [];
  }
};
</file>

<file path="src/features/exams/progress/hooks/useProgressQueries.ts">
import { useQuery } from '@tanstack/react-query';
import { progressApi, Progress, Analytics, Recommendation } from '../api/progressApi';

// Define query keys for progress data
export const PROGRESS_KEYS = {
  all: ['progress'] as const,
  user: (userId: string) => [...PROGRESS_KEYS.all, userId] as const,
  analytics: (userId: string, startDate?: string, endDate?: string) => 
    [...PROGRESS_KEYS.all, 'analytics', userId, { startDate, endDate }] as const,
  recommendations: (userId: string) => 
    [...PROGRESS_KEYS.all, 'recommendations', userId] as const,
};

/**
 * Hook for fetching user progress data
 */
export function useUserProgress(userId: string) {
  return useQuery<Progress>({
    queryKey: PROGRESS_KEYS.user(userId),
    queryFn: () => progressApi.getUserProgress(userId),
    enabled: !!userId,
  });
}

/**
 * Hook for fetching user analytics data
 */
export function useUserAnalytics(userId: string, startDate?: string, endDate?: string) {
  return useQuery<Analytics>({
    queryKey: PROGRESS_KEYS.analytics(userId, startDate, endDate),
    queryFn: () => progressApi.getAnalytics(userId, startDate, endDate),
    enabled: !!userId,
  });
}

/**
 * Hook for fetching user recommendations
 */
export function useUserRecommendations(userId: string) {
  return useQuery<Recommendation[]>({
    queryKey: PROGRESS_KEYS.recommendations(userId),
    queryFn: () => progressApi.getRecommendations(userId),
    enabled: !!userId,
  });
}

/**
 * Composite hook that fetches all progress-related data
 */
export function useProgress(userId: string) {
  const progressQuery = useUserProgress(userId);
  const analyticsQuery = useUserAnalytics(userId);
  const recommendationsQuery = useUserRecommendations(userId);

  return {
    progress: progressQuery.data,
    analytics: analyticsQuery.data,
    recommendations: recommendationsQuery.data,
    isLoading: 
      progressQuery.isLoading || 
      analyticsQuery.isLoading || 
      recommendationsQuery.isLoading,
    error: 
      progressQuery.error || 
      analyticsQuery.error || 
      recommendationsQuery.error,
    refetch: () => {
      progressQuery.refetch();
      analyticsQuery.refetch();
      recommendationsQuery.refetch();
    }
  };
}
</file>

<file path="src/features/exams/store/examPaperStore.ts">
import { create } from 'zustand';
import { examPaperService } from '../api/examPaperService';
import { ExamPaper, ExamStats } from '../model/types';
import { logger } from '@/shared/lib/logger';

interface ExamPaperState {
  // State
  modelPapers: ExamPaper[];
  pastPapers: ExamPaper[];
  stats: ExamStats | null;
  isLoading: boolean;
  error: string | null;
  
  // Actions
  fetchModelPapers: () => Promise<void>;
  fetchPastPapers: () => Promise<void>;
  fetchAllPapers: () => Promise<void>;
  fetchExamStats: () => Promise<void>;
  fetchPaperById: (id: string) => Promise<ExamPaper | null>;
}

export const useExamPaperStore = create<ExamPaperState>((set, get) => ({
  modelPapers: [],
  pastPapers: [],
  stats: null,
  isLoading: false,
  error: null,
  
  fetchModelPapers: async () => {
    try {
      set({ isLoading: true, error: null });
      const papers = await examPaperService.getModelPapers();
      set({ modelPapers: papers, isLoading: false });
    } catch (error) {
      logger.error('Failed to fetch model papers', { 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
      set({ 
        isLoading: false, 
        error: error instanceof Error ? error.message : 'Failed to fetch model papers' 
      });
    }
  },
  
  fetchPastPapers: async () => {
    try {
      set({ isLoading: true, error: null });
      const papers = await examPaperService.getPastPapers();
      set({ pastPapers: papers, isLoading: false });
    } catch (error) {
      logger.error('Failed to fetch past papers', { 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
      set({ 
        isLoading: false, 
        error: error instanceof Error ? error.message : 'Failed to fetch past papers' 
      });
    }
  },
  
  fetchAllPapers: async () => {
    try {
      set({ isLoading: true, error: null });
      
      // Run both requests in parallel
      const [modelPapers, pastPapers] = await Promise.all([
        examPaperService.getModelPapers(),
        examPaperService.getPastPapers()
      ]);
      
      set({ 
        modelPapers, 
        pastPapers, 
        isLoading: false 
      });
    } catch (error) {
      logger.error('Failed to fetch all papers', { 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
      set({ 
        isLoading: false, 
        error: error instanceof Error ? error.message : 'Failed to fetch exam papers' 
      });
    }
  },
  
  fetchExamStats: async () => {
    try {
      set({ isLoading: true, error: null });
      const stats = await examPaperService.getExamStats();
      set({ stats, isLoading: false });
    } catch (error) {
      logger.error('Failed to fetch exam stats', { 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
      set({ 
        isLoading: false, 
        error: error instanceof Error ? error.message : 'Failed to fetch exam stats' 
      });
    }
  },
  
  fetchPaperById: async (id) => {
    try {
      set({ isLoading: true, error: null });
      
      // First check if we already have this paper in our state
      const { modelPapers, pastPapers } = get();
      let paper = [...modelPapers, ...pastPapers].find(p => p.id === id);
      
      if (!paper) {
        // If not found in state, fetch from API
        paper = await examPaperService.getPaperById(id);
      }
      
      set({ isLoading: false });
      return paper;
    } catch (error) {
      logger.error(`Failed to fetch paper with ID ${id}`, { 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
      set({ 
        isLoading: false, 
        error: error instanceof Error ? error.message : `Failed to fetch paper ${id}` 
      });
      return null;
    }
  }
}));
</file>

<file path="src/features/exams/store/examStore.ts">
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { Question, ExamSession, UserAnswer } from '../model/mcqTypes';

interface ExamState {
  // Exam data
  examId?: number;
  attemptId?: number;
  questions: Question[];
  currentQuestionIndex: number;
  timeRemaining: number; // in seconds
  startTime?: Date;
  endTime?: Date;
  
  // User interactions
  answers: Record<number, UserAnswer>;
  flaggedQuestions: Set<number>;
  visitedQuestions: Set<number>;
  
  // UI state
  isPaused: boolean;
  isCompleted: boolean;
  showSummary: boolean;
  reviewMode: boolean;
  
  // Actions
  startExam: (examId: number, questions: Question[], durationInMinutes: number) => void;
  setAttemptId: (attemptId: number) => void;
  answerQuestion: (questionId: number, optionIndex: number) => void;
  toggleFlagQuestion: (questionId: number) => void;
  navigateToQuestion: (index: number) => void;
  nextQuestion: () => void;
  previousQuestion: () => void;
  pauseExam: () => void;
  resumeExam: () => void;
  decrementTimer: () => void;
  toggleSummary: () => void;
  setReviewMode: (isReview: boolean) => void;
  completeExam: () => void;
  resetExam: () => void;
  
  // Getters
  hasAnswer: (questionId: number) => boolean;
  isFlagged: (questionId: number) => boolean;
  getAnsweredQuestionsCount: () => number;
  getFlaggedQuestionsCount: () => number;
  getCompletionPercentage: () => number;
}

export const useExamStore = create<ExamState>()(
  persist(
    (set, get) => ({
      // Initial state
      questions: [],
      currentQuestionIndex: 0,
      timeRemaining: 0,
      answers: {},
      flaggedQuestions: new Set<number>(),
      visitedQuestions: new Set<number>(),
      isPaused: false,
      isCompleted: false,
      showSummary: false,
      reviewMode: false,
      
      // Actions
      startExam: (examId, questions, durationInMinutes) => {
        set({
          examId,
          questions,
          timeRemaining: durationInMinutes * 60,
          currentQuestionIndex: 0,
          startTime: new Date(),
          answers: {},
          flaggedQuestions: new Set<number>(),
          visitedQuestions: new Set<number>([0]), // Mark first question as visited
          isPaused: false,
          isCompleted: false,
          showSummary: false,
          reviewMode: false,
        });
      },
      
      setAttemptId: (attemptId) => {
        set({ attemptId });
      },
      
      answerQuestion: (questionId, optionIndex) => {
        set((state) => {
          // Calculate time spent on this question
          const timeSpent = 0; // Implement time tracking per question if needed
          
          return {
            answers: {
              ...state.answers,
              [questionId]: { 
                questionId, 
                selectedOption: optionIndex,
                timeSpent
              },
            },
          };
        });
      },
      
      toggleFlagQuestion: (questionId) => {
        set((state) => {
          const newFlagged = new Set(state.flaggedQuestions);
          if (newFlagged.has(questionId)) {
            newFlagged.delete(questionId);
          } else {
            newFlagged.add(questionId);
          }
          return { flaggedQuestions: newFlagged };
        });
      },
      
      navigateToQuestion: (index) => {
        const { questions, visitedQuestions } = get();
        if (index >= 0 && index < questions.length) {
          // Mark the question as visited
          const newVisited = new Set(visitedQuestions);
          newVisited.add(index);
          
          set({ 
            currentQuestionIndex: index,
            visitedQuestions: newVisited
          });
        }
      },
      
      nextQuestion: () => {
        const { currentQuestionIndex, questions, visitedQuestions } = get();
        if (currentQuestionIndex < questions.length - 1) {
          const newIndex = currentQuestionIndex + 1;
          
          // Mark the next question as visited
          const newVisited = new Set(visitedQuestions);
          newVisited.add(newIndex);
          
          set({ 
            currentQuestionIndex: newIndex,
            visitedQuestions: newVisited
          });
        }
      },
      
      previousQuestion: () => {
        const { currentQuestionIndex } = get();
        if (currentQuestionIndex > 0) {
          set({ currentQuestionIndex: currentQuestionIndex - 1 });
        }
      },
      
      pauseExam: () => set({ isPaused: true }),
      
      resumeExam: () => set({ isPaused: false }),
      
      decrementTimer: () => {
        set((state) => ({
          timeRemaining: Math.max(0, state.timeRemaining - 1)
        }));
      },
      
      toggleSummary: () => {
        set((state) => ({ showSummary: !state.showSummary }));
      },
      
      setReviewMode: (isReview) => {
        set({ reviewMode: isReview });
      },
      
      completeExam: () => {
        set({ 
          isCompleted: true,
          endTime: new Date() 
        });
      },
      
      resetExam: () => {
        set({
          examId: undefined,
          attemptId: undefined,
          questions: [],
          currentQuestionIndex: 0,
          timeRemaining: 0,
          startTime: undefined,
          endTime: undefined,
          answers: {},
          flaggedQuestions: new Set<number>(),
          visitedQuestions: new Set<number>(),
          isPaused: false,
          isCompleted: false,
          showSummary: false,
          reviewMode: false,
        });
      },
      
      // Getters
      hasAnswer: (questionId) => {
        return !!get().answers[questionId];
      },
      
      isFlagged: (questionId) => {
        return get().flaggedQuestions.has(questionId);
      },
      
      getAnsweredQuestionsCount: () => {
        return Object.keys(get().answers).length;
      },
      
      getFlaggedQuestionsCount: () => {
        return get().flaggedQuestions.size;
      },
      
      getCompletionPercentage: () => {
        const { questions, answers } = get();
        if (questions.length === 0) return 0;
        return (Object.keys(answers).length / questions.length) * 100;
      },
    }),
    {
      name: 'exam-store',
      partialize: (state) => ({
        // Only persist these fields
        examId: state.examId,
        attemptId: state.attemptId,
        questions: state.questions,
        currentQuestionIndex: state.currentQuestionIndex,
        timeRemaining: state.timeRemaining,
        startTime: state.startTime,
        answers: state.answers,
        flaggedQuestions: Array.from(state.flaggedQuestions),
        visitedQuestions: Array.from(state.visitedQuestions),
        isPaused: state.isPaused,
        isCompleted: state.isCompleted,
      }),
      onRehydrateStorage: (state) => {
        // Convert arrays back to Sets after rehydration
        if (state) {
          return (rehydratedState, error) => {
            if (error) {
              console.error('Error rehydrating exam store:', error);
            } else if (rehydratedState) {
              // Convert arrays back to Sets
              rehydratedState.flaggedQuestions = new Set(rehydratedState.flaggedQuestions || []);
              rehydratedState.visitedQuestions = new Set(rehydratedState.visitedQuestions || []);
            }
          };
        }
      },
    }
  )
);
</file>

<file path="src/features/exams/store/index.ts">
export * from './examStore';
export * from './mcqExamStore';
export * from './examPaperStore';
export * from './examSlice';
</file>

<file path="src/features/exams/store/mcqExamStore.ts">
import { create } from 'zustand';
import { examService } from '../api/core/examService';
import { Exam, ExamAttempt, UserAnswer, ExamResult, FlaggedQuestion } from '../model/mcqTypes';
import logger from '@/shared/lib/logger';

interface McqExamState {
  // State
  currentExam?: Exam;
  currentAttempt?: ExamAttempt;
  currentQuestionIndex: number;
  timeRemaining: number;
  userAnswers: { [questionId: number]: UserAnswer };
  flaggedQuestions: Set<number>;
  isPaused: boolean;
  isCompleted: boolean;
  isLoading: boolean;
  error?: string;
  examResult?: ExamResult;
  
  // Actions
  fetchPublishedExams: () => Promise<Exam[]>;
  fetchExamById: (examId: number) => Promise<void>;
  startExam: (examId: number) => Promise<void>;
  answerQuestion: (answer: UserAnswer) => void;
  nextQuestion: () => void;
  previousQuestion: () => void;
  flagQuestion: (questionId: number) => Promise<void>;
  unflagQuestion: (questionId: number) => Promise<void>;
  pauseExam: () => void;
  resumeExam: () => void;
  completeExam: () => Promise<void>;
  resetExam: () => void;
  updateTimeRemaining: (seconds: number) => void;
}

export const useMcqExamStore = create<McqExamState>((set, get) => ({
  currentQuestionIndex: 0,
  timeRemaining: 0,
  userAnswers: {},
  flaggedQuestions: new Set<number>(),
  isPaused: false,
  isCompleted: false,
  isLoading: false,
  
  fetchPublishedExams: async () => {
    try {
      set({ isLoading: true });
      const exams = await examService.getPublishedExams();
      set({ isLoading: false });
      return exams;
    } catch (error) {
      logger.error('Failed to fetch exams', { 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
      set({ 
        isLoading: false, 
        error: error instanceof Error ? error.message : 'Failed to fetch exams' 
      });
      return [];
    }
  },
  
  fetchExamById: async (examId) => {
    try {
      set({ isLoading: true });
      const exam = await examService.getExamById(examId);
      set({ 
        currentExam: exam,
        timeRemaining: exam.duration * 60, // Convert minutes to seconds
        isLoading: false 
      });
    } catch (error) {
      logger.error('Failed to fetch exam by ID', { 
        examId,
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
      set({ 
        isLoading: false, 
        error: error instanceof Error ? error.message : `Failed to fetch exam ${examId}` 
      });
    }
  },
  
  startExam: async (examId) => {
    try {
      set({ isLoading: true });
      // First get the exam if not already loaded
      if (!get().currentExam || get().currentExam.id !== examId) {
        await get().fetchExamById(examId);
      }
      
      try {
        const attempt = await examService.startExam(examId);
        console.log('Exam attempt in store:', attempt);
        
        // Set timeRemaining based on current exam duration if it exists
        const currentExam = get().currentExam;
        const timeRemainingSeconds = currentExam ? currentExam.duration * 60 : 0;
        
        // Also fetch flagged questions if any exist
        let flaggedQuestions = new Set<number>();
        try {
          const flagged = await examService.getFlaggedQuestions(attempt.id);
          flaggedQuestions = new Set(flagged.map(f => f.questionId));
        } catch (err) {
          // Ignore errors fetching flagged questions
          console.warn('Could not fetch flagged questions', err);
        }
        
        set({
          currentAttempt: attempt,
          currentQuestionIndex: 0,
          userAnswers: {},
          flaggedQuestions,
          timeRemaining: timeRemainingSeconds,
          isPaused: false,
          isCompleted: false,
          examResult: undefined,
          isLoading: false,
          error: undefined // Clear any previous errors
        });
      } catch (error) {
        logger.error('Failed to start exam', { 
          examId,
          error: error instanceof Error ? error.message : 'Unknown error' 
        });
        set({ 
          isLoading: false, 
          error: error instanceof Error ? error.message : `Failed to start exam ${examId}` 
        });
      }
    } catch (error) {
      logger.error('Failed to start exam', { 
        examId,
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
      set({ 
        isLoading: false, 
        error: error instanceof Error ? error.message : `Failed to start exam ${examId}` 
      });
    }
  },
  
  answerQuestion: (answer) => {
    set((state) => ({
      userAnswers: {
        ...state.userAnswers,
        [answer.questionId]: answer,
      },
    }));
  },
  
  nextQuestion: () => {
    const { currentQuestionIndex, currentExam } = get();
    if (currentExam?.questions && currentQuestionIndex < currentExam.questions.length - 1) {
      set({ currentQuestionIndex: currentQuestionIndex + 1 });
    }
  },
  
  previousQuestion: () => {
    const { currentQuestionIndex } = get();
    if (currentQuestionIndex > 0) {
      set({ currentQuestionIndex: currentQuestionIndex - 1 });
    }
  },
  
  flagQuestion: async (questionId) => {
    const { currentAttempt, flaggedQuestions } = get();
    
    if (!currentAttempt) {
      logger.error('No active exam attempt');
      throw new Error('No active exam attempt');
    }
    
    try {
      set({ isLoading: true });
      
      // Add to local state immediately for responsive UI
      const newFlagged = new Set(flaggedQuestions);
      newFlagged.add(questionId);
      set({ flaggedQuestions: newFlagged });
      
      // Then persist to server
      await examService.flagQuestion(currentAttempt.id, questionId);
      set({ isLoading: false });
    } catch (error) {
      logger.error('Failed to flag question', {
        questionId,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      
      // Rollback if server call fails
      const rollbackFlagged = new Set(get().flaggedQuestions);
      rollbackFlagged.delete(questionId);
      
      set({
        flaggedQuestions: rollbackFlagged,
        isLoading: false,
        error: error instanceof Error ? error.message : 'Failed to flag question'
      });
    }
  },
  
  unflagQuestion: async (questionId) => {
    const { currentAttempt, flaggedQuestions } = get();
    
    if (!currentAttempt) {
      logger.error('No active exam attempt');
      throw new Error('No active exam attempt');
    }
    
    try {
      set({ isLoading: true });
      
      // Remove from local state immediately for responsive UI
      const newFlagged = new Set(flaggedQuestions);
      newFlagged.delete(questionId);
      set({ flaggedQuestions: newFlagged });
      
      // Then persist to server
      await examService.unflagQuestion(currentAttempt.id, questionId);
      set({ isLoading: false });
    } catch (error) {
      logger.error('Failed to unflag question', {
        questionId,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      
      // Rollback if server call fails
      const rollbackFlagged = new Set(get().flaggedQuestions);
      rollbackFlagged.add(questionId);
      
      set({
        flaggedQuestions: rollbackFlagged,
        isLoading: false,
        error: error instanceof Error ? error.message : 'Failed to unflag question'
      });
    }
  },
  
  pauseExam: () => set({ isPaused: true }),
  
  resumeExam: () => set({ isPaused: false }),
  
  completeExam: async () => {
    const { currentAttempt, userAnswers } = get();
    
    if (!currentAttempt) {
      logger.error('No active exam attempt to submit');
      set({ error: 'No active exam attempt to submit' });
      return;
    }
    
    try {
      set({ isLoading: true });
      
      // Convert userAnswers object to array
      const answersArray = Object.values(userAnswers);
      
      logger.info('Submitting exam', { 
        attemptId: currentAttempt.id,
        answersCount: answersArray.length
      });
      
      const result = await examService.submitExam(currentAttempt.id, answersArray);
      
      set({ 
        examResult: result,
        isCompleted: true,
        isLoading: false
      });
    } catch (error) {
      logger.error('Failed to submit exam', { 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
      set({ 
        isLoading: false, 
        error: error instanceof Error ? error.message : 'Failed to submit exam' 
      });
    }
  },
  
  resetExam: () => {
    set({
      currentExam: undefined,
      currentAttempt: undefined,
      currentQuestionIndex: 0,
      timeRemaining: 0,
      userAnswers: {},
      flaggedQuestions: new Set(),
      isPaused: false,
      isCompleted: false,
      examResult: undefined,
      error: undefined
    });
  },
  
  updateTimeRemaining: (seconds) => {
    set({ timeRemaining: seconds });
  }
}));
</file>

<file path="src/features/exams/types/index.ts">
export interface ExamPaper {
  id: string;
  title: string;
  description: string;
  difficulty: 'easy' | 'medium' | 'hard';
  totalQuestions: number;
  duration: number;
  topics: string[];
  isPremium: boolean;
  attempts: number;
  successRate: number;
  lastUpdated: string;
  source: 'model' | 'past';
}

export interface ExamPaperMetadata {
  id: string;
  title: string;
  description: string;
  difficulty: 'easy' | 'medium' | 'hard';
  topics_covered: string[];
  total_questions: number;
  time_limit: number;
  is_premium: boolean;
  source: 'model' | 'past';
}

export interface Exam {
  id: number;
  title: string;
  description: string;
  duration: number;
  maxScore: number;
  passingScore: number;
  status: ExamStatusType;
  questions: ExamQuestion[];
}

export interface ExamQuestion {
  id: number;
  text: string;
  options: ExamOption[];
  explanation: string;
  points: number;
}

export interface ExamOption {
  id: string;
  text: string;
  isCorrect: boolean;
}

export enum ExamStatus {
  DRAFT = 'DRAFT',
  PUBLISHED = 'PUBLISHED',
  ARCHIVED = 'ARCHIVED'
}

export type ExamStatusType = keyof typeof ExamStatus;
</file>

<file path="src/features/exams/ui/components/ExamProgress.tsx">
'use client';

import React from 'react';
import { Progress } from '@/components/ui/progress';
import { Badge } from '@/components/ui/badge';

interface ExamProgressProps {
  currentQuestion: number;
  totalQuestions: number;
  answeredQuestions: number;
}

export function ExamProgress({
  currentQuestion,
  totalQuestions,
  answeredQuestions,
}: ExamProgressProps) {
  const progressPercentage = Math.round((answeredQuestions / totalQuestions) * 100);
  const questionProgressPercentage = Math.round(((currentQuestion + 1) / totalQuestions) * 100);
  
  return (
    <div className="w-full space-y-2">
      <div className="flex justify-between text-sm">
        <span className="text-muted-foreground">
          Question {currentQuestion + 1} of {totalQuestions}
        </span>
        <Badge variant="outline">
          {answeredQuestions}/{totalQuestions} answered
        </Badge>
      </div>
      
      <div className="space-y-1">
        <Progress 
          value={questionProgressPercentage} 
          className="h-1"
        />
        <Progress 
          value={progressPercentage} 
          className="h-1"
          // The progress color is handled by shadcn's default styling
        />
      </div>
      
      <div className="flex justify-between text-xs text-muted-foreground">
        <span>Current progress</span>
        <span>{progressPercentage}% complete</span>
      </div>
    </div>
  );
}
</file>

<file path="src/features/exams/ui/components/ExamResults.tsx">
'use client';

import React from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { CheckCircle, XCircle } from 'lucide-react';
import { Progress } from '@/components/ui/progress';
import { Separator } from '@/components/ui/separator';
import { ExamResult, Question, UserAnswer } from '../../model/mcqTypes';

interface ExamResultsProps {
  result: ExamResult;
  questions: Question[];
  userAnswers: Record<number, UserAnswer>;
  onReturnToDashboard: () => void;
}

export function ExamResults({
  result,
  questions,
  userAnswers,
  onReturnToDashboard,
}: ExamResultsProps) {
  const scorePercentage = result.score;
  const isPassed = result.isPassed;
  
  // Calculate time spent in minutes and seconds
  const totalSeconds = result.timeSpent;
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  
  return (
    <Card className="w-full">
      <CardHeader>
        <CardTitle className="flex items-center">
          <span>Exam Results: {result.examTitle}</span>
          {isPassed ? (
            <span className="ml-2 text-sm bg-green-100 text-green-800 py-1 px-2 rounded-full">Passed</span>
          ) : (
            <span className="ml-2 text-sm bg-red-100 text-red-800 py-1 px-2 rounded-full">Failed</span>
          )}
        </CardTitle>
        <CardDescription>
          Completed on {new Date(result.completedAt).toLocaleString()}
        </CardDescription>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-2 gap-6 mb-6">
          <div className="space-y-4">
            <div>
              <div className="text-sm text-muted-foreground">Your Score</div>
              <div className="text-3xl font-bold">
                {scorePercentage.toFixed(1)}%
              </div>
              <div className="text-sm text-muted-foreground">
                Passing score: {result.passingMarks}%
              </div>
            </div>
            
            <Progress 
              value={scorePercentage} 
              className="h-2"
            />
          </div>
          
          <div className="space-y-2">
            <div className="flex justify-between">
              <div className="text-sm">Total Questions</div>
              <div className="font-medium">{result.totalQuestions}</div>
            </div>
            <div className="flex justify-between">
              <div className="text-sm">Correct Answers</div>
              <div className="font-medium text-green-600">{result.correctAnswers}</div>
            </div>
            <div className="flex justify-between">
              <div className="text-sm">Incorrect Answers</div>
              <div className="font-medium text-red-600">{result.incorrectAnswers}</div>
            </div>
            <div className="flex justify-between">
              <div className="text-sm">Unanswered</div>
              <div className="font-medium">{result.unanswered}</div>
            </div>
            <div className="flex justify-between">
              <div className="text-sm">Time Taken</div>
              <div className="font-medium">{minutes}m {seconds}s</div>
            </div>
          </div>
        </div>
        
        <Separator className="my-6" />
        
        <Tabs defaultValue="all" className="w-full">
          <TabsList className="grid w-full grid-cols-3">
            <TabsTrigger value="all">All Questions</TabsTrigger>
            <TabsTrigger value="correct">Correct</TabsTrigger>
            <TabsTrigger value="incorrect">Incorrect</TabsTrigger>
          </TabsList>
          
          <TabsContent value="all" className="mt-4 space-y-4">
            {questions.map((question, index) => {
              const userAnswer = userAnswers[question.id];
              const questionResult = result.questionResults.find(qr => qr.questionId === question.id);
              const isCorrect = questionResult?.isCorrect || false;
              
              return (
                <div key={question.id} className="border rounded-md p-4">
                  <div className="flex items-start justify-between">
                    <div className="font-medium">Question {index + 1}</div>
                    {isCorrect ? (
                      <CheckCircle className="h-5 w-5 text-green-500" />
                    ) : (
                      <XCircle className="h-5 w-5 text-red-500" />
                    )}
                  </div>
                  <p className="mt-2">{question.text}</p>
                  
                  <div className="mt-3 space-y-2">
                    {question.options.map((option, optIndex) => {
                      const isUserSelection = userAnswer?.selectedOption === optIndex;
                      const isCorrectOption = questionResult?.correctAnswerId === option.id;
                      
                      return (
                        <div 
                          key={optIndex}
                          className={`p-2 border rounded-md ${
                            isUserSelection && isCorrectOption
                              ? 'bg-green-50 border-green-300'
                              : isUserSelection && !isCorrectOption
                              ? 'bg-red-50 border-red-300'
                              : isCorrectOption
                              ? 'bg-green-50 border-green-300'
                              : ''
                          }`}
                        >
                          {option}
                          {isUserSelection && isCorrectOption && (
                            <span className="ml-2 text-green-600 text-sm">✓ Your answer (Correct)</span>
                          )}
                          {isUserSelection && !isCorrectOption && (
                            <span className="ml-2 text-red-600 text-sm">✗ Your answer</span>
                          )}
                          {!isUserSelection && isCorrectOption && (
                            <span className="ml-2 text-green-600 text-sm">Correct answer</span>
                          )}
                        </div>
                      );
                    })}
                  </div>
                  
                  {questionResult?.explanation && (
                    <div className="mt-3 text-sm bg-blue-50 p-3 rounded-md">
                      <strong>Explanation:</strong> {questionResult.explanation}
                    </div>
                  )}
                </div>
              );
            })}
          </TabsContent>
          
          <TabsContent value="correct" className="mt-4 space-y-4">
            {questions
              .filter(q => {
                const qResult = result.questionResults.find(r => r.questionId === q.id);
                return qResult?.isCorrect;
              })
              .map((question, index) => {
                const userAnswer = userAnswers[question.id];
                const questionResult = result.questionResults.find(qr => qr.questionId === question.id);
                
                return (
                  <div key={question.id} className="border rounded-md p-4">
                    <div className="flex items-start justify-between">
                      <div className="font-medium">Question {questions.findIndex(q => q.id === question.id) + 1}</div>
                      <CheckCircle className="h-5 w-5 text-green-500" />
                    </div>
                    <p className="mt-2">{question.text}</p>
                    
                    <div className="mt-3 space-y-2">
                      {question.options.map((option, optIndex) => {
                        const isUserSelection = userAnswer?.selectedOption === optIndex;
                        const isCorrectOption = questionResult?.correctAnswerId === option.id;
                        
                        return (
                          <div 
                            key={optIndex}
                            className={`p-2 border rounded-md ${
                              isUserSelection && isCorrectOption
                                ? 'bg-green-50 border-green-300'
                                : ''
                            }`}
                          >
                            {option}
                            {isUserSelection && isCorrectOption && (
                              <span className="ml-2 text-green-600 text-sm">✓ Your answer (Correct)</span>
                            )}
                          </div>
                        );
                      })}
                    </div>
                    
                    {questionResult?.explanation && (
                      <div className="mt-3 text-sm bg-blue-50 p-3 rounded-md">
                        <strong>Explanation:</strong> {questionResult.explanation}
                      </div>
                    )}
                  </div>
                );
              })
            }
          </TabsContent>
          
          <TabsContent value="incorrect" className="mt-4 space-y-4">
            {questions
              .filter(q => {
                const qResult = result.questionResults.find(r => r.questionId === q.id);
                return !qResult?.isCorrect;
              })
              .map((question, index) => {
                const userAnswer = userAnswers[question.id];
                const questionResult = result.questionResults.find(qr => qr.questionId === question.id);
                
                return (
                  <div key={question.id} className="border rounded-md p-4">
                    <div className="flex items-start justify-between">
                      <div className="font-medium">Question {questions.findIndex(q => q.id === question.id) + 1}</div>
                      <XCircle className="h-5 w-5 text-red-500" />
                    </div>
                    <p className="mt-2">{question.text}</p>
                    
                    <div className="mt-3 space-y-2">
                      {question.options.map((option, optIndex) => {
                        const isUserSelection = userAnswer?.selectedOption === optIndex;
                        const isCorrectOption = questionResult?.correctAnswerId === option.id;
                        
                        return (
                          <div 
                            key={optIndex}
                            className={`p-2 border rounded-md ${
                              isUserSelection && !isCorrectOption
                                ? 'bg-red-50 border-red-300'
                                : isCorrectOption
                                ? 'bg-green-50 border-green-300'
                                : ''
                            }`}
                          >
                            {option}
                            {isUserSelection && !isCorrectOption && (
                              <span className="ml-2 text-red-600 text-sm">✗ Your answer</span>
                            )}
                            {!isUserSelection && isCorrectOption && (
                              <span className="ml-2 text-green-600 text-sm">Correct answer</span>
                            )}
                          </div>
                        );
                      })}
                    </div>
                    
                    {questionResult?.explanation && (
                      <div className="mt-3 text-sm bg-blue-50 p-3 rounded-md">
                        <strong>Explanation:</strong> {questionResult.explanation}
                      </div>
                    )}
                  </div>
                );
              })
            }
          </TabsContent>
        </Tabs>
        
        <div className="mt-8">
          <Button 
            onClick={onReturnToDashboard}
            className="w-full"
          >
            Return to Dashboard
          </Button>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/exams/ui/components/ExamSummary.tsx">
'use client';

import React from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { CheckCircle, XCircle, BookmarkIcon, Circle } from 'lucide-react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from '@/components/ui/dialog';
import { Question } from '../../model/mcqTypes';

interface ExamSummaryProps {
  questions: Question[];
  answeredQuestionIds: Set<number>;
  flaggedQuestionIds: Set<number>;
  onNavigateToQuestion: (index: number) => void;
  onSubmitExam: () => void;
}

export function ExamSummary({
  questions,
  answeredQuestionIds,
  flaggedQuestionIds,
  onNavigateToQuestion,
  onSubmitExam,
}: ExamSummaryProps) {
  const [showConfirmDialog, setShowConfirmDialog] = React.useState(false);
  
  const totalQuestions = questions.length;
  const answeredCount = answeredQuestionIds.size;
  const unansweredCount = totalQuestions - answeredCount;
  const flaggedCount = flaggedQuestionIds.size;
  
  const handleSubmitClick = () => {
    if (unansweredCount > 0) {
      setShowConfirmDialog(true);
    } else {
      onSubmitExam();
    }
  };
  
  return (
    <>
      <Card className="w-full">
        <CardHeader>
          <CardTitle>Exam Summary</CardTitle>
          <CardDescription>
            Review your progress before submitting
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-2 gap-4 mb-6">
            <div className="space-y-1">
              <div className="text-sm text-muted-foreground">Total Questions</div>
              <div className="text-2xl font-bold">{totalQuestions}</div>
            </div>
            <div className="space-y-1">
              <div className="text-sm text-muted-foreground">Completion</div>
              <div className="text-2xl font-bold">{Math.round((answeredCount / totalQuestions) * 100)}%</div>
            </div>
            <div className="space-y-1 flex items-center">
              <CheckCircle className="h-4 w-4 text-green-500 mr-2" />
              <div>
                <div className="text-sm text-muted-foreground">Answered</div>
                <div className="text-xl font-semibold">{answeredCount}</div>
              </div>
            </div>
            <div className="space-y-1 flex items-center">
              <Circle className="h-4 w-4 text-gray-300 mr-2" />
              <div>
                <div className="text-sm text-muted-foreground">Unanswered</div>
                <div className="text-xl font-semibold">{unansweredCount}</div>
              </div>
            </div>
            <div className="space-y-1 flex items-center">
              <BookmarkIcon className="h-4 w-4 text-yellow-500 mr-2" />
              <div>
                <div className="text-sm text-muted-foreground">Flagged</div>
                <div className="text-xl font-semibold">{flaggedCount}</div>
              </div>
            </div>
          </div>
          
          <div className="space-y-4">
            <h3 className="text-sm font-medium">Question Status</h3>
            <div className="grid grid-cols-5 gap-2">
              {questions.map((question, index) => {
                const isAnswered = answeredQuestionIds.has(question.id);
                const isFlagged = flaggedQuestionIds.has(question.id);
                
                return (
                  <Button
                    key={question.id}
                    variant="outline"
                    size="sm"
                    className={`relative w-10 h-10 p-0 ${
                      isFlagged ? "border-yellow-500" : ""
                    } ${
                      isAnswered ? "bg-green-50" : "bg-red-50"
                    }`}
                    onClick={() => onNavigateToQuestion(index)}
                  >
                    <span>{index + 1}</span>
                    
                    {isAnswered ? (
                      <CheckCircle 
                        className="absolute -top-1 -right-1 h-3 w-3 text-green-500"
                      />
                    ) : (
                      <XCircle 
                        className="absolute -top-1 -right-1 h-3 w-3 text-red-500"
                      />
                    )}
                    
                    {isFlagged && (
                      <BookmarkIcon 
                        className="absolute -bottom-1 -right-1 h-3 w-3 text-yellow-500"
                      />
                    )}
                  </Button>
                );
              })}
            </div>
          </div>
          
          <div className="mt-8 space-y-4">
            <Button 
              className="w-full" 
              onClick={handleSubmitClick}
            >
              Submit Exam
            </Button>
            
            {unansweredCount > 0 && (
              <p className="text-sm text-muted-foreground text-center">
                You have {unansweredCount} unanswered {unansweredCount === 1 ? 'question' : 'questions'}.
                Click on any question number to navigate to it.
              </p>
            )}
          </div>
        </CardContent>
      </Card>
      
      <Dialog open={showConfirmDialog} onOpenChange={setShowConfirmDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Submit with unanswered questions?</DialogTitle>
            <DialogDescription>
              You have {unansweredCount} unanswered {unansweredCount === 1 ? 'question' : 'questions'}.
              Are you sure you want to submit your exam?
            </DialogDescription>
          </DialogHeader>
          <DialogFooter className="flex items-center justify-end space-x-2 pt-4">
            <Button
              variant="outline"
              onClick={() => setShowConfirmDialog(false)}
            >
              Continue Exam
            </Button>
            <Button
              variant="destructive"
              onClick={() => {
                setShowConfirmDialog(false);
                onSubmitExam();
              }}
            >
              Submit Anyway
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}
</file>

<file path="src/features/exams/ui/components/ExamTimer.tsx">
'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Pause, Play, Clock } from 'lucide-react';

interface ExamTimerProps {
  durationInMinutes: number;
  onTimeExpired: () => void;
  allowPause?: boolean;
}

export function ExamTimer({
  durationInMinutes,
  onTimeExpired,
  allowPause = false,
}: ExamTimerProps) {
  // Convert duration to seconds
  const totalSeconds = durationInMinutes * 60;
  const [timeRemaining, setTimeRemaining] = useState(totalSeconds);
  const [isPaused, setIsPaused] = useState(false);
  
  // Format time as mm:ss
  const formatTime = (seconds: number) => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
  };
  
  // Calculate percentage of time remaining
  const percentageRemaining = (timeRemaining / totalSeconds) * 100;
  
  // Determine color based on percentage remaining
  const getTimerColor = () => {
    if (percentageRemaining > 50) return 'text-green-500';
    if (percentageRemaining > 25) return 'text-yellow-500';
    return 'text-red-500';
  };
  
  // Handle timer tick
  const tick = useCallback(() => {
    setTimeRemaining((prevTime) => {
      if (prevTime <= 1) {
        onTimeExpired();
        return 0;
      }
      return prevTime - 1;
    });
  }, [onTimeExpired]);
  
  // Toggle pause state
  const togglePause = () => {
    setIsPaused((prev) => !prev);
  };
  
  // Set up timer
  useEffect(() => {
    if (isPaused) return;
    
    const timerId = setInterval(tick, 1000);
    
    // Clean up interval on unmount
    return () => clearInterval(timerId);
  }, [tick, isPaused]);
  
  return (
    <Card className="w-full">
      <CardContent className="p-4 flex justify-between items-center">
        <div className="flex items-center">
          <Clock className={`mr-2 h-5 w-5 ${getTimerColor()}`} />
          <span className={`font-mono text-lg font-bold ${getTimerColor()}`}>
            {formatTime(timeRemaining)}
          </span>
        </div>
        
        {allowPause && (
          <Button
            size="sm"
            variant="ghost"
            onClick={togglePause}
            aria-label={isPaused ? "Resume timer" : "Pause timer"}
          >
            {isPaused ? (
              <Play className="h-4 w-4" />
            ) : (
              <Pause className="h-4 w-4" />
            )}
          </Button>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/exams/ui/components/QuestionDisplay.tsx">
'use client';

import React from 'react';
import { Question, UserAnswer } from '../../model/mcqTypes';
import { Card, CardContent } from '@/components/ui/card';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Label } from '@/components/ui/label';
import { Button } from '@/components/ui/button';
import { BookmarkIcon } from 'lucide-react';

interface QuestionDisplayProps {
  question: Question;
  userAnswer?: number;
  isFlagged?: boolean;
  onAnswerSelect: (questionId: number, optionIndex: number) => void;
  onFlagQuestion: (questionId: number) => void;
}

export function QuestionDisplay({
  question,
  userAnswer,
  isFlagged = false,
  onAnswerSelect,
  onFlagQuestion,
}: QuestionDisplayProps) {
  const handleAnswerSelect = (optionIndex: string) => {
    onAnswerSelect(question.id, parseInt(optionIndex));
  };

  const handleFlagToggle = () => {
    onFlagQuestion(question.id);
  };

  return (
    <Card className="w-full">
      <CardContent className="pt-6">
        <div className="flex justify-between items-start mb-4">
          <h3 className="text-lg font-medium leading-6">
            {question.text}
          </h3>
          <Button 
            variant="ghost" 
            size="icon" 
            onClick={handleFlagToggle}
            aria-label={isFlagged ? "Unflag question" : "Flag question for review"}
          >
            <BookmarkIcon className={`h-5 w-5 ${isFlagged ? "fill-yellow-400 text-yellow-400" : ""}`} />
          </Button>
        </div>

        <RadioGroup
          value={userAnswer?.toString() || ''}
          onValueChange={handleAnswerSelect}
          className="space-y-3 mt-4"
        >
          {question.options.map((option, index) => (
            <div key={index} className="flex items-center space-x-2 border p-3 rounded-md">
              <RadioGroupItem value={index.toString()} id={`option-${question.id}-${index}`} />
              <Label htmlFor={`option-${question.id}-${index}`} className="flex-grow cursor-pointer">
                {option}
              </Label>
            </div>
          ))}
        </RadioGroup>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/exams/ui/components/QuestionNavigation.tsx">
'use client';

import React from 'react';
import { Button } from '@/components/ui/button';
import { 
  ChevronLeft, 
  ChevronRight, 
  CheckCircle, 
  BookmarkIcon as Bookmark,
  Circle
} from 'lucide-react';

interface QuestionNavigationProps {
  currentIndex: number;
  totalQuestions: number;
  answeredQuestions: Set<number>;
  flaggedQuestions: Set<number>;
  onNavigate: (index: number) => void;
  onFinishExam: () => void;
}

export function QuestionNavigation({
  currentIndex,
  totalQuestions,
  answeredQuestions,
  flaggedQuestions,
  onNavigate,
  onFinishExam,
}: QuestionNavigationProps) {
  // Create array of question numbers from 0 to totalQuestions - 1
  const questionIndices = Array.from({ length: totalQuestions }, (_, i) => i);
  
  return (
    <div className="w-full">
      <div className="flex justify-between items-center mb-4">
        <Button
          variant="outline"
          size="sm"
          onClick={() => onNavigate(currentIndex - 1)}
          disabled={currentIndex === 0}
        >
          <ChevronLeft className="h-4 w-4 mr-2" />
          Previous
        </Button>
        {currentIndex < totalQuestions - 1 ? (
          <Button
            variant="outline"
            size="sm"
            onClick={() => onNavigate(currentIndex + 1)}
            disabled={currentIndex === totalQuestions - 1}
          >
            Next
            <ChevronRight className="h-4 w-4 ml-2" />
          </Button>
        ) : (
          <Button
            variant="default"
            size="sm"
            onClick={onFinishExam}
          >
            Finish Exam
          </Button>
        )}
      </div>
      
      <div className="flex flex-wrap gap-2 mt-6">
        {questionIndices.map((index) => {
          const isAnswered = answeredQuestions.has(index);
          const isFlagged = flaggedQuestions.has(index);
          const isCurrent = index === currentIndex;
          
          return (
            <Button
              key={index}
              variant={isCurrent ? "default" : "outline"}
              size="sm"
              className={`relative w-10 h-10 p-0 ${
                isFlagged ? "border-yellow-500" : ""
              }`}
              onClick={() => onNavigate(index)}
            >
              <span>{index + 1}</span>
              
              {isAnswered && (
                <CheckCircle 
                  className="absolute -top-1 -right-1 h-3 w-3 text-green-500"
                />
              )}
              
              {isFlagged && (
                <Bookmark 
                  className="absolute -bottom-1 -right-1 h-3 w-3 text-yellow-500"
                />
              )}
            </Button>
          );
        })}
      </div>
      
      <div className="flex justify-between text-sm text-muted-foreground mt-4">
        <div className="flex items-center gap-1">
          <CheckCircle className="h-3 w-3 text-green-500" />
          <span>Answered ({answeredQuestions.size})</span>
        </div>
        <div className="flex items-center gap-1">
          <Bookmark className="h-3 w-3 text-yellow-500" />
          <span>Flagged ({flaggedQuestions.size})</span>
        </div>
        <div className="flex items-center gap-1">
          <Circle className="h-3 w-3 text-gray-300" />
          <span>Unanswered ({totalQuestions - answeredQuestions.size})</span>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/features/exams/ui/ExamContainer.tsx">
'use client';

import React, { useEffect, useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Separator } from '@/components/ui/separator';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Skeleton } from '@/components/ui/skeleton';
import { toast } from 'sonner';

import { useExamQueries } from '@/features/exams/hooks';
const useExamSession = useExamQueries.useExam;
import { QuestionDisplay } from './components/QuestionDisplay';
import { QuestionNavigation } from './components/QuestionNavigation';
import { ExamProgress } from './components/ExamProgress';
import { ExamTimer } from './components/ExamTimer';
import { ExamSummary } from './components/ExamSummary';
import { ExamResults } from './components/ExamResults';

interface ExamContainerProps {
  examId: number;
  userId: string;
  onExit?: () => void;
}

export function ExamContainer({ 
  examId, 
  userId,
  onExit 
}: ExamContainerProps) {
  const [attemptId, setAttemptId] = useState<number | null>(null);
  const [showResults, setShowResults] = useState(false);
  
  const {
    // Data
    exam,
    questions,
    currentQuestionIndex,
    answers,
    flaggedQuestions,
    timeRemaining,
    isCompleted,
    showSummary,
    
    // Loading states
    isLoading,
    error,
    isStarting,
    isSubmitting,
    isSaving,
    isFlagging,
    startError,
    submitError,
    
    // Actions
    startExam,
    answerQuestion,
    toggleFlagQuestion,
    navigateToQuestion,
    nextQuestion,
    previousQuestion,
    toggleSummary,
    submitExam,
    handleTimeExpired,
    
    // Helpers
    hasAnswer,
    isFlagged,
    getAnsweredQuestionsCount,
    getFlaggedQuestionsCount,
    getCompletionPercentage
  } = useExamSession(examId);
  
  // Handle exam start
  const handleStartExam = () => {
    startExam(
      { userId },
      {
        onSuccess: (data) => {
          setAttemptId(data.id);
          toast.success('Exam started successfully!');
        },
        onError: (error) => {
          toast.error('Failed to start exam: ' + (error instanceof Error ? error.message : 'Unknown error'));
        }
      }
    );
  };
  
  // Handle exam submission
  const handleSubmitExam = () => {
    submitExam(
      undefined,
      {
        onSuccess: (data) => {
          setShowResults(true);
          toast.success('Exam submitted successfully!');
        },
        onError: (error) => {
          toast.error('Failed to submit exam: ' + (error instanceof Error ? error.message : 'Unknown error'));
        }
      }
    );
  };
  
  // Return to dashboard
  const handleReturnToDashboard = () => {
    if (onExit) {
      onExit();
    } else {
      // Fallback navigation if onExit isn't provided
      window.location.href = '/dashboard';
    }
  };
  
  // Handle timer expiration
  useEffect(() => {
    if (timeRemaining === 0 && !isCompleted && attemptId) {
      toast.warning('Time is up! Your exam will be submitted automatically.');
      submitExam();
    }
  }, [timeRemaining, isCompleted, attemptId, submitExam]);
  
  // Loading state
  if (isLoading) {
    return (
      <Card className="w-full">
        <CardHeader>
          <CardTitle>
            <Skeleton className="h-8 w-3/4" />
          </CardTitle>
        </CardHeader>
        <CardContent>
          <Skeleton className="h-64 w-full" />
        </CardContent>
      </Card>
    );
  }
  
  // Error state
  if (error) {
    return (
      <Alert variant="destructive">
        <AlertTitle>Error</AlertTitle>
        <AlertDescription>
          {error instanceof Error ? error.message : 'An unknown error occurred'}
        </AlertDescription>
      </Alert>
    );
  }
  
  // If no exam data is available
  if (!exam || !questions || questions.length === 0) {
    return (
      <Alert>
        <AlertTitle>No exam found</AlertTitle>
        <AlertDescription>
          We couldn&apos;t find the requested exam. Please check the exam ID and try again.
        </AlertDescription>
      </Alert>
    );
  }
  
  // Current question
  const currentQuestion = questions[currentQuestionIndex];
  const answeredQuestionsSet = new Set(
    Object.values(answers).map(answer => answer.questionId)
  );
  
  // Show exam results
  if (showResults) {
    return (
      <ExamResults
        result={{
          attemptId: attemptId as number,
          examId: exam.id,
          examTitle: exam.title,
          score: 75, // TODO: Get actual score from API
          totalMarks: exam.totalMarks,
          passingMarks: exam.passingMarks,
          isPassed: true, // TODO: Get actual pass status from API
          timeSpent: 1800, // TODO: Calculate actual time spent
          totalQuestions: questions.length,
          correctAnswers: 15, // TODO: Get actual count from API
          incorrectAnswers: 5, // TODO: Get actual count from API
          unanswered: 0, // TODO: Get actual count from API
          completedAt: new Date().toISOString(),
          questionResults: [] // TODO: Get actual results from API
        }}
        questions={questions}
        userAnswers={answers}
        onReturnToDashboard={handleReturnToDashboard}
      />
    );
  }
  
  // Show exam summary
  if (showSummary) {
    return (
      <ExamSummary
        questions={questions}
        answeredQuestionIds={answeredQuestionsSet}
        flaggedQuestionIds={flaggedQuestions}
        onNavigateToQuestion={(index) => {
          toggleSummary();
          navigateToQuestion(index);
        }}
        onSubmitExam={handleSubmitExam}
      />
    );
  }
  
  // Display exam start screen if not started
  if (!attemptId && !isStarting) {
    return (
      <Card className="w-full">
        <CardHeader>
          <CardTitle>{exam.title}</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-6">
            <div>
              <p className="text-gray-600">{exam.description}</p>
            </div>
            
            <div className="grid grid-cols-2 gap-4 bg-gray-50 p-4 rounded-md">
              <div>
                <h3 className="text-sm font-semibold text-gray-500">Duration</h3>
                <p className="text-lg">{exam.duration} minutes</p>
              </div>
              <div>
                <h3 className="text-sm font-semibold text-gray-500">Total Questions</h3>
                <p className="text-lg">{questions.length}</p>
              </div>
              <div>
                <h3 className="text-sm font-semibold text-gray-500">Total Marks</h3>
                <p className="text-lg">{exam.totalMarks}</p>
              </div>
              <div>
                <h3 className="text-sm font-semibold text-gray-500">Passing Marks</h3>
                <p className="text-lg">{exam.passingMarks}</p>
              </div>
            </div>
            
            <div className="bg-blue-50 border-l-4 border-blue-500 p-4 rounded-md">
              <h3 className="text-blue-800 font-medium">Instructions:</h3>
              <ul className="list-disc list-inside text-blue-700 mt-2 space-y-1">
                <li>Read each question carefully before answering.</li>
                <li>You can flag questions to review later.</li>
                <li>Once the time is up, the exam will be submitted automatically.</li>
                <li>You can review all your answers before final submission.</li>
              </ul>
            </div>
            
            <Button 
              onClick={handleStartExam} 
              disabled={isStarting}
              className="w-full"
              size="lg"
            >
              {isStarting ? 'Starting...' : 'Start Exam'}
            </Button>
            
            {startError && (
              <Alert variant="destructive">
                <AlertDescription>
                  {startError instanceof Error ? startError.message : 'Failed to start exam'}
                </AlertDescription>
              </Alert>
            )}
          </div>
        </CardContent>
      </Card>
    );
  }
  
  // Main exam interface
  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="pb-3">
          <div className="flex justify-between items-center">
            <CardTitle>{exam.title}</CardTitle>
            <div className="flex gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={toggleSummary}
              >
                Review Answers
              </Button>
              <Button
                variant="destructive"
                size="sm"
                onClick={handleSubmitExam}
                disabled={isSubmitting}
              >
                {isSubmitting ? 'Submitting...' : 'Submit Exam'}
              </Button>
            </div>
          </div>
        </CardHeader>
        <CardContent className="pt-0">
          <div className="flex gap-4 mb-4">
            <div className="flex-grow">
              <ExamProgress 
                currentQuestion={currentQuestionIndex}
                totalQuestions={questions.length}
                answeredQuestions={answeredQuestionsSet.size}
              />
            </div>
            <div>
              <ExamTimer 
                durationInMinutes={exam.duration}
                onTimeExpired={handleTimeExpired}
              />
            </div>
          </div>
          
          <Separator className="my-4" />
        </CardContent>
      </Card>
      
      {currentQuestion && (
        <QuestionDisplay
          question={currentQuestion}
          userAnswer={answers[currentQuestion.id]?.selectedOption}
          isFlagged={isFlagged(currentQuestion.id)}
          onAnswerSelect={answerQuestion}
          onFlagQuestion={toggleFlagQuestion}
        />
      )}
      
      <Card>
        <CardContent className="py-4">
          <QuestionNavigation
            currentIndex={currentQuestionIndex}
            totalQuestions={questions.length}
            answeredQuestions={answeredQuestionsSet}
            flaggedQuestions={flaggedQuestions}
            onNavigate={navigateToQuestion}
            onFinishExam={toggleSummary}
          />
        </CardContent>
      </Card>
      
      {submitError && (
        <Alert variant="destructive">
          <AlertDescription>
            {submitError instanceof Error ? submitError.message : 'Failed to submit exam'}
          </AlertDescription>
        </Alert>
      )}
    </div>
  );
}
</file>

<file path="src/features/exams/ui/ExamLanding.tsx">
"use client";

import React, { useState, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import { 
  Search, 
  Star,
  CheckCircle2,
  BookOpen,
  Clock,
  BarChart,
  Users
} from 'lucide-react';

import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { 
  Card, 
  CardContent, 
  CardDescription, 
  CardFooter, 
  CardHeader, 
  CardTitle 
} from '@/components/ui/card';
import { 
  Select, 
  SelectContent, 
  SelectItem, 
  SelectTrigger, 
  SelectValue 
} from '@/components/ui/select';
import { 
  Tabs, 
  TabsContent, 
  TabsList, 
  TabsTrigger 
} from '@/components/ui/tabs';

import { ExamPaperCard } from './ExamPaperCard';
import { 
  ExamPaperMetadata, 
  UserExamProgress 
} from '../model/types';

interface ExamLandingProps {
  modelPapers?: ExamPaperMetadata[];
  pastPapers?: ExamPaperMetadata[];
  userProgress?: UserExamProgress;
}

export const ExamLanding: React.FC<ExamLandingProps> = ({ 
  modelPapers = [], 
  pastPapers = [], 
  userProgress = {
    completedPapers: [],
    premium_access: false,
    papers_progress: []
  }
}) => {
  const router = useRouter();
  const [searchTerm, setSearchTerm] = useState('');
  const [difficulty, setDifficulty] = useState<string | null>(null);

  const filterPapers = (papers: ExamPaperMetadata[]) => {
    return papers.filter(paper => {
      if (!paper || !paper.title || !paper.topics_covered) return false;
      return (searchTerm === '' || 
        (paper.title?.toLowerCase().includes(searchTerm.toLowerCase()) || 
        paper.topics_covered?.some(topic => 
          topic?.toLowerCase().includes(searchTerm.toLowerCase())
        ))
      ) &&
      (difficulty === null || paper.difficulty === difficulty);
    });
  };

  const handleStartPaper = (paper: ExamPaperMetadata) => {
    if (paper.is_premium && !userProgress?.premium_access) {
      router.push('/pricing');
      return;
    }
    router.push(`/exam/${paper.id}`);
  };

  const difficultiesAvailable = useMemo(() => {
    const difficulties = new Set<string>();
    modelPapers?.forEach(p => p?.difficulty && difficulties.add(p.difficulty));
    pastPapers?.forEach(p => p?.difficulty && difficulties.add(p.difficulty));
    return Array.from(difficulties);
  }, [modelPapers, pastPapers]);

  const capitalize = (str?: string) => 
    str ? str.charAt(0).toUpperCase() + str.slice(1) : '';

  const renderPaperSection = (
    title: string, 
    description: string, 
    papers: ExamPaperMetadata[]
  ) => {
    const filteredPapers = filterPapers(papers);
    return (
      <div className="space-y-6">
        <div className="space-y-2">
          <h2 className="text-2xl font-semibold tracking-tight">{title}</h2>
          <p className="text-muted-foreground">{description}</p>
        </div>
        
        {/* Stats Overview */}
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
          {[
            { icon: BookOpen, label: 'Total Papers', value: papers.length },
            { icon: Clock, label: 'Avg. Duration', value: '180 mins' },
            { icon: BarChart, label: 'Completion Rate', value: '75%' },
            { icon: Users, label: 'Active Users', value: '2.5k' }
          ].map((stat, idx) => (
            <Card key={idx} className="bg-gradient-to-br from-white to-gray-50">
              <CardContent className="flex items-center p-4">
                <div className="mr-4 rounded-lg bg-primary/10 p-2">
                  <stat.icon className="h-5 w-5 text-primary" />
                </div>
                <div>
                  <p className="text-sm font-medium text-muted-foreground">
                    {stat.label}
                  </p>
                  <p className="text-xl font-bold">{stat.value}</p>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {filteredPapers.length > 0 ? (
            filteredPapers.map(paper => paper && (
              <ExamPaperCard 
                key={paper.id}
                paper={paper}
                progress={
                  userProgress?.papers_progress?.find(p => p.paperId === paper.id)
                }
                onStart={handleStartPaper}
              />
            ))
          ) : (
            <div className="col-span-full flex flex-col items-center justify-center py-12 text-center">
              <Search className="h-12 w-12 text-muted-foreground mb-4" />
              <p className="text-lg font-medium">No papers found</p>
              <p className="text-sm text-muted-foreground">
                Try adjusting your search or filter settings
              </p>
            </div>
          )}
        </div>
      </div>
    );
  };

  return (
    <div className="container py-8 space-y-8">
      {/* Header */}
      <div className="flex flex-col space-y-4 md:flex-row md:justify-between md:items-center md:space-y-0">
        <div className="space-y-1">
          <h1 className="text-3xl font-bold tracking-tight">Exam Practice</h1>
          <p className="text-muted-foreground">
            Prepare for your pharmacy exams with our comprehensive question bank
          </p>
        </div>
        <div className="flex flex-col sm:flex-row gap-4">
          <div className="relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground" />
            <Input 
              placeholder="Search papers by title or topics" 
              className="pl-10 w-[250px]"
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
            />
          </div>
          <Select 
            onValueChange={(value) => 
              setDifficulty(value === 'all' ? null : value)
            }
          >
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="Difficulty" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Difficulties</SelectItem>
              {difficultiesAvailable.map(diff => (
                <SelectItem key={diff} value={diff}>
                  {capitalize(diff)}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
      </div>

      {/* Tabs */}
      <Tabs defaultValue="model" className="space-y-8">
        <TabsList className="grid w-full grid-cols-2 max-w-[400px]">
          <TabsTrigger value="model">Model Papers</TabsTrigger>
          <TabsTrigger value="past">Past Papers</TabsTrigger>
        </TabsList>

        <TabsContent value="model" className="space-y-8">
          {renderPaperSection(
            'Model Papers', 
            'Practice with our curated model papers to prepare for your exam.', 
            modelPapers
          )}
        </TabsContent>

        <TabsContent value="past" className="space-y-8">
          {renderPaperSection(
            'Past Papers', 
            'Review actual exam papers from previous years.', 
            pastPapers
          )}
        </TabsContent>
      </Tabs>

      {!userProgress?.premium_access && (
        <Card className="bg-gradient-to-r from-purple-50 to-indigo-50 border-0 overflow-hidden relative">
          <div className="absolute inset-0 bg-grid-white/10" />
          <CardHeader>
            <CardTitle className="flex items-center space-x-2">
              <Star className="h-6 w-6 text-yellow-500" />
              <span>Unlock Premium Access</span>
            </CardTitle>
            <CardDescription className="text-base">
              Get access to all model papers and past papers with detailed explanations.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="grid sm:grid-cols-2 gap-6">
              <ul className="space-y-3">
                {[
                  "Unlimited access to all model papers",
                  "Complete past paper archive",
                  "Comprehensive answer explanations",
                  "Advanced progress tracking & analytics"
                ].map((benefit, index) => (
                  <li key={index} className="flex items-center">
                    <CheckCircle2 className="h-5 w-5 mr-2 text-green-600 flex-shrink-0" />
                    <span className="text-sm">{benefit}</span>
                  </li>
                ))}
              </ul>
              <div className="flex items-center justify-center sm:justify-end">
                <Button 
                  size="lg" 
                  className="bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 text-white shadow-lg"
                  onClick={() => router.push('/pricing')}
                >
                  Upgrade to Premium
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
};
</file>

<file path="src/features/exams/ui/ExamList.tsx">
'use client';

import { usePublishedExams } from '../hooks/useExamQueries';
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Skeleton } from '@/components/ui/skeleton';
import { Badge } from '@/components/ui/badge';
import { useRouter } from 'next/navigation';

export function ExamList() {
  const { data: exams, isLoading, error, refetch } = usePublishedExams();
  const router = useRouter();

  const handleStartExam = (examId: number) => {
    router.push(`/exams/${examId}`);
  };

  if (isLoading) {
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {[1, 2, 3].map((index) => (
          <Card key={index}>
            <CardHeader>
              <CardTitle><Skeleton className="h-6 w-3/4" /></CardTitle>
            </CardHeader>
            <CardContent>
              <Skeleton className="h-20 w-full mb-2" />
              <div className="flex gap-2 mt-2">
                <Skeleton className="h-5 w-16" />
                <Skeleton className="h-5 w-16" />
              </div>
            </CardContent>
            <CardFooter>
              <Skeleton className="h-10 w-full" />
            </CardFooter>
          </Card>
        ))}
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-red-100 p-4 rounded-md border border-red-300 text-red-800">
        <h3 className="font-bold">Error loading exams</h3>
        <p>{error instanceof Error ? error.message : 'An unknown error occurred'}</p>
        <Button 
          variant="outline" 
          className="mt-2"
          onClick={() => refetch()}
        >
          Try Again
        </Button>
      </div>
    );
  }

  if (!exams || exams.length === 0) {
    return (
      <Card className="w-full text-center p-6">
        <CardHeader>
          <CardTitle>No Exams Available</CardTitle>
        </CardHeader>
        <CardContent>
          <p>There are currently no published exams available.</p>
        </CardContent>
      </Card>
    );
  }

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {exams.map((exam) => (
        <Card key={exam.id} className="flex flex-col">
          <CardHeader>
            <CardTitle className="flex items-center justify-between">
              <span>{exam.title}</span>
              <Badge variant="outline">{exam.duration} min</Badge>
            </CardTitle>
          </CardHeader>
          <CardContent className="flex-grow">
            <p className="text-sm text-gray-600 mb-4">{exam.description}</p>
            <div className="flex flex-wrap gap-2 mt-4">
              <Badge variant="secondary">{exam.questions?.length || 'N/A'} Questions</Badge>
              <Badge variant="secondary">Score: {exam.passingScore}/{exam.maxScore}</Badge>
            </div>
          </CardContent>
          <CardFooter>
            <Button 
              className="w-full" 
              onClick={() => handleStartExam(exam.id)}
            >
              Start Exam
            </Button>
          </CardFooter>
        </Card>
      ))}
    </div>
  );
}
</file>

<file path="src/features/exams/ui/ExamPaperCard.tsx">
"use client";

import React from 'react';
import { 
  Clock, 
  FileText, 
  CheckCircle2, 
  Lock, 
  TrendingUp 
} from 'lucide-react';
import { 
  Card, 
  CardContent, 
  CardFooter, 
  CardHeader, 
  CardTitle 
} from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { 
  ExamPaperMetadata, 
  ExamPaperProgress, 
  ExamPaperCardProps 
} from '../model/types';

export const ExamPaperCard: React.FC<ExamPaperCardProps> = ({ 
  paper, 
  progress, 
  onStart 
}) => {
  const difficultyVariants = {
    'easy': 'bg-green-50 text-green-600',
    'medium': 'bg-yellow-50 text-yellow-600',
    'hard': 'bg-red-50 text-red-600'
  };

  const renderDifficultyBadge = () => (
    <Badge 
      className={`${difficultyVariants[paper.difficulty]} px-2 py-1`}
      variant="outline"
    >
      {paper.difficulty.charAt(0).toUpperCase() + paper.difficulty.slice(1)}
    </Badge>
  );

  const renderProgressBadge = () => {
    if (progress?.completed) {
      return (
        <Badge variant="secondary" className="flex items-center gap-1">
          <CheckCircle2 className="h-3 w-3" />
          Completed
        </Badge>
      );
    }
    return null;
  };

  const handleStart = () => {
    onStart(paper);
  };

  return (
    <Card className="hover:shadow-lg transition-all duration-300 transform hover:-translate-y-2">
      <CardHeader className="pb-2">
        <div className="flex justify-between items-start">
          <CardTitle className="text-xl">{paper.title}</CardTitle>
          {paper.is_premium && <Lock className="text-muted-foreground" />}
        </div>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="flex justify-between items-center">
          <div className="flex items-center space-x-4">
            <div className="flex items-center text-muted-foreground">
              <FileText className="h-4 w-4 mr-2" />
              <span>{paper.total_questions} Questions</span>
            </div>
            <div className="flex items-center text-muted-foreground">
              <Clock className="h-4 w-4 mr-2" />
              <span>{paper.time_limit} mins</span>
            </div>
          </div>
          {renderDifficultyBadge()}
        </div>
        
        <div className="flex flex-wrap gap-2">
          {paper.topics_covered.map(topic => (
            <Badge key={topic} variant="outline" className="text-xs">
              {topic}
            </Badge>
          ))}
        </div>

        {progress?.score && (
          <div className="flex items-center text-muted-foreground">
            <TrendingUp className="h-4 w-4 mr-2" />
            <span>Last Score: {progress.score}%</span>
          </div>
        )}
      </CardContent>
      <CardFooter className="flex justify-between items-center">
        <div className="flex items-center space-x-2">
          {renderProgressBadge()}
        </div>
        <Button 
          onClick={handleStart} 
          variant={paper.is_premium ? 'outline' : 'default'}
        >
          {paper.is_premium ? 'Upgrade' : 'Start Paper'}
        </Button>
      </CardFooter>
    </Card>
  );
};
</file>

<file path="src/features/exams/ui/index.ts">
export { default as ExamList } from './ExamList';
export type { ExamListProps } from './ExamList';
export * from './ExamLanding';
export * from './ExamPaperCard';
export * from './quiz';
export * from './mcq';
</file>

<file path="src/features/exams/ui/mcq/index.ts">
export * from './McqExamLayout';
export * from './McqQuestionCard';
export * from './McqQuestionNavigation';
export * from './McqExamResults';
export * from './McqExamList';
</file>

<file path="src/features/exams/ui/mcq/McqExamLayout.tsx">
'use client';

import React, { useEffect, useState } from 'react';
import { Button } from "@/components/ui/button";
import {
    AlertDialog,
    AlertDialogAction,
    AlertDialogCancel,
    AlertDialogContent,
    AlertDialogDescription,
    AlertDialogFooter,
    AlertDialogHeader,
    AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { useMcqExamStore } from '../../store/mcqExamStore';
import { ExamTimer } from '../quiz/ExamTimer';
import { McqQuestionNavigation } from './McqQuestionNavigation';
import { McqQuestionCard } from './McqQuestionCard';
import { useRouter } from 'next/navigation';
import { Loader2 } from 'lucide-react';

interface McqExamLayoutProps {
    examId: number;
}

export const McqExamLayout: React.FC<McqExamLayoutProps> = ({ examId }) => {
    const router = useRouter();
    const {
        currentExam,
        currentQuestionIndex,
        timeRemaining,
        userAnswers,
        flaggedQuestions,
        isPaused,
        isLoading,
        error,
        startExam,
        answerQuestion,
        flagQuestion,
        unflagQuestion,
        nextQuestion,
        previousQuestion,
        pauseExam,
        resumeExam,
        completeExam,
        updateTimeRemaining
    } = useMcqExamStore();

    const [showSubmitDialog, setShowSubmitDialog] = useState(false);
    const [showTimeUpDialog, setShowTimeUpDialog] = useState(false);
    const [submitError, setSubmitError] = useState<string | null>(null);

    // Start the exam when the component mounts
    useEffect(() => {
        const loadExam = async () => {
            try {
                await startExam(examId);
            } catch (err) {
                console.error('Failed to start exam:', err);
            }
        };
        
        loadExam();
        
        // Cleanup when unmounting
        return () => {
            // Reset exam state when leaving the page
            useMcqExamStore.getState().resetExam();
        };
    }, [examId, startExam]);

    // Timer effect
    useEffect(() => {
        let timer: NodeJS.Timeout;
        if (!isPaused && timeRemaining > 0) {
            timer = setInterval(() => {
                if (timeRemaining <= 1) {
                    handleTimeUp();
                } else {
                    updateTimeRemaining(timeRemaining - 1);
                }
            }, 1000);
        }
        return () => clearInterval(timer);
    }, [timeRemaining, isPaused, updateTimeRemaining]);

    const handleAnswer = (answer: string, timeSpent: number) => {
        if (!currentExam?.questions) return;

        const question = currentExam.questions[currentQuestionIndex];
        answerQuestion({
            questionId: question.id,
            selectedOptionId: answer,
            timeSpent: timeSpent
        });

        // Auto-advance to next question after a brief delay
        setTimeout(() => {
            if (currentQuestionIndex < (currentExam.questions?.length || 0) - 1) {
                nextQuestion();
            }
        }, 1000);
    };

    const handleFlag = async () => {
        if (!currentExam?.questions) return;
        
        const question = currentExam.questions[currentQuestionIndex];
        const questionId = question.id;
        
        try {
            // If already flagged, unflag it, otherwise flag it
            if (flaggedQuestions.has(questionId)) {
                await unflagQuestion(questionId);
            } else {
                await flagQuestion(questionId);
            }
        } catch (err) {
            console.error('Error toggling flag:', err);
        }
    };

    const handleTimeUp = () => {
        pauseExam();
        setShowTimeUpDialog(true);
    };

    const handleSubmit = async () => {
        try {
            if (!currentExam) return;

            const answeredCount = Object.keys(userAnswers).length;
            // Check if the user has answered enough questions based on exam requirements
            // This is just a placeholder. You should define your own criteria
            const minimumRequired = Math.ceil((currentExam.questions?.length || 0) * 0.5) || 1;
            
            if (answeredCount < minimumRequired) {
                setSubmitError(`Please attempt at least ${minimumRequired} questions`);
                return;
            }

            await completeExam();
            router.push('/exam-practice/results');
        } catch (err) {
            setSubmitError(err instanceof Error ? err.message : 'Failed to submit exam');
        }
    };

    if (isLoading) {
        return (
            <div className="flex items-center justify-center min-h-screen">
                <Loader2 className="w-8 h-8 animate-spin text-primary" />
                <span className="ml-2 text-lg">Loading exam...</span>
            </div>
        );
    }

    if (error) {
        return (
            <div className="flex flex-col items-center justify-center min-h-screen p-4">
                <div className="bg-red-50 text-red-600 p-6 rounded-lg max-w-lg text-center shadow-md">
                    <h2 className="text-xl font-bold mb-4">Error</h2>
                    <p className="mb-4">{error}</p>
                    <Button 
                        className="mt-4 bg-red-600 hover:bg-red-700 text-white" 
                        onClick={() => router.push('/exam-practice')}
                    >
                        Return to Exams
                    </Button>
                </div>
            </div>
        );
    }

    if (!currentExam || !currentExam.questions) {
        return <div>No exam data available</div>;
    }

    const currentQuestion = currentExam.questions[currentQuestionIndex];

    return (
        <div className="flex h-screen">
            <div className="flex-1 flex flex-col">
                {/* Header */}
                <div className="p-4 border-b">
                    <div className="flex justify-between items-center mb-4">
                        <h1 className="text-xl font-bold">{currentExam.title}</h1>
                        <Button 
                            variant="destructive"
                            onClick={() => setShowSubmitDialog(true)}
                        >
                            Submit Exam
                        </Button>
                    </div>
                    <ExamTimer
                        totalTime={currentExam.duration * 60}
                        remainingTime={timeRemaining}
                        isPaused={isPaused}
                        onPause={pauseExam}
                        onResume={resumeExam}
                        onTimeUp={handleTimeUp}
                    />
                </div>

                {/* Question Area */}
                <div className="flex-1 overflow-auto p-4">
                    <McqQuestionCard
                        question={currentQuestion}
                        currentAnswer={userAnswers[currentQuestion.id]}
                        onAnswer={handleAnswer}
                        onFlag={handleFlag}
                        isFlagged={flaggedQuestions.has(currentQuestion.id)}
                    />
                </div>

                {/* Navigation Controls */}
                <div className="p-4 border-t">
                    <div className="flex justify-between">
                        <Button
                            onClick={previousQuestion}
                            disabled={currentQuestionIndex === 0}
                        >
                            Previous
                        </Button>
                        <Button
                            onClick={nextQuestion}
                            disabled={currentQuestionIndex === currentExam.questions.length - 1}
                        >
                            Next
                        </Button>
                    </div>
                </div>
            </div>

            {/* Question Navigation Sidebar */}
            <McqQuestionNavigation
                totalQuestions={currentExam.questions.length}
                currentQuestion={currentQuestionIndex}
                answers={userAnswers}
                flaggedQuestions={flaggedQuestions}
                onQuestionSelect={(index) => useMcqExamStore.setState({ currentQuestionIndex: index })}
                minimumRequired={Math.ceil(currentExam.questions.length * 0.5)} // Placeholder, define your criteria
            />

            {/* Submit Confirmation Dialog */}
            <AlertDialog open={showSubmitDialog} onOpenChange={setShowSubmitDialog}>
                <AlertDialogContent>
                    <AlertDialogHeader>
                        <AlertDialogTitle>Submit Exam?</AlertDialogTitle>
                        <AlertDialogDescription>
                            You have answered {Object.keys(userAnswers).length} out of {currentExam.questions.length} questions.
                            {submitError && (
                                <span className="text-red-500 block mt-2">{submitError}</span>
                            )}
                        </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                        <AlertDialogAction onClick={handleSubmit}>
                            Submit
                        </AlertDialogAction>
                    </AlertDialogFooter>
                </AlertDialogContent>
            </AlertDialog>

            {/* Time Up Dialog */}
            <AlertDialog 
                open={showTimeUpDialog} 
                onOpenChange={setShowTimeUpDialog}
            >
                <AlertDialogContent>
                    <AlertDialogHeader>
                        <AlertDialogTitle>Time&apos;s Up!</AlertDialogTitle>
                        <AlertDialogDescription>
                            Your exam time has ended. Your answers will be submitted automatically.
                        </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                        <AlertDialogAction onClick={handleSubmit}>
                            View Results
                        </AlertDialogAction>
                    </AlertDialogFooter>
                </AlertDialogContent>
            </AlertDialog>
        </div>
    );
};
</file>

<file path="src/features/exams/ui/mcq/McqExamList.tsx">
'use client';

import React, { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { 
  Search, 
  Star,
  CheckCircle2,
  BookOpen,
  Clock,
  BarChart,
  Users,
  Loader2,
  RefreshCcw,
  AlertTriangle
} from 'lucide-react';

import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { 
  Card, 
  CardContent, 
  CardDescription, 
  CardFooter, 
  CardHeader, 
  CardTitle 
} from '@/components/ui/card';
import { 
  Select, 
  SelectContent, 
  SelectItem, 
  SelectTrigger, 
  SelectValue 
} from '@/components/ui/select';

import { examService } from '../../api/core/examService';
import { Exam } from '../../model/mcqTypes';
import { useAuth } from '@/shared/auth';

export const McqExamList: React.FC = () => {
  const router = useRouter();
  const { isAuthenticated, isLoading: authLoading, user } = useAuth();
  
  const [exams, setExams] = useState<Exam[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [debugInfo, setDebugInfo] = useState<any>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [difficultyFilter, setDifficultyFilter] = useState<string | null>(null);
  const [retryCount, setRetryCount] = useState(0);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);

  // Debug log for authentication state
  useEffect(() => {
    console.log('Auth state:', { isAuthenticated, authLoading, user });
    
    // Debug tokens in localStorage
    const authToken = localStorage.getItem('auth_token');
    const accessToken = localStorage.getItem('access_token');
    const tokenExpiry = localStorage.getItem('token_expiry');
    
    console.log('Tokens:', { 
      authToken: authToken ? `${authToken.substring(0, 10)}...` : null,
      accessToken: accessToken ? `${accessToken.substring(0, 10)}...` : null,
      tokenExpiry
    });
  }, [isAuthenticated, authLoading, user]);

  // Fetch exams effect with retry mechanism
  useEffect(() => {
    const fetchExams = async () => {
      if (authLoading) {
        console.log('Auth is still loading, waiting...');
        return;
      }
      
      try {
        console.log('Attempting to fetch exams...');
        setLoading(true);
        setError(null);
        setDebugInfo(null);
        setSuccessMessage(null);
        
        const publishedExams = await examService.getPublishedExams();
        console.log('Exams fetched successfully:', publishedExams.length);
        setExams(publishedExams);
        setLoading(false);
        
        // Show success message on retry success
        if (retryCount > 0) {
          setSuccessMessage('Exam data has been refreshed successfully');
          // Clear success message after 3 seconds
          setTimeout(() => setSuccessMessage(null), 3000);
        }
      } catch (err) {
        console.error('Failed to load exams:', err);
        
        const errorMsg = err instanceof Error ? err.message : 'Failed to load exams. Please try again later.';
        console.log('Setting error message:', errorMsg);
        setError(errorMsg);
        
        // Store debug info
        setDebugInfo({
          error: err,
          apiUrl: process.env.NEXT_PUBLIC_API_BASE_URL,
          endpoint: '/v1/exams/published',
          auth: isAuthenticated,
          timestamp: new Date().toISOString()
        });
        
        setLoading(false);
      }
    };

    fetchExams();
  }, [isAuthenticated, authLoading, retryCount]);

  const handleStartExam = (examId: number) => {
    router.push(`/exam/${examId}`);
  };
  
  const handleRetry = () => {
    console.log('Retrying exam fetch...');
    setRetryCount(prev => prev + 1);
  };
  
  const handleLogin = () => {
    console.log('Redirecting to login page...');
    // Save the current URL to redirect back after login
    if (typeof window !== 'undefined') {
      sessionStorage.setItem('redirectAfterLogin', '/exam');
    }
    router.push('/login');
  };

  // Filter exams based on search term and difficulty
  const filteredExams = exams.filter(exam => {
    const matchesSearch = 
      searchTerm === '' || 
      exam.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
      exam.description.toLowerCase().includes(searchTerm.toLowerCase());
    
    const matchesDifficulty = 
      difficultyFilter === null || 
      difficultyFilter === 'all';
    
    return matchesSearch && matchesDifficulty;
  });

  if (authLoading || loading) {
    return (
      <div className="flex flex-col items-center justify-center min-h-screen">
        <Loader2 className="w-8 h-8 animate-spin text-primary mb-4" />
        <span className="text-lg">{authLoading ? 'Checking authentication...' : 'Loading exams...'}</span>
        <p className="text-sm text-muted-foreground mt-2">
          This may take a moment. Please wait.
        </p>
      </div>
    );
  }

  if (error) {
    const isCorsError = error.toString().includes('CORS');
    const isAuthError = error.toString().includes('403') || 
                        error.toString().includes('401') || 
                        error.toString().includes('Forbidden') || 
                        error.toString().includes('Unauthorized');
    
    return (
      <div className="flex flex-col items-center justify-center min-h-screen p-4">
        <div className="bg-red-50 text-red-600 p-6 rounded-lg max-w-lg text-center shadow-md">
          <AlertTriangle className="h-12 w-12 mx-auto mb-4" />
          <h2 className="text-xl font-bold mb-2">Error</h2>
          <p className="mb-4">{error.toString()}</p>
          <div className="space-y-2">
            <Button className="w-full" onClick={handleRetry}>
              <RefreshCcw className="mr-2 h-4 w-4" />
              Try Again
            </Button>
            <p className="text-xs text-red-500 mt-2">
              Server Status: {navigator.onLine ? 'Your internet connection appears to be working.' : 'You appear to be offline.'}
            </p>
            <details className="mt-4 text-left">
              <summary className="cursor-pointer text-sm">Troubleshooting Steps</summary>
              <ul className="list-disc pl-5 mt-2 text-sm">
                <li>Make sure the backend server is running at {process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:8080/api'}</li>
                <li>Check that published exams exist in the database</li>
                <li>Check browser console for detailed network errors</li>
                {isCorsError && (
                  <li>If CORS errors persist, verify your SecurityConfig.java CORS settings allow <code>{window.location.origin}</code></li>
                )}
              </ul>
            </details>
            
            {debugInfo && (
              <details className="mt-4 text-left">
                <summary className="cursor-pointer text-sm">Debug Information</summary>
                <pre className="text-xs mt-2 p-2 bg-gray-100 rounded overflow-auto">
                  {JSON.stringify(debugInfo, null, 2)}
                </pre>
              </details>
            )}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="container py-8 space-y-8">
      {/* Success Message */}
      {successMessage && (
        <div className="bg-green-50 text-green-600 p-4 rounded-lg mb-4 flex items-center shadow-sm">
          <CheckCircle2 className="h-5 w-5 mr-2" />
          {successMessage}
        </div>
      )}
      
      {/* Header */}
      <div className="flex flex-col space-y-4 md:flex-row md:justify-between md:items-center md:space-y-0">
        <div className="space-y-1">
          <h1 className="text-3xl font-bold tracking-tight">Pharmacy Exams</h1>
          <p className="text-muted-foreground">
            Test your knowledge with our comprehensive pharmacy exams
          </p>
        </div>
        <div className="flex flex-col sm:flex-row gap-4">
          <div className="relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground" />
            <Input 
              placeholder="Search by title or description" 
              className="pl-10 w-[250px]"
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
            />
          </div>
          <Select 
            onValueChange={(value) => 
              setDifficultyFilter(value === 'all' ? null : value)
            }
          >
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="Difficulty" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Difficulties</SelectItem>
              <SelectItem value="easy">Easy</SelectItem>
              <SelectItem value="medium">Medium</SelectItem>
              <SelectItem value="hard">Hard</SelectItem>
            </SelectContent>
          </Select>
        </div>
      </div>

      {/* Stats Overview */}
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
        {[
          { icon: BookOpen, label: 'Total Exams', value: exams.length },
          { icon: Clock, label: 'Avg. Duration', value: `${Math.round(exams.reduce((acc, exam) => acc + exam.duration, 0) / exams.length || 0)} mins` },
          { icon: BarChart, label: 'Avg. Passing Score', value: `${Math.round(exams.reduce((acc, exam) => acc + exam.passingMarks, 0) / exams.length || 0)}%` },
          { icon: Users, label: 'Active Users', value: '1.2k' }
        ].map((stat, idx) => (
          <Card key={idx} className="bg-gradient-to-br from-white to-gray-50">
            <CardContent className="flex items-center p-4">
              <div className="mr-4 rounded-lg bg-primary/10 p-2">
                <stat.icon className="h-5 w-5 text-primary" />
              </div>
              <div>
                <p className="text-sm font-medium text-muted-foreground">
                  {stat.label}
                </p>
                <p className="text-xl font-bold">{stat.value}</p>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>

      {/* Exams List */}
      <div className="space-y-2">
        <h2 className="text-2xl font-semibold tracking-tight">Available Exams</h2>
        <p className="text-muted-foreground">Choose an exam to start practicing</p>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {filteredExams.length > 0 ? (
          filteredExams.map(exam => (
            <Card key={exam.id} className="overflow-hidden transition-all hover:shadow-md">
              <CardHeader className="pb-3">
                <CardTitle>{exam.title}</CardTitle>
                <CardDescription>{exam.description}</CardDescription>
              </CardHeader>
              <CardContent className="pb-3">
                <div className="space-y-3">
                  <div className="flex justify-between text-sm">
                    <div className="flex items-center">
                      <Clock className="h-4 w-4 mr-1 text-muted-foreground" />
                      <span>{exam.duration} mins</span>
                    </div>
                    <div className="flex items-center">
                      <BookOpen className="h-4 w-4 mr-1 text-muted-foreground" />
                      <span>{exam.questions?.length || 0} questions</span>
                    </div>
                  </div>
                  
                  <div className="space-y-1">
                    <div className="flex justify-between text-sm">
                      <span className="text-muted-foreground">Passing Score</span>
                      <span className="font-medium">{exam.passingMarks}%</span>
                    </div>
                    <div className="flex justify-between text-sm">
                      <span className="text-muted-foreground">Total Marks</span>
                      <span className="font-medium">{exam.totalMarks}</span>
                    </div>
                  </div>
                </div>
              </CardContent>
              <CardFooter>
                <Button 
                  className="w-full"
                  onClick={() => handleStartExam(exam.id)}
                >
                  Start Exam
                </Button>
              </CardFooter>
            </Card>
          ))
        ) : (
          <div className="col-span-full flex flex-col items-center justify-center py-12 text-center">
            <Search className="h-12 w-12 text-muted-foreground mb-4" />
            <p className="text-lg font-medium">No exams found</p>
            <p className="text-sm text-muted-foreground mb-4">
              Try adjusting your search or filter settings
            </p>
            <Button variant="outline" onClick={handleRetry}>
              <RefreshCcw className="mr-2 h-4 w-4" />
              Refresh Exams
            </Button>
          </div>
        )}
      </div>

      {/* Premium Banner */}
      <Card className="bg-gradient-to-r from-purple-50 to-indigo-50 border-0 overflow-hidden relative">
        <div className="absolute inset-0 bg-grid-white/10" />
        <CardHeader>
          <CardTitle className="flex items-center space-x-2">
            <Star className="h-6 w-6 text-yellow-500" />
            <span>Premium Practice Exams</span>
          </CardTitle>
          <CardDescription className="text-base">
            Get access to all premium exam content with detailed explanations.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="grid sm:grid-cols-2 gap-6">
            <ul className="space-y-3">
              {[
                "Unlimited access to all exam types",
                "Detailed answer explanations",
                "Performance analytics and progress tracking",
                "Custom study plans based on your results"
              ].map((benefit, index) => (
                <li key={index} className="flex items-center">
                  <CheckCircle2 className="h-5 w-5 mr-2 text-green-600 flex-shrink-0" />
                  <span className="text-sm">{benefit}</span>
                </li>
              ))}
            </ul>
            <div className="flex items-center justify-center sm:justify-end">
              <Button 
                size="lg" 
                className="bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 text-white shadow-lg"
                onClick={() => router.push('/pricing')}
              >
                Upgrade to Premium
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};
</file>

<file path="src/features/exams/ui/mcq/McqExamResults.tsx">
'use client';

import React, { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { Button } from "@/components/ui/button";
import {
    Card,
    CardContent,
    CardDescription,
    CardFooter,
    CardHeader,
    CardTitle,
} from "@/components/ui/card";
import {
    CheckCircle,
    XCircle,
    Trophy,
    Clock,
    BarChart,
    ArrowLeft,
    RefreshCw,
    BookOpen,
    Flag,
    BookmarkIcon,
    PencilIcon
} from 'lucide-react';
import { Progress } from "@/components/ui/progress";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useMcqExamStore } from '../../store/mcqExamStore';
import { Loader2 } from 'lucide-react';
import { examService } from '../../api/core/examService';
import { FlaggedQuestion } from '../../model/mcqTypes';

export const McqExamResults: React.FC = () => {
    const router = useRouter();
    const { examResult, currentExam, currentAttempt, flaggedQuestions, resetExam, isLoading, error } = useMcqExamStore();
    const [reviewMode, setReviewMode] = useState<'all' | 'incorrect' | 'flagged'>('all');
    const [loadingFlagged, setLoadingFlagged] = useState(false);
    const [serverFlaggedQuestions, setServerFlaggedQuestions] = useState<FlaggedQuestion[]>([]);

    // Load flagged questions from server if needed
    useEffect(() => {
        const loadFlaggedQuestions = async () => {
            if (!currentAttempt) return;
            
            try {
                setLoadingFlagged(true);
                const flagged = await examService.getFlaggedQuestions(currentAttempt.id);
                setServerFlaggedQuestions(flagged);
            } catch (err) {
                console.error('Error loading flagged questions:', err);
            } finally {
                setLoadingFlagged(false);
            }
        };
        
        loadFlaggedQuestions();
    }, [currentAttempt]);

    if (isLoading || loadingFlagged) {
        return (
            <div className="flex items-center justify-center min-h-screen">
                <Loader2 className="w-8 h-8 animate-spin text-primary" />
                <span className="ml-2 text-lg">Loading results...</span>
            </div>
        );
    }

    if (error) {
        return (
            <div className="flex flex-col items-center justify-center min-h-screen p-4">
                <div className="bg-red-50 text-red-600 p-4 rounded-lg max-w-lg text-center">
                    <h2 className="text-xl font-bold mb-2">Error</h2>
                    <p>{error}</p>
                    <Button className="mt-4" onClick={() => router.push('/exam-practice')}>
                        Return to Exams
                    </Button>
                </div>
            </div>
        );
    }

    if (!examResult || !currentExam) {
        return (
            <div className="container py-8">
                <Card className="max-w-2xl mx-auto">
                    <CardHeader>
                        <CardTitle>No Results Available</CardTitle>
                        <CardDescription>
                            You haven't completed an exam recently or the results have been reset.
                        </CardDescription>
                    </CardHeader>
                    <CardFooter>
                        <Button onClick={() => router.push('/exam-practice')}>
                            <ArrowLeft className="mr-2 h-4 w-4" />
                            Return to Exams
                        </Button>
                    </CardFooter>
                </Card>
            </div>
        );
    }

    const formatTime = (seconds: number) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}m ${secs}s`;
    };

    const handleTryAgain = () => {
        resetExam();
        router.push(`/exam/${currentExam.id}`);
    };

    // Filter questions based on the selected review mode
    const filteredQuestionResults = examResult.questionResults.filter(question => {
        if (reviewMode === 'incorrect') {
            return !question.isCorrect;
        }
        if (reviewMode === 'flagged') {
            // Check if this question was flagged
            const questionIds = serverFlaggedQuestions.map(fq => fq.questionId);
            return questionIds.includes(question.questionId);
        }
        return true; // 'all' mode shows everything
    });

    return (
        <div className="container py-8">
            <div className="max-w-4xl mx-auto">
                {/* Results Summary */}
                <Card className="mb-8">
                    <CardHeader className="pb-2">
                        <div className="flex items-center justify-between">
                            <div>
                                <CardTitle className="text-2xl">{currentExam.title} - Results</CardTitle>
                                <CardDescription>Completed on {new Date().toLocaleString()}</CardDescription>
                            </div>
                            <div className="flex items-center">
                                {examResult.isPassed ? (
                                    <div className="flex items-center bg-green-100 text-green-800 px-3 py-1 rounded-full">
                                        <Trophy className="h-5 w-5 mr-1" />
                                        <span className="font-medium">Passed</span>
                                    </div>
                                ) : (
                                    <div className="flex items-center bg-red-100 text-red-800 px-3 py-1 rounded-full">
                                        <XCircle className="h-5 w-5 mr-1" />
                                        <span className="font-medium">Failed</span>
                                    </div>
                                )}
                            </div>
                        </div>
                    </CardHeader>
                    <CardContent>
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
                            <Card className="bg-muted/10">
                                <CardContent className="flex items-center p-4">
                                    <div className="mr-4 rounded-lg bg-primary/10 p-2">
                                        <BarChart className="h-5 w-5 text-primary" />
                                    </div>
                                    <div>
                                        <p className="text-sm font-medium text-muted-foreground">Score</p>
                                        <p className="text-xl font-bold">{examResult.score.toFixed(1)}%</p>
                                    </div>
                                </CardContent>
                            </Card>
                            <Card className="bg-muted/10">
                                <CardContent className="flex items-center p-4">
                                    <div className="mr-4 rounded-lg bg-primary/10 p-2">
                                        <CheckCircle className="h-5 w-5 text-primary" />
                                    </div>
                                    <div>
                                        <p className="text-sm font-medium text-muted-foreground">Correct Answers</p>
                                        <p className="text-xl font-bold">
                                            {examResult.questionResults.filter(q => q.isCorrect).length} / {examResult.questionResults.length}
                                        </p>
                                    </div>
                                </CardContent>
                            </Card>
                            <Card className="bg-muted/10">
                                <CardContent className="flex items-center p-4">
                                    <div className="mr-4 rounded-lg bg-primary/10 p-2">
                                        <Clock className="h-5 w-5 text-primary" />
                                    </div>
                                    <div>
                                        <p className="text-sm font-medium text-muted-foreground">Time Spent</p>
                                        <p className="text-xl font-bold">{formatTime(examResult.timeSpent)}</p>
                                    </div>
                                </CardContent>
                            </Card>
                            <Card className="bg-muted/10">
                                <CardContent className="flex items-center p-4">
                                    <div className="mr-4 rounded-lg bg-primary/10 p-2">
                                        <BookOpen className="h-5 w-5 text-primary" />
                                    </div>
                                    <div>
                                        <p className="text-sm font-medium text-muted-foreground">Passing Score</p>
                                        <p className="text-xl font-bold">{examResult.passingMarks.toFixed(1)}%</p>
                                    </div>
                                </CardContent>
                            </Card>
                        </div>

                        <div className="space-y-4">
                            <div>
                                <div className="flex justify-between mb-1">
                                    <span className="text-sm font-medium">Score</span>
                                    <span className="text-sm font-medium">{examResult.score.toFixed(1)}%</span>
                                </div>
                                <Progress 
                                    value={examResult.score} 
                                    className={`h-3 ${examResult.isPassed ? 'bg-green-600' : 'bg-red-600'}`} 
                                />
                                <div className="mt-1">
                                    <span className="text-xs text-muted-foreground">
                                        Passing score: {examResult.passingMarks}%
                                    </span>
                                </div>
                            </div>
                        </div>
                    </CardContent>
                    <CardFooter className="flex justify-between">
                        <Button variant="outline" onClick={() => router.push('/exam-practice')}>
                            <ArrowLeft className="mr-2 h-4 w-4" />
                            Back to All Exams
                        </Button>
                        <Button onClick={handleTryAgain}>
                            <RefreshCw className="mr-2 h-4 w-4" />
                            Try Again
                        </Button>
                    </CardFooter>
                </Card>

                {/* Detailed Question Review */}
                <div className="space-y-6">
                    <div className="flex justify-between items-center">
                        <h2 className="text-2xl font-bold tracking-tight">Detailed Review</h2>
                        <Tabs defaultValue="all" className="w-full max-w-md" onValueChange={(value) => setReviewMode(value as any)}>
                            <TabsList className="grid w-full grid-cols-3">
                                <TabsTrigger value="all" className="flex items-center justify-center gap-1">
                                    <PencilIcon className="h-4 w-4" />
                                    <span>All Questions</span>
                                </TabsTrigger>
                                <TabsTrigger value="incorrect" className="flex items-center justify-center gap-1">
                                    <XCircle className="h-4 w-4" />
                                    <span>Incorrect</span>
                                </TabsTrigger>
                                <TabsTrigger value="flagged" className="flex items-center justify-center gap-1">
                                    <Flag className="h-4 w-4" />
                                    <span>Flagged</span>
                                </TabsTrigger>
                            </TabsList>
                        </Tabs>
                    </div>
                    
                    {filteredQuestionResults.length === 0 ? (
                        <Card>
                            <CardContent className="py-6 flex flex-col items-center justify-center">
                                <div className="p-3 rounded-full bg-muted mb-3">
                                    {reviewMode === 'incorrect' ? (
                                        <CheckCircle className="h-6 w-6 text-green-500" />
                                    ) : (
                                        <BookmarkIcon className="h-6 w-6 text-blue-500" />
                                    )}
                                </div>
                                <h3 className="text-lg font-medium mb-1">
                                    {reviewMode === 'incorrect' 
                                        ? 'All questions answered correctly!' 
                                        : reviewMode === 'flagged' 
                                            ? 'No questions were flagged for review' 
                                            : 'No questions found'}
                                </h3>
                                <p className="text-muted-foreground text-center max-w-md">
                                    {reviewMode === 'incorrect' 
                                        ? 'Great job! You didn&apos;t miss any questions on this exam.' 
                                        : reviewMode === 'flagged' 
                                            ? 'You can flag questions during the exam for later review' 
                                            : 'Try selecting a different filter option'}
                                </p>
                            </CardContent>
                        </Card>
                    ) : (
                        filteredQuestionResults.map((questionResult, index) => (
                            <Card 
                                key={questionResult.questionId} 
                                className={`border-l-4 ${
                                    serverFlaggedQuestions.some(fq => fq.questionId === questionResult.questionId)
                                        ? 'border-l-amber-500'
                                        : questionResult.isCorrect
                                            ? 'border-l-green-500'
                                            : 'border-l-red-500'
                                }`}
                            >
                                <CardHeader className="pb-2">
                                    <div className="flex justify-between items-start">
                                        <div className="flex items-center gap-2">
                                            <CardTitle className="text-lg">Question {index + 1}</CardTitle>
                                            {serverFlaggedQuestions.some(fq => fq.questionId === questionResult.questionId) && (
                                                <span className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-amber-100 text-amber-800">
                                                    <Flag className="h-3 w-3 mr-1" />
                                                    Flagged
                                                </span>
                                            )}
                                        </div>
                                        {questionResult.isCorrect ? (
                                            <div className="flex items-center text-green-600">
                                                <CheckCircle className="h-5 w-5 mr-1" />
                                                <span>Correct</span>
                                            </div>
                                        ) : (
                                            <div className="flex items-center text-red-600">
                                                <XCircle className="h-5 w-5 mr-1" />
                                                <span>Incorrect</span>
                                            </div>
                                        )}
                                    </div>
                                    <p className="text-base font-medium mt-1">{questionResult.questionText}</p>
                                </CardHeader>
                                <CardContent className="pb-2">
                                    <div className="space-y-2">
                                        {questionResult.userAnswerId && (
                                            <div className="border p-3 rounded-md">
                                                <p className="text-sm font-medium text-muted-foreground mb-1">Your Answer:</p>
                                                <p className={`${questionResult.isCorrect ? 'text-green-600' : 'text-red-600'} font-medium`}>
                                                    {currentExam.questions?.find(q => q.id === questionResult.questionId)?.options.find(o => o.id === questionResult.userAnswerId)?.text || 'Unknown option'}
                                                </p>
                                            </div>
                                        )}
                                        
                                        {!questionResult.isCorrect && (
                                            <div className="border p-3 rounded-md border-green-200 bg-green-50">
                                                <p className="text-sm font-medium text-muted-foreground mb-1">Correct Answer:</p>
                                                <p className="text-green-600 font-medium">
                                                    {currentExam.questions?.find(q => q.id === questionResult.questionId)?.options.find(o => o.id === questionResult.correctAnswerId)?.text || 'Unknown option'}
                                                </p>
                                            </div>
                                        )}
                                        
                                        <div className="border p-3 rounded-md mt-2">
                                            <p className="text-sm font-medium text-muted-foreground mb-1">Explanation:</p>
                                            <p className="text-sm">{questionResult.explanation}</p>
                                        </div>
                                    </div>
                                </CardContent>
                                <CardFooter>
                                    <div className="text-sm text-muted-foreground">
                                        Points: {questionResult.earnedPoints} / {questionResult.points}
                                    </div>
                                </CardFooter>
                            </Card>
                        ))
                    )}
                </div>
            </div>
        </div>
    );
};
</file>

<file path="src/features/exams/ui/mcq/McqQuestionCard.tsx">
import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardFooter, CardHeader } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Timer, Flag, CheckCircle, HelpCircle } from 'lucide-react';
import { ExamQuestion, UserAnswer } from '../../model/mcqTypes';

interface McqQuestionCardProps {
    question: ExamQuestion;
    currentAnswer?: UserAnswer;
    onAnswer: (optionId: string, timeSpent: number) => void;
    onFlag?: () => void;
    isFlagged?: boolean;
    showAnswer?: boolean;
}

export const McqQuestionCard: React.FC<McqQuestionCardProps> = ({
    question,
    currentAnswer,
    onAnswer,
    onFlag,
    isFlagged = false,
    showAnswer = false,
}) => {
    const [timeSpent, setTimeSpent] = useState(0);
    const [startTime] = useState(Date.now());

    // Track time spent on this question
    useEffect(() => {
        const timer = setInterval(() => {
            setTimeSpent(Math.floor((Date.now() - startTime) / 1000));
        }, 1000);
        
        return () => clearInterval(timer);
    }, [startTime]);

    const handleOptionSelect = (optionId: string) => {
        onAnswer(optionId, timeSpent);
    };

    const getOptionClassName = (option: { id: string; isCorrect: boolean; }) => {
        let className = "w-full justify-start p-4 mb-2";
        
        if (!showAnswer && !currentAnswer) {
            return className;
        }

        if (showAnswer) {
            if (option.isCorrect) {
                className += " bg-green-50 border-green-500 text-green-700";
            } else if (currentAnswer?.selectedOptionId === option.id) {
                className += " bg-red-50 border-red-500 text-red-700";
            }
        } else if (currentAnswer?.selectedOptionId === option.id) {
            className += " bg-blue-50 border-blue-500";
        }
        
        return className;
    };

    return (
        <Card className="w-full max-w-4xl">
            <CardHeader className="space-y-2">
                <div className="flex justify-between items-start">
                    <div className="space-y-1">
                        <div className="flex items-center space-x-2">
                            <span className="text-lg font-bold">
                                Question {question.id}
                            </span>
                            <Badge variant={isFlagged ? "destructive" : "outline"} className="font-normal cursor-pointer" onClick={onFlag}>
                                {isFlagged ? "Flagged" : "Flag for review"}
                            </Badge>
                        </div>
                    </div>
                    <div className="flex items-center space-x-4">
                        <div className="flex items-center text-muted-foreground">
                            <Timer className="h-4 w-4 mr-1" />
                            <span>{timeSpent}s</span>
                        </div>
                        {onFlag && (
                            <Button
                                variant={isFlagged ? "destructive" : "ghost"}
                                size="icon"
                                onClick={onFlag}
                                className="h-8 w-8"
                            >
                                <Flag className="h-4 w-4" />
                            </Button>
                        )}
                    </div>
                </div>
                <p className="text-lg">{question.text}</p>
            </CardHeader>

            <CardContent className="space-y-4">
                {question.options.map((option) => (
                    <Button
                        key={option.id}
                        variant="outline"
                        className={getOptionClassName(option)}
                        onClick={() => handleOptionSelect(option.id)}
                        disabled={showAnswer || !!currentAnswer}
                    >
                        <span className="font-bold mr-2">{option.id}.</span>
                        {option.text}
                        {showAnswer && option.isCorrect && (
                            <CheckCircle className="ml-2 h-4 w-4 text-green-500" />
                        )}
                    </Button>
                ))}
            </CardContent>

            {showAnswer && (
                <CardFooter className="flex-col items-start pt-4 border-t">
                    <div className="flex items-start space-x-2">
                        <HelpCircle className="h-5 w-5 text-blue-500 mt-0.5" />
                        <div className="flex-1">
                            <h4 className="font-semibold mb-1">Explanation</h4>
                            <p className="text-muted-foreground">
                                {question.explanation}
                            </p>
                        </div>
                    </div>
                </CardFooter>
            )}
        </Card>
    );
};
</file>

<file path="src/features/exams/ui/mcq/McqQuestionNavigation.tsx">
import React from 'react';
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { Flag, CheckCircle, Circle, AlertCircle } from 'lucide-react';
import { UserAnswer } from '../../model/mcqTypes';

interface McqQuestionNavigationProps {
    totalQuestions: number;
    currentQuestion: number;
    answers: { [questionId: number]: UserAnswer };
    flaggedQuestions: Set<number>;
    onQuestionSelect: (index: number) => void;
    minimumRequired: number;
}

export const McqQuestionNavigation: React.FC<McqQuestionNavigationProps> = ({
    totalQuestions,
    currentQuestion,
    answers,
    flaggedQuestions,
    onQuestionSelect,
    minimumRequired
}) => {
    // Create an array of question indexes
    const questionIndexes = Array.from({ length: totalQuestions }, (_, i) => i);
    
    // Count answered questions
    const answeredCount = Object.keys(answers).length;
    const progressPercentage = (answeredCount / totalQuestions) * 100;
    
    return (
        <div className="w-64 border-l bg-muted/10 p-4 flex flex-col">
            <div className="mb-6">
                <h2 className="text-lg font-semibold mb-2">Progress</h2>
                <Progress value={progressPercentage} className="h-2 mb-2" />
                <div className="text-sm text-muted-foreground">
                    {answeredCount} of {totalQuestions} answered
                    {minimumRequired > 0 && (
                        <div className={answeredCount >= minimumRequired ? "text-green-600" : "text-amber-600"}>
                            Minimum required: {minimumRequired}
                        </div>
                    )}
                </div>
            </div>
            
            <div className="mb-4">
                <h2 className="text-lg font-semibold mb-2">Questions</h2>
                <div className="grid grid-cols-4 gap-2">
                    {questionIndexes.map((index) => {
                        const questionId = index + 1; // Adjust if your question IDs start from a different number
                        const isAnswered = !!answers[questionId];
                        const isFlagged = flaggedQuestions.has(index);
                        const isCurrent = currentQuestion === index;
                        
                        let className = "flex items-center justify-center w-full h-10 text-sm";
                        let variant: "default" | "outline" | "secondary" | "ghost" = "outline";
                        
                        if (isCurrent) {
                            variant = "default";
                        } else if (isAnswered) {
                            variant = "secondary";
                        }
                        
                        return (
                            <Button
                                key={index}
                                variant={variant}
                                className={className}
                                onClick={() => onQuestionSelect(index)}
                            >
                                {isAnswered ? (
                                    <CheckCircle className="h-4 w-4" />
                                ) : isFlagged ? (
                                    <div className="flex flex-col items-center">
                                        <Flag className="h-3 w-3 text-destructive" />
                                        <span className="text-[10px]">{index + 1}</span>
                                    </div>
                                ) : (
                                    <span>{index + 1}</span>
                                )}
                            </Button>
                        );
                    })}
                </div>
            </div>
            
            <div className="mt-auto">
                <div className="bg-muted/20 p-3 rounded-lg">
                    <h3 className="font-medium mb-2">Legend</h3>
                    <div className="space-y-2 text-sm">
                        <div className="flex items-center">
                            <Circle className="h-4 w-4 mr-2" />
                            <span>Not Answered</span>
                        </div>
                        <div className="flex items-center">
                            <CheckCircle className="h-4 w-4 mr-2 text-primary" />
                            <span>Answered</span>
                        </div>
                        <div className="flex items-center">
                            <Flag className="h-4 w-4 mr-2 text-destructive" />
                            <span>Flagged for Review</span>
                        </div>
                        <div className="flex items-center">
                            <AlertCircle className="h-4 w-4 mr-2 text-blue-500" />
                            <span>Current Question</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
};
</file>

<file path="src/features/exams/ui/quiz/ExamLayout.tsx">
'use client';

import React, { useEffect, useState } from 'react';
import { Button } from "@/components/ui/button";
import {
    AlertDialog,
    AlertDialogAction,
    AlertDialogCancel,
    AlertDialogContent,
    AlertDialogDescription,
    AlertDialogFooter,
    AlertDialogHeader,
    AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { useExamStore } from '../../store/examStore';
import { ExamTimer } from './ExamTimer';
import { QuestionNavigation } from './QuestionNavigation';
import { QuestionCard } from './QuestionCard';
import { useRouter } from 'next/navigation';

export const ExamLayout = () => {
    const router = useRouter();
    const {
        currentPaper,
        currentQuestionIndex,
        timeRemaining,
        answers,
        isPaused,
        answerQuestion,
        nextQuestion,
        previousQuestion,
        pauseExam,
        resumeExam,
        completeExam,
    } = useExamStore();

    const [flaggedQuestions, setFlaggedQuestions] = useState<Set<number>>(new Set());
    const [showSubmitDialog, setShowSubmitDialog] = useState(false);
    const [showTimeUpDialog, setShowTimeUpDialog] = useState(false);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        let timer: NodeJS.Timeout;
        if (!isPaused && timeRemaining > 0) {
            timer = setInterval(() => {
                if (timeRemaining <= 1) {
                    handleTimeUp();
                } else {
                    useExamStore.setState({ timeRemaining: timeRemaining - 1 });
                }
            }, 1000);
        }
        return () => clearInterval(timer);
    }, [timeRemaining, isPaused]);

    const handleAnswer = (answer: string) => {
        if (!currentPaper) return;

        const question = currentPaper.content.sections[0].questions[currentQuestionIndex];
        answerQuestion({
            question_id: question.id,
            selected_option: answer,
            time_spent: 0,
        });

        // Auto-advance to next question after a brief delay
        setTimeout(() => {
            if (currentQuestionIndex < currentPaper.content.total_questions - 1) {
                nextQuestion();
            }
        }, 1000);
    };

    const handleFlag = () => {
        setFlaggedQuestions(prev => {
            const newFlags = new Set(prev);
            if (newFlags.has(currentQuestionIndex)) {
                newFlags.delete(currentQuestionIndex);
            } else {
                newFlags.add(currentQuestionIndex);
            }
            return newFlags;
        });
    };

    const handleTimeUp = () => {
        pauseExam();
        setShowTimeUpDialog(true);
    };

    const handleSubmit = () => {
        try {
            if (!currentPaper) return;

            const answeredCount = Object.keys(answers).length;
            if (answeredCount < currentPaper.content.passing_criteria.minimum_questions) {
                setError(`Please attempt at least ${currentPaper.content.passing_criteria.minimum_questions} questions`);
                return;
            }

            completeExam();
            router.push('/exam/results');
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to submit exam');
        }
    };

    if (!currentPaper) {
        return <div>No exam in progress</div>;
    }

    const currentQuestion = currentPaper.content.sections[0].questions[currentQuestionIndex];

    return (
        <div className="flex h-screen">
            <div className="flex-1 flex flex-col">
                {/* Header */}
                <div className="p-4 border-b">
                    <div className="flex justify-between items-center mb-4">
                        <h1 className="text-xl font-bold">{currentPaper.content.title}</h1>
                        <Button 
                            variant="destructive"
                            onClick={() => setShowSubmitDialog(true)}
                        >
                            Submit Exam
                        </Button>
                    </div>
                    <ExamTimer
                        totalTime={currentPaper.content.time_limit * 60}
                        remainingTime={timeRemaining}
                        isPaused={isPaused}
                        onPause={pauseExam}
                        onResume={resumeExam}
                        onTimeUp={handleTimeUp}
                    />
                </div>

                {/* Question Area */}
                <div className="flex-1 overflow-auto p-4">
                    <QuestionCard
                        question={currentQuestion}
                        currentAnswer={answers[currentQuestion.id]}
                        timeSpent={0}
                        onAnswer={handleAnswer}
                        onFlag={handleFlag}
                    />
                </div>

                {/* Navigation Controls */}
                <div className="p-4 border-t">
                    <div className="flex justify-between">
                        <Button
                            onClick={previousQuestion}
                            disabled={currentQuestionIndex === 0}
                        >
                            Previous
                        </Button>
                        <Button
                            onClick={nextQuestion}
                            disabled={currentQuestionIndex === currentPaper.content.total_questions - 1}
                        >
                            Next
                        </Button>
                    </div>
                </div>
            </div>

            {/* Question Navigation Sidebar */}
            <QuestionNavigation
                totalQuestions={currentPaper.content.total_questions}
                currentQuestion={currentQuestionIndex}
                answers={answers}
                flaggedQuestions={flaggedQuestions}
                onQuestionSelect={(index) => useExamStore.setState({ currentQuestionIndex: index })}
                minimumRequired={currentPaper.content.passing_criteria.minimum_questions}
            />

            {/* Submit Confirmation Dialog */}
            <AlertDialog open={showSubmitDialog} onOpenChange={setShowSubmitDialog}>
                <AlertDialogContent>
                    <AlertDialogHeader>
                        <AlertDialogTitle>Submit Exam?</AlertDialogTitle>
                        <AlertDialogDescription>
                            You have answered {Object.keys(answers).length} out of {currentPaper.content.total_questions} questions.
                            {error && (
                                <span className="text-red-500 block mt-2">{error}</span>
                            )}
                        </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                        <AlertDialogAction onClick={handleSubmit}>
                            Submit
                        </AlertDialogAction>
                    </AlertDialogFooter>
                </AlertDialogContent>
            </AlertDialog>

            {/* Time Up Dialog */}
            <AlertDialog 
                open={showTimeUpDialog} 
                onOpenChange={setShowTimeUpDialog}
            >
                <AlertDialogContent>
                    <AlertDialogHeader>
                        <AlertDialogTitle>Time&apos;s Up!</AlertDialogTitle>
                        <AlertDialogDescription>
                            Your exam time has ended. Your answers will be submitted automatically.
                        </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                        <AlertDialogAction onClick={handleSubmit}>
                            View Results
                        </AlertDialogAction>
                    </AlertDialogFooter>
                </AlertDialogContent>
            </AlertDialog>
        </div>
    );
};
</file>

<file path="src/features/exams/ui/quiz/ExamSettings.tsx">
import React from 'react';
import {
    Dialog,
    DialogContent,
    DialogDescription,
    DialogHeader,
    DialogTitle,
    DialogTrigger,
} from "@/components/ui/dialog";
import {
    Select,
    SelectContent,
    SelectItem,
    SelectTrigger,
    SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { Settings2 } from 'lucide-react';

interface ExamSettingsProps {
    showExplanations: boolean;
    autoAdvance: boolean;
    highlightSelected: boolean;
    onSettingChange: (setting: string, value: boolean) => void;
    theme: 'light' | 'dark';
    onThemeChange: (theme: 'light' | 'dark') => void;
}

export const ExamSettings = ({
    showExplanations,
    autoAdvance,
    highlightSelected,
    onSettingChange,
    theme,
    onThemeChange,
}: ExamSettingsProps) => {
    return (
        <Dialog>
            <DialogTrigger asChild>
                <Button variant="ghost" size="icon">
                    <Settings2 className="h-5 w-5" />
                </Button>
            </DialogTrigger>
            <DialogContent>
                <DialogHeader>
                    <DialogTitle>Exam Settings</DialogTitle>
                    <DialogDescription>
                        Customize your exam experience
                    </DialogDescription>
                </DialogHeader>

                <div className="space-y-6">
                    {/* Display Settings */}
                    <div className="space-y-4">
                        <h4 className="font-medium">Display</h4>
                        <div className="flex items-center justify-between">
                            <Label htmlFor="theme">Theme</Label>
                            <Select
                                value={theme}
                                onValueChange={value => 
                                    onThemeChange(value as 'light' | 'dark')
                                }
                            >
                                <SelectTrigger className="w-32">
                                    <SelectValue />
                                </SelectTrigger>
                                <SelectContent>
                                    <SelectItem value="light">Light</SelectItem>
                                    <SelectItem value="dark">Dark</SelectItem>
                                </SelectContent>
                            </Select>
                        </div>
                        <div className="flex items-center justify-between">
                            <Label htmlFor="highlight">
                                Highlight selected options
                            </Label>
                            <Switch
                                id="highlight"
                                checked={highlightSelected}
                                onCheckedChange={checked => 
                                    onSettingChange('highlightSelected', checked)
                                }
                            />
                        </div>
                    </div>

                    {/* Behavior Settings */}
                    <div className="space-y-4">
                        <h4 className="font-medium">Behavior</h4>
                        <div className="flex items-center justify-between">
                            <Label htmlFor="explanations">
                                Show explanations after answering
                            </Label>
                            <Switch
                                id="explanations"
                                checked={showExplanations}
                                onCheckedChange={checked => 
                                    onSettingChange('showExplanations', checked)
                                }
                            />
                        </div>
                        <div className="flex items-center justify-between">
                            <Label htmlFor="advance">
                                Auto-advance to next question
                            </Label>
                            <Switch
                                id="advance"
                                checked={autoAdvance}
                                onCheckedChange={checked => 
                                    onSettingChange('autoAdvance', checked)
                                }
                            />
                        </div>
                    </div>

                    {/* Accessibility Note */}
                    <div className="text-sm text-muted-foreground">
                        These settings will be saved for your next exam sessions.
                    </div>
                </div>
            </DialogContent>
        </Dialog>
    );
};
</file>

<file path="src/features/exams/ui/quiz/ExamTimer.tsx">
import React, { useEffect, useState } from 'react';
import { Progress } from "@/components/ui/progress";
import { Timer, Pause, Play } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription } from '@/components/ui/alert';

interface ExamTimerProps {
    totalTime: number; // in seconds
    remainingTime: number;
    isPaused: boolean;
    onPause?: () => void;
    onResume?: () => void;
    onTimeUp: () => void;
}

export const ExamTimer = ({
    totalTime,
    remainingTime,
    isPaused,
    onPause,
    onResume,
    onTimeUp,
}: ExamTimerProps) => {
    const [showWarning, setShowWarning] = useState(false);
    const progress = (remainingTime / totalTime) * 100;

    useEffect(() => {
        if (remainingTime <= 300 && !showWarning) { // 5 minutes warning
            setShowWarning(true);
        }
    }, [remainingTime, showWarning]);

    const formatTime = (seconds: number) => {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;

        return `${hours > 0 ? `${hours}:` : ''}${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    };

    const getTimerColor = () => {
        if (remainingTime <= 300) return 'text-red-500'; // 5 minutes
        if (remainingTime <= 600) return 'text-yellow-500'; // 10 minutes
        return 'text-green-500';
    };

    return (
        <div className="w-full space-y-2">
            <div className="flex items-center justify-between">
                <div className="flex items-center space-x-2">
                    <Timer className={`h-5 w-5 ${getTimerColor()}`} />
                    <span className={`font-mono text-lg ${getTimerColor()}`}>
                        {formatTime(remainingTime)}
                    </span>
                </div>
                {(onPause || onResume) && (
                    <Button
                        variant="ghost"
                        size="sm"
                        onClick={isPaused ? onResume : onPause}
                    >
                        {isPaused ? (
                            <Play className="h-4 w-4" />
                        ) : (
                            <Pause className="h-4 w-4" />
                        )}
                    </Button>
                )}
            </div>

            <Progress value={progress} className="h-2" />

            {showWarning && remainingTime <= 300 && (
                <Alert variant="destructive" className="mt-2">
                    <AlertDescription>
                        Less than {Math.ceil(remainingTime / 60)} minutes remaining!
                    </AlertDescription>
                </Alert>
            )}
        </div>
    );
};
</file>

<file path="src/features/exams/ui/quiz/QuestionCard.tsx">
import React from 'react';
import { Card, CardContent, CardFooter, CardHeader } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Timer, Flag, CheckCircle, HelpCircle } from 'lucide-react';
import { MCQuestion, UserAnswer } from '../../model/types';

interface QuestionCardProps {
    question: MCQuestion;
    currentAnswer?: UserAnswer;
    timeSpent: number;
    onAnswer: (answer: string) => void;
    onFlag?: () => void;
    showAnswer?: boolean;
}

export const QuestionCard = ({
    question,
    currentAnswer,
    timeSpent,
    onAnswer,
    onFlag,
    showAnswer = false,
}: QuestionCardProps) => {
    const getOptionStyle = (key: string) => {
        if (!showAnswer && !currentAnswer) {
            return '';
        }

        if (showAnswer) {
            if (key === question.answer) {
                return 'bg-green-50 border-green-500 text-green-700';
            }
            if (currentAnswer?.selectedOption === key && key !== question.answer) {
                return 'bg-red-50 border-red-500 text-red-700';
            }
        }

        if (currentAnswer?.selectedOption === key) {
            return 'bg-blue-50 border-blue-500';
        }

        return '';
    };

    return (
        <Card className="w-full max-w-4xl">
            <CardHeader className="space-y-2">
                <div className="flex justify-between items-start">
                    <div className="space-y-1">
                        <div className="flex items-center space-x-2">
                            <span className="text-lg font-bold">
                                Question {question.questionNumber}
                            </span>
                            <Badge variant="outline" className="font-normal">
                                {question.metadata.topic}
                            </Badge>
                            <Badge
                                variant="outline"
                                className={
                                    question.metadata.difficulty === 'easy'
                                        ? 'bg-green-50'
                                        : question.metadata.difficulty === 'medium'
                                        ? 'bg-yellow-50'
                                        : 'bg-red-50'
                                }
                            >
                                {question.metadata.difficulty}
                            </Badge>
                        </div>
                    </div>
                    <div className="flex items-center space-x-4">
                        <div className="flex items-center text-muted-foreground">
                            <Timer className="h-4 w-4 mr-1" />
                            <span>{timeSpent}s</span>
                        </div>
                        {onFlag && (
                            <Button
                                variant="ghost"
                                size="icon"
                                onClick={onFlag}
                                className="h-8 w-8"
                            >
                                <Flag className="h-4 w-4" />
                            </Button>
                        )}
                    </div>
                </div>
                <p className="text-lg">{question.question}</p>
            </CardHeader>

            <CardContent className="space-y-4">
                {Object.entries(question.options).map(([key, value]) => (
                    <Button
                        key={key}
                        variant="outline"
                        className={`w-full justify-start p-4 ${getOptionStyle(key)}`}
                        onClick={() => onAnswer(key)}
                        disabled={showAnswer || !!currentAnswer}
                    >
                        <span className="font-bold mr-2">{key}.</span>
                        {value}
                        {showAnswer && key === question.answer && (
                            <CheckCircle className="ml-2 h-4 w-4 text-green-500" />
                        )}
                    </Button>
                ))}
            </CardContent>

            {showAnswer && (
                <CardFooter className="flex-col items-start pt-4 border-t">
                    <div className="flex items-start space-x-2">
                        <HelpCircle className="h-5 w-5 text-blue-500 mt-0.5" />
                        <div className="flex-1">
                            <h4 className="font-semibold mb-1">Explanation</h4>
                            <p className="text-muted-foreground">
                                {question.explanation}
                            </p>
                        </div>
                    </div>
                </CardFooter>
            )}
        </Card>
    );
};
</file>

<file path="src/features/exams/ui/quiz/QuestionNavigation.tsx">
import React from 'react';
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Check, Clock, Flag, HelpCircle } from 'lucide-react';
import { UserAnswer } from '../../model/types';

interface QuestionNavigationProps {
    totalQuestions: number;
    currentQuestion: number;
    answers: { [key: string]: UserAnswer };
    flaggedQuestions: Set<number>;
    onQuestionSelect: (index: number) => void;
    minimumRequired: number;
}

export const QuestionNavigation = ({
    totalQuestions,
    currentQuestion,
    answers,
    flaggedQuestions,
    onQuestionSelect,
    minimumRequired,
}: QuestionNavigationProps) => {
    const getQuestionStatus = (index: number) => {
        const questionId = `q-${index + 1}`;
        const isAnswered = !!answers[questionId];
        const isFlagged = flaggedQuestions.has(index);
        const isCurrent = currentQuestion === index;

        if (isCurrent) return 'current';
        if (isAnswered) return 'answered';
        if (isFlagged) return 'flagged';
        return 'unanswered';
    };

    const getButtonStyle = (status: string) => {
        switch (status) {
            case 'current':
                return 'bg-blue-100 border-blue-500 text-blue-700';
            case 'answered':
                return 'bg-green-50 border-green-500 text-green-700';
            case 'flagged':
                return 'bg-yellow-50 border-yellow-500 text-yellow-700';
            default:
                return 'bg-gray-50 border-gray-300 text-gray-600';
        }
    };

    return (
        <div className="w-64 h-full bg-white border-l">
            <div className="p-4 border-b">
                <h3 className="font-semibold mb-2">Questions Overview</h3>
                <div className="space-y-2 text-sm">
                    <div className="flex items-center justify-between">
                        <div className="flex items-center space-x-2">
                            <Check className="h-4 w-4 text-green-500" />
                            <span>Answered</span>
                        </div>
                        <span className="font-mono">
                            {Object.keys(answers).length}/{minimumRequired}
                        </span>
                    </div>
                    <div className="flex items-center justify-between">
                        <div className="flex items-center space-x-2">
                            <Flag className="h-4 w-4 text-yellow-500" />
                            <span>Flagged</span>
                        </div>
                        <span className="font-mono">{flaggedQuestions.size}</span>
                    </div>
                    <div className="flex items-center justify-between">
                        <div className="flex items-center space-x-2">
                            <HelpCircle className="h-4 w-4 text-gray-500" />
                            <span>Unanswered</span>
                        </div>
                        <span className="font-mono">
                            {totalQuestions - Object.keys(answers).length}
                        </span>
                    </div>
                </div>
            </div>

            <ScrollArea className="h-[calc(100vh-12rem)] p-4">
                <div className="grid grid-cols-5 gap-2">
                    {Array.from({ length: totalQuestions }, (_, i) => {
                        const status = getQuestionStatus(i);
                        return (
                            <Button
                                key={i}
                                variant="outline"
                                size="sm"
                                className={`w-full h-8 p-0 font-mono ${getButtonStyle(
                                    status
                                )}`}
                                onClick={() => onQuestionSelect(i)}
                            >
                                {i + 1}
                            </Button>
                        );
                    })}
                </div>
            </ScrollArea>
        </div>
    );
};
</file>

<file path="src/features/exams/ui/results/PerformanceCharts.tsx">
import React from 'react';
import {
    Card,
    CardContent,
    CardHeader,
    CardTitle,
} from "@/components/ui/card";
import { QuestionAnalysis } from '../../lib/analysis';
import {
    BarChart,
    Bar,
    XAxis,
    YAxis,
    Tooltip,
    ResponsiveContainer,
    PieChart,
    Pie,
    Cell,
    Legend,
} from 'recharts';

interface PerformanceChartsProps {
    analysis: QuestionAnalysis;
}

export const PerformanceCharts = ({ analysis }: PerformanceChartsProps) => {
    // Prepare data for topic-wise performance chart
    const topicData = Object.entries(analysis.topicWiseAnalysis).map(([topic, stats]) => ({
        name: topic,
        Accuracy: Math.round(stats.accuracy),
        Attempted: Math.round((stats.attempted / stats.total) * 100),
    }));

    // Prepare data for difficulty distribution pie chart
    const difficultyData = Object.entries(analysis.difficultyAnalysis).map(([difficulty, stats]) => ({
        name: difficulty,
        value: stats.total,
        correct: stats.correct,
    }));

    const DIFFICULTY_COLORS = {
        easy: '#4ade80',
        medium: '#fbbf24',
        hard: '#f87171',
    };

    return (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Topic-wise Performance Chart */}
            <Card>
                <CardHeader>
                    <CardTitle>Topic-wise Performance</CardTitle>
                </CardHeader>
                <CardContent>
                    <div className="h-[300px]">
                        <ResponsiveContainer width="100%" height="100%">
                            <BarChart data={topicData}>
                                <XAxis 
                                    dataKey="name" 
                                    tickLine={false}
                                    axisLine={false}
                                    fontSize={12}
                                    angle={-45}
                                    textAnchor="end"
                                    height={80}
                                />
                                <YAxis 
                                    tickLine={false}
                                    axisLine={false}
                                    fontSize={12}
                                />
                                <Tooltip />
                                <Bar
                                    dataKey="Accuracy"
                                    fill="#3b82f6"
                                    radius={[4, 4, 0, 0]}
                                />
                                <Bar
                                    dataKey="Attempted"
                                    fill="#93c5fd"
                                    radius={[4, 4, 0, 0]}
                                />
                            </BarChart>
                        </ResponsiveContainer>
                    </div>
                </CardContent>
            </Card>

            {/* Difficulty Distribution Chart */}
            <Card>
                <CardHeader>
                    <CardTitle>Question Difficulty Distribution</CardTitle>
                </CardHeader>
                <CardContent>
                    <div className="h-[300px]">
                        <ResponsiveContainer width="100%" height="100%">
                            <PieChart>
                                <Pie
                                    data={difficultyData}
                                    dataKey="value"
                                    nameKey="name"
                                    cx="50%"
                                    cy="50%"
                                    innerRadius={60}
                                    outerRadius={80}
                                    paddingAngle={5}
                                >
                                    {difficultyData.map((entry, index) => (
                                        <Cell
                                            key={`cell-${index}`}
                                            fill={DIFFICULTY_COLORS[entry.name as keyof typeof DIFFICULTY_COLORS]}
                                        />
                                    ))}
                                </Pie>
                                <Tooltip />
                                <Legend 
                                    verticalAlign="bottom" 
                                    height={36}
                                    formatter={(value) => {
                                        const data = difficultyData.find(d => d.name === value);
                                        return `${value} (${data?.correct}/${data?.value})`;
                                    }}
                                />
                            </PieChart>
                        </ResponsiveContainer>
                    </div>
                </CardContent>
            </Card>

            {/* Time Distribution Chart */}
            <Card>
                <CardHeader>
                    <CardTitle>Average Time per Topic</CardTitle>
                </CardHeader>
                <CardContent>
                    <div className="h-[300px]">
                        <ResponsiveContainer width="100%" height="100%">
                            <BarChart
                                data={Object.entries(analysis.topicWiseAnalysis).map(([topic, stats]) => ({
                                    name: topic,
                                    time: Math.round(stats.averageTime),
                                }))}
                            >
                                <XAxis 
                                    dataKey="name"
                                    tickLine={false}
                                    axisLine={false}
                                    fontSize={12}
                                    angle={-45}
                                    textAnchor="end"
                                    height={80}
                                />
                                <YAxis
                                    tickLine={false}
                                    axisLine={false}
                                    fontSize={12}
                                    unit="s"
                                />
                                <Tooltip />
                                <Bar
                                    dataKey="time"
                                    fill="#a855f7"
                                    radius={[4, 4, 0, 0]}
                                />
                            </BarChart>
                        </ResponsiveContainer>
                    </div>
                </CardContent>
            </Card>

            {/* Performance Recommendations */}
            <Card>
                <CardHeader>
                    <CardTitle>Improvement Areas</CardTitle>
                </CardHeader>
                <CardContent>
                    <div className="space-y-4">
                        {Object.entries(analysis.topicWiseAnalysis)
                            .filter(([_, stats]) => stats.accuracy < 70)
                            .map(([topic, stats]) => (
                                <div key={topic} className="space-y-2">
                                    <div className="flex justify-between items-center">
                                        <span className="font-medium">{topic}</span>
                                        <span className="text-sm text-muted-foreground">
                                            {Math.round(stats.accuracy)}% accuracy
                                        </span>
                                    </div>
                                    <div className="text-sm text-muted-foreground">
                                        {stats.accuracy < 50
                                            ? 'Needs significant improvement'
                                            : 'Room for improvement'}
                                    </div>
                                </div>
                            ))}
                    </div>
                </CardContent>
            </Card>
        </div>
    );
};
</file>

<file path="src/features/exams/ui/results/ResultsView.tsx">
import React from 'react';
import {
    Card,
    CardContent,
    CardDescription,
    CardHeader,
    CardTitle,
} from "@/components/ui/card";
import {
    Table,
    TableBody,
    TableCell,
    TableHead,
    TableHeader,
    TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import {
    CheckCircle2,
    XCircle,
    Clock,
    BrainCircuit,
    Target,
    ChevronRight,
} from 'lucide-react';
import { useExamStore } from '../../store/examStore';
import { useRouter } from 'next/navigation';

export const ResultsView = () => {
    const router = useRouter();
    const { currentPaper, answers, timeRemaining } = useExamStore();

    if (!currentPaper) {
        router.push('/exam');
        return null;
    }

    const totalQuestions = currentPaper.totalQuestions;
    const totalAttempted = Object.keys(answers).length;
    const correctAnswers = Object.values(answers).filter(a => a.isCorrect).length;
    const incorrectAnswers = totalAttempted - correctAnswers;
    const score = correctAnswers - (incorrectAnswers * 0.25);
    const percentage = (score / totalQuestions) * 100;
    const timeSpent = (currentPaper.timeLimit * 60) - timeRemaining;

    const isPassed = percentage >= currentPaper.passingCriteria.passingScore;

    const topicPerformance = currentPaper.sections[0].questions.reduce((acc, q) => {
        const topic = q.metadata.topic;
        if (!acc[topic]) {
            acc[topic] = { total: 0, correct: 0 };
        }
        acc[topic].total++;
        if (answers[q.id]?.isCorrect) {
            acc[topic].correct++;
        }
        return acc;
    }, {} as Record<string, { total: number; correct: number }>);

    return (
        <div className="container py-8 space-y-6">
            {/* Overall Score Card */}
            <Card className={isPassed ? 'bg-green-50' : 'bg-red-50'}>
                <CardHeader>
                    <CardTitle className="flex items-center space-x-2">
                        {isPassed ? (
                            <>
                                <CheckCircle2 className="h-6 w-6 text-green-600" />
                                <span>Congratulations!</span>
                            </>
                        ) : (
                            <>
                                <XCircle className="h-6 w-6 text-red-600" />
                                <span>Keep Practicing</span>
                            </>
                        )}
                    </CardTitle>
                    <CardDescription>
                        {isPassed
                            ? "You've successfully completed the exam!"
                            : "Don't worry, keep practicing to improve your score."}
                    </CardDescription>
                </CardHeader>
                <CardContent>
                    <div className="space-y-4">
                        <div className="flex items-center justify-between">
                            <span className="text-2xl font-bold">
                                {score.toFixed(2)} / {totalQuestions}
                            </span>
                            <Badge
                                variant={isPassed ? 'default' : 'destructive'}
                                className="text-lg px-4 py-1"
                            >
                                {percentage.toFixed(1)}%
                            </Badge>
                        </div>
                        <Progress value={percentage} className="h-2" />
                    </div>
                </CardContent>
            </Card>

            {/* Performance Metrics */}
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <Card>
                    <CardHeader className="pb-2">
                        <CardTitle className="text-sm text-muted-foreground">
                            Time Spent
                        </CardTitle>
                    </CardHeader>
                    <CardContent>
                        <div className="flex items-center">
                            <Clock className="h-4 w-4 mr-2 text-blue-500" />
                            <span className="text-2xl font-bold">
                                {Math.floor(timeSpent / 60)}m {timeSpent % 60}s
                            </span>
                        </div>
                    </CardContent>
                </Card>

                <Card>
                    <CardHeader className="pb-2">
                        <CardTitle className="text-sm text-muted-foreground">
                            Accuracy
                        </CardTitle>
                    </CardHeader>
                    <CardContent>
                        <div className="flex items-center">
                            <Target className="h-4 w-4 mr-2 text-green-500" />
                            <span className="text-2xl font-bold">
                                {totalAttempted > 0 
                                    ? ((correctAnswers / totalAttempted) * 100).toFixed(1)
                                    : '0'}%
                            </span>
                        </div>
                    </CardContent>
                </Card>

                <Card>
                    <CardHeader className="pb-2">
                        <CardTitle className="text-sm text-muted-foreground">
                            Questions Attempted
                        </CardTitle>
                    </CardHeader>
                    <CardContent>
                        <div className="flex items-center">
                            <BrainCircuit className="h-4 w-4 mr-2 text-purple-500" />
                            <span className="text-2xl font-bold">
                                {totalAttempted} / {totalQuestions}
                            </span>
                        </div>
                    </CardContent>
                </Card>
            </div>

            {/* Topic-wise Performance */}
            <Card>
                <CardHeader>
                    <CardTitle>Topic-wise Performance</CardTitle>
                </CardHeader>
                <CardContent>
                    <div className="space-y-4">
                        {Object.entries(topicPerformance).map(([topic, data]) => (
                            <div key={topic}>
                                <div className="flex justify-between mb-1">
                                    <div className="flex items-center">
                                        <span className="font-medium">{topic}</span>
                                        <Badge
                                            variant="outline"
                                            className="ml-2"
                                        >
                                            {((data.correct / data.total) * 100).toFixed(0)}%
                                        </Badge>
                                    </div>
                                    <span className="text-muted-foreground">
                                        {data.correct} / {data.total}
                                    </span>
                                </div>
                                <Progress
                                    value={(data.correct / data.total) * 100}
                                    className="h-2"
                                />
                            </div>
                        ))}
                    </div>
                </CardContent>
            </Card>

            {/* Question-wise Analysis */}
            <Card>
                <CardHeader>
                    <CardTitle>Question Analysis</CardTitle>
                    <CardDescription>
                        Detailed breakdown of your performance on each question
                    </CardDescription>
                </CardHeader>
                <CardContent>
                    <div className="rounded-md border">
                        <Table>
                            <TableHeader>
                                <TableRow>
                                    <TableHead className="w-20">Q.No</TableHead>
                                    <TableHead>Topic</TableHead>
                                    <TableHead>Your Answer</TableHead>
                                    <TableHead>Correct Answer</TableHead>
                                    <TableHead className="text-center">Result</TableHead>
                                    <TableHead>Time</TableHead>
                                </TableRow>
                            </TableHeader>
                            <TableBody>
                                {currentPaper.sections[0].questions.map((q, index) => {
                                    const answer = answers[q.id];
                                    return (
                                        <TableRow key={q.id}>
                                            <TableCell className="font-medium">
                                                {index + 1}
                                            </TableCell>
                                            <TableCell>
                                                <Badge variant="outline">
                                                    {q.metadata.topic}
                                                </Badge>
                                            </TableCell>
                                            <TableCell>
                                                {answer?.selectedOption || '—'}
                                            </TableCell>
                                            <TableCell>{q.answer}</TableCell>
                                            <TableCell className="text-center">
                                                {answer ? (
                                                    answer.isCorrect ? (
                                                        <CheckCircle2 className="h-4 w-4 text-green-500 mx-auto" />
                                                    ) : (
                                                        <XCircle className="h-4 w-4 text-red-500 mx-auto" />
                                                    )
                                                ) : (
                                                    <span className="text-muted-foreground">—</span>
                                                )}
                                            </TableCell>
                                            <TableCell>
                                                {answer?.timeSpent
                                                    ? `${answer.timeSpent}s`
                                                    : '—'}
                                            </TableCell>
                                        </TableRow>
                                    );
                                })}
                            </TableBody>
                        </Table>
                    </div>
                </CardContent>
            </Card>

            {/* Action Buttons */}
            <div className="flex justify-between">
                <Button
                    variant="outline"
                    onClick={() => router.push('/exam')}
                >
                    Back to Papers
                </Button>
                <div className="space-x-2">
                    <Button
                        variant="outline"
                        onClick={() => useExamStore.getState().resetExam()}
                    >
                        Retake Exam
                    </Button>
                    <Button
                        onClick={() => router.push(`/exam/review/${currentPaper.id}`)}
                    >
                        Review Answers
                        <ChevronRight className="h-4 w-4 ml-2" />
                    </Button>
                </div>
            </div>
        </div>
    );
};
</file>

<file path="src/features/exams/ui/review/ReviewMode.tsx">
"use client";

import React from 'react';
import {
    Card,
    CardContent,
    CardHeader,
    CardTitle,
    CardDescription,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import {
    CheckCircle2,
    XCircle,
    ChevronLeft,
    ChevronRight,
    HelpCircle,
    ArrowLeft,
} from 'lucide-react';
import { useRouter } from 'next/navigation';
import { MCQPaper, UserAnswer } from '../../model/types';

interface ReviewModeProps {
    paper: MCQPaper;
    answers: Record<string, UserAnswer>;
}

export const ReviewMode = ({ paper, answers }: ReviewModeProps) => {
    const router = useRouter();
    const [currentQuestionIndex, setCurrentQuestionIndex] = React.useState(0);
    const currentQuestion = paper.sections[0].questions[currentQuestionIndex];
    const currentAnswer = answers[currentQuestion.id];

    const getOptionStyle = (optionKey: string) => {
        const isSelected = currentAnswer?.selectedOption === optionKey;
        const isCorrect = optionKey === currentQuestion.answer;

        if (isSelected && isCorrect) {
            return 'bg-green-50 border-green-500 text-green-700';
        }
        if (isSelected && !isCorrect) {
            return 'bg-red-50 border-red-500 text-red-700';
        }
        if (isCorrect) {
            return 'bg-green-50 border-green-500 text-green-700';
        }
        return '';
    };

    return (
        <div className="container py-8 space-y-6">
            {/* Navigation Header */}
            <div className="flex justify-between items-center">
                <Button
                    variant="ghost"
                    onClick={() => router.back()}
                >
                    <ArrowLeft className="h-4 w-4 mr-2" />
                    Back to Results
                </Button>
                <div className="space-x-2">
                    <Button
                        variant="outline"
                        onClick={() => setCurrentQuestionIndex(prev => prev - 1)}
                        disabled={currentQuestionIndex === 0}
                    >
                        <ChevronLeft className="h-4 w-4 mr-2" />
                        Previous
                    </Button>
                    <Button
                        variant="outline"
                        onClick={() => setCurrentQuestionIndex(prev => prev + 1)}
                        disabled={currentQuestionIndex === paper.totalQuestions - 1}
                    >
                        Next
                        <ChevronRight className="h-4 w-4 ml-2" />
                    </Button>
                </div>
            </div>

            {/* Question Card */}
            <Card className="w-full max-w-4xl mx-auto">
                <CardHeader>
                    <div className="flex justify-between items-start">
                        <div className="space-y-1">
                            <CardTitle>
                                Question {currentQuestionIndex + 1}
                            </CardTitle>
                            <div className="flex items-center space-x-2">
                                <Badge variant="outline">
                                    {currentQuestion.metadata.topic}
                                </Badge>
                                <Badge
                                    variant="outline"
                                    className={
                                        currentQuestion.metadata.difficulty === 'easy'
                                            ? 'bg-green-50'
                                            : currentQuestion.metadata.difficulty === 'medium'
                                            ? 'bg-yellow-50'
                                            : 'bg-red-50'
                                    }
                                >
                                    {currentQuestion.metadata.difficulty}
                                </Badge>
                            </div>
                        </div>
                        {currentAnswer && (
                            <Badge
                                variant={currentAnswer.isCorrect ? 'default' : 'destructive'}
                                className="ml-2"
                            >
                                {currentAnswer.isCorrect ? '+1' : '-0.25'}
                            </Badge>
                        )}
                    </div>
                    <CardDescription className="text-lg font-medium text-foreground mt-4">
                        {currentQuestion.question}
                    </CardDescription>
                </CardHeader>

                <CardContent className="space-y-6">
                    {/* Options */}
                    <div className="space-y-3">
                        {Object.entries(currentQuestion.options).map(([key, value]) => (
                            <div
                                key={key}
                                className={`p-4 rounded-lg border ${getOptionStyle(key)}`}
                            >
                                <div className="flex items-center">
                                    <span className="font-bold mr-2">{key}.</span>
                                    <span>{value}</span>
                                    {key === currentQuestion.answer && (
                                        <CheckCircle2 className="h-4 w-4 ml-2 text-green-500" />
                                    )}
                                    {key === currentAnswer?.selectedOption && 
                                     key !== currentQuestion.answer && (
                                        <XCircle className="h-4 w-4 ml-2 text-red-500" />
                                    )}
                                </div>
                            </div>
                        ))}
                    </div>

                    {/* Explanation */}
                    <div className="pt-6 border-t">
                        <div className="flex items-start space-x-2">
                            <HelpCircle className="h-5 w-5 text-blue-500 mt-0.5" />
                            <div>
                                <h4 className="font-semibold mb-2">Explanation</h4>
                                <p className="text-muted-foreground">
                                    {currentQuestion.explanation}
                                </p>
                            </div>
                        </div>
                    </div>

                    {/* Key Points */}
                    {currentQuestion.metadata.keyPoints?.length > 0 && (
                        <div className="pt-4">
                            <h4 className="font-semibold mb-2">Key Points</h4>
                            <ul className="list-disc pl-5 space-y-1">
                                {currentQuestion.metadata.keyPoints.map((point, index) => (
                                    <li key={index} className="text-muted-foreground">
                                        {point}
                                    </li>
                                ))}
                            </ul>
                        </div>
                    )}

                    {/* References if available */}
                    {currentQuestion.metadata.references?.length > 0 && (
                        <div className="pt-4 border-t">
                            <h4 className="font-semibold mb-2">References</h4>
                            <ul className="list-disc pl-5 space-y-1">
                                {currentQuestion.metadata.references.map((ref, index) => (
                                    <li key={index} className="text-muted-foreground">
                                        {ref}
                                    </li>
                                ))}
                            </ul>
                        </div>
                    )}
                </CardContent>
            </Card>

            {/* Question Navigation */}
            <div className="w-full max-w-4xl mx-auto">
                <div className="flex items-center space-x-4">
                    <div className="flex-1">
                        <div className="bg-gray-200 rounded-full h-2">
                            <div
                                className="bg-blue-600 h-2 rounded-full transition-all"
                                style={{
                                    width: `${((currentQuestionIndex + 1) / paper.totalQuestions) * 100}%`,
                                }}
                            />
                        </div>
                    </div>
                    <span className="text-sm text-muted-foreground">
                        {currentQuestionIndex + 1} / {paper.totalQuestions}
                    </span>
                </div>
            </div>
        </div>
    );
};
</file>

<file path="src/features/home/ui/FeatureCardSection.tsx">
import React from 'react';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { ChevronRight, Users, Building2, Store, UserCircle } from 'lucide-react';
import { motion } from 'framer-motion';

export const FeatureCardSection = () => {
  const features = [
    {
      icon: "/Images/pharmacist.png",
      title: "For Pharmacists",
      description: "Join our network of qualified pharmacists",
      iconComponent: <UserCircle className="w-10 h-10 text-blue-500" />,
      color: "from-blue-500 to-blue-600",
      delay: 0.1
    },
    {
      icon: "/Images/pharmacist.png",
      title: "For Pharmacy Managers",
      description: "Manage your pharmacy efficiently",
      iconComponent: <Users className="w-10 h-10 text-indigo-500" />,
      color: "from-indigo-500 to-indigo-600",
      delay: 0.2
    },
    {
      icon: "/Images/pharmacist.png",
      title: "For Proprietors",
      description: "Grow your pharmacy business",
      iconComponent: <Building2 className="w-10 h-10 text-purple-500" />,
      color: "from-purple-500 to-purple-600",
      delay: 0.3
    },
    {
      icon: "/Images/pharmacist.png",
      title: "For Salesmen",
      description: "Connect with pharmacies and boost your sales",
      iconComponent: <Store className="w-10 h-10 text-rose-500" />,
      color: "from-rose-500 to-rose-600",
      delay: 0.4
    },
  ];

  return (
    <section className="py-24 bg-gradient-to-b from-white to-gray-50">
      <div className="container mx-auto px-4 space-y-12">
        <div className="text-center space-y-4 max-w-2xl mx-auto">
  
        <h2 className="text-4xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 bg-clip-text text-transparent">
            Join Our Growing Network
          </h2>
          <p className="text-gray-600 text-lg">
            Connect with pharmacies, managers, and professionals across the industry
          </p>
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
          {features.map((feature, index) => (
            <motion.div
              key={index}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: feature.delay, duration: 0.5 }}
            >
              <Card className="relative p-6 overflow-hidden group hover:shadow-xl transition-all duration-300 border-none bg-white/90 backdrop-blur-sm">
                <div className={`absolute inset-0 bg-gradient-to-br opacity-0 group-hover:opacity-5 transition-opacity duration-300 ${feature.color}`} />
                <div className="flex flex-col items-center text-center relative space-y-4">
                  <div className="p-3 rounded-full bg-gray-50 group-hover:scale-110 transition-transform duration-300">
                    {feature.iconComponent}
                  </div>
                  <h3 className="text-xl font-semibold bg-gradient-to-r from-gray-800 to-gray-600 bg-clip-text text-transparent">
                    {feature.title}
                  </h3>
                  <p className="text-gray-600">
                    {feature.description}
                  </p>
                  <Button 
                    variant="ghost" 
                    className="mt-4 text-blue-600 hover:text-blue-700 hover:bg-blue-50 transition-colors group"
                  >
                    Learn More
                    <ChevronRight className="w-4 h-4 ml-1 group-hover:translate-x-1 transition-transform" />
                  </Button>
                </div>
              </Card>
            </motion.div>
          ))}
        </div>
      </div>
    </section>
  );
};

export default FeatureCardSection;
</file>

<file path="src/features/home/ui/Footer.tsx">
'use client';

import React from 'react';
import Image from 'next/image';
import Link from 'next/link';

export const Footer = () => {
  return (
    <footer className="bg-gray-100 py-12">
      <div className="container mx-auto px-4">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-8">
          <div className="space-y-4">
            <div className="flex items-center space-x-2">
              <Image
                src="/Images/PharmacyHub.png"
                alt="Pharmacy Hub logo"
                width={40}
                height={40}
                className="object-contain"
              />
              <span className="text-xl font-bold">Pharmacy Hub</span>
            </div>
            <p className="text-gray-600 max-w-xs">
              Connecting pharmacists, pharmacy managers, and proprietors for a better healthcare ecosystem.
            </p>
          </div>
          
          <div>
            <h3 className="font-semibold text-lg mb-4">Services</h3>
            <ul className="space-y-2">
              <li><Link href="#" className="text-gray-600 hover:text-primary">Pharmacy Licensing</Link></li>
              <li><Link href="#" className="text-gray-600 hover:text-primary">Professional Connections</Link></li>
              <li><Link href="#" className="text-gray-600 hover:text-primary">Exam Preparation</Link></li>
              <li><Link href="#" className="text-gray-600 hover:text-primary">Regulatory Compliance</Link></li>
            </ul>
          </div>
          
          <div>
            <h3 className="font-semibold text-lg mb-4">Resources</h3>
            <ul className="space-y-2">
              <li><Link href="#" className="text-gray-600 hover:text-primary">Documentation</Link></li>
              <li><Link href="#" className="text-gray-600 hover:text-primary">Blog</Link></li>
              <li><Link href="#" className="text-gray-600 hover:text-primary">Support</Link></li>
              <li><Link href="#" className="text-gray-600 hover:text-primary">FAQs</Link></li>
            </ul>
          </div>
          
          <div>
            <h3 className="font-semibold text-lg mb-4">Contact</h3>
            <ul className="space-y-2">
              <li className="text-gray-600">Email: contact@pharmacyhub.com</li>
              <li className="text-gray-600">Phone: +1 (123) 456-7890</li>
              <li className="text-gray-600">Address: 123 Pharmacy Street, Health City</li>
            </ul>
            <div className="mt-4 flex space-x-4">
              <Link href="#" aria-label="Twitter" className="text-gray-500 hover:text-primary">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-twitter">
                  <path d="M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z" />
                </svg>
              </Link>
              <Link href="#" aria-label="Facebook" className="text-gray-500 hover:text-primary">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-facebook">
                  <path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z" />
                </svg>
              </Link>
              <Link href="#" aria-label="Instagram" className="text-gray-500 hover:text-primary">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-instagram">
                  <rect width="20" height="20" x="2" y="2" rx="5" ry="5" />
                  <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z" />
                  <line x1="17.5" x2="17.51" y1="6.5" y2="6.5" />
                </svg>
              </Link>
              <Link href="#" aria-label="LinkedIn" className="text-gray-500 hover:text-primary">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-linkedin">
                  <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z" />
                  <rect width="4" height="12" x="2" y="9" />
                  <circle cx="4" cy="4" r="2" />
                </svg>
              </Link>
            </div>
          </div>
        </div>
        
        <div className="border-t border-gray-200 mt-12 pt-8 text-center text-gray-500">
          <p>© {new Date().getFullYear()} Pharmacy Hub. All rights reserved.</p>
        </div>
      </div>
    </footer>
  );
};
</file>

<file path="src/features/progress/hooks/useProgressQueries.ts">
import { useQuery } from '@tanstack/react-query';
import { progressApi, Progress, Analytics, Recommendation } from '../api/progressApi';

// Define query keys for progress data
export const PROGRESS_KEYS = {
  all: ['progress'] as const,
  user: (userId: string) => [...PROGRESS_KEYS.all, userId] as const,
  analytics: (userId: string, startDate?: string, endDate?: string) => 
    [...PROGRESS_KEYS.all, 'analytics', userId, { startDate, endDate }] as const,
  recommendations: (userId: string) => 
    [...PROGRESS_KEYS.all, 'recommendations', userId] as const,
};

/**
 * Hook for fetching user progress data
 */
export function useUserProgress(userId: string) {
  return useQuery<Progress>({
    queryKey: PROGRESS_KEYS.user(userId),
    queryFn: () => progressApi.getUserProgress(userId),
    enabled: !!userId,
  });
}

/**
 * Hook for fetching user analytics data
 */
export function useUserAnalytics(userId: string, startDate?: string, endDate?: string) {
  return useQuery<Analytics>({
    queryKey: PROGRESS_KEYS.analytics(userId, startDate, endDate),
    queryFn: () => progressApi.getAnalytics(userId, startDate, endDate),
    enabled: !!userId,
  });
}

/**
 * Hook for fetching user recommendations
 */
export function useUserRecommendations(userId: string) {
  return useQuery<Recommendation[]>({
    queryKey: PROGRESS_KEYS.recommendations(userId),
    queryFn: () => progressApi.getRecommendations(userId),
    enabled: !!userId,
  });
}

/**
 * Composite hook that fetches all progress-related data
 */
export function useProgress(userId: string) {
  const progressQuery = useUserProgress(userId);
  const analyticsQuery = useUserAnalytics(userId);
  const recommendationsQuery = useUserRecommendations(userId);

  return {
    progress: progressQuery.data,
    analytics: analyticsQuery.data,
    recommendations: recommendationsQuery.data,
    isLoading: 
      progressQuery.isLoading || 
      analyticsQuery.isLoading || 
      recommendationsQuery.isLoading,
    error: 
      progressQuery.error || 
      analyticsQuery.error || 
      recommendationsQuery.error,
    refetch: () => {
      progressQuery.refetch();
      analyticsQuery.refetch();
      recommendationsQuery.refetch();
    }
  };
}
</file>

<file path="src/features/rbac/api/hooks/useRbacQueries.ts">
/**
 * RBAC Query Hooks
 * TanStack Query hooks for RBAC-related data fetching
 */
import { 
  useApiQuery, 
  useApiMutation, 
  UseApiQueryOptions 
} from '@/features/tanstack-query-api';
import { rbacService } from '../services/rbacService';
import { rbacQueryKeys } from '../queryKeys';
import type { AccessProfile, PermissionCheckResponse } from '../../types';

/**
 * Hook to get the current user's access profile
 */
export function useAccessProfile(options?: UseApiQueryOptions<AccessProfile>) {
  return useApiQuery<AccessProfile>(
    rbacQueryKeys.profile(),
    () => rbacService.getUserAccessProfile(),
    options
  );
}

/**
 * Hook to get a user's access profile by ID
 */
export function useUserAccessProfile(userId: string, options?: UseApiQueryOptions<AccessProfile>) {
  return useApiQuery<AccessProfile>(
    rbacQueryKeys.userProfile(userId),
    () => rbacService.getUserAccessProfileById(userId),
    {
      enabled: !!userId,
      ...options
    }
  );
}

/**
 * Hook to check specific permissions
 */
export function useCheckPermissions(
  permissions: string[],
  options?: UseApiQueryOptions<PermissionCheckResponse>
) {
  return useApiQuery<PermissionCheckResponse>(
    rbacQueryKeys.permissions(permissions),
    () => rbacService.checkPermissions(permissions),
    {
      enabled: permissions.length > 0,
      ...options
    }
  );
}

/**
 * Hook to check access based on roles and/or permissions
 */
export function useCheckAccess(
  roles: string[] = [],
  permissions: string[] = [],
  requireAll: boolean = false,
  options?: UseApiQueryOptions<boolean>
) {
  return useApiQuery<boolean>(
    rbacQueryKeys.access(roles, permissions, requireAll),
    () => rbacService.checkAccess(roles, permissions, requireAll),
    {
      enabled: roles.length > 0 || permissions.length > 0,
      ...options
    }
  );
}
</file>

<file path="src/features/rbac/api/index.ts">
/**
 * RBAC API Module
 */

// Export service
export { rbacService } from './services/rbacService';
export { featureFlagService } from '../services/featureFlagService';

// Export query hooks
export {
  useAccessProfile,
  useUserAccessProfile,
  useCheckPermissions,
  useCheckAccess
} from './hooks/useRbacQueries';

// Export query keys
export { rbacQueryKeys } from './queryKeys';
</file>

<file path="src/features/rbac/api/queryKeys.ts">
/**
 * RBAC Query Keys
 * TanStack Query key factory for RBAC-related queries
 */
import { createQueryKeys } from '@/features/tanstack-query-api';

/**
 * Query keys for RBAC-related queries
 */
export const rbacQueryKeys = createQueryKeys('rbac', {
  // Access profile queries
  profile: () => ['profile'],
  userProfile: (userId: string) => ['userProfile', userId],
  
  // Permission checking queries
  permissions: (permissions: string[]) => ['permissions', permissions],
  
  // Complex access check queries
  access: (roles: string[], permissions: string[], requireAll: boolean) => [
    'access', 
    { roles, permissions, requireAll }
  ]
});
</file>

<file path="src/features/rbac/api/services/rbacService.ts">
/**
 * RBAC Service
 * Provides API methods for role and permission-based access control
 */
import { createExtendedApiService } from '@/features/tanstack-query-api';
import type { ApiResponse } from '@/features/tanstack-query-api';
import type { PermissionCheckResponse, AccessProfile } from '../../types';

/**
 * Service for RBAC-related API operations
 */
export const rbacService = createExtendedApiService<AccessProfile, {
  /**
   * Checks if the user has the specified permissions
   * 
   * @param permissions Array of permission codes to check
   * @returns Object mapping each permission to a boolean indicating if it's granted
   */
  checkPermissions: (permissions: string[]) => Promise<ApiResponse<PermissionCheckResponse>>;
  
  /**
   * Checks if the user has the required access based on roles and/or permissions
   * 
   * @param roles Array of roles to check
   * @param permissions Array of permissions to check
   * @param requireAll Whether all roles/permissions are required (true) or just any (false)
   * @returns Boolean indicating if access is granted
   */
  checkAccess: (
    roles: string[], 
    permissions: string[], 
    requireAll: boolean
  ) => Promise<ApiResponse<boolean>>;
  
  /**
   * Gets the complete access profile for the current user
   * 
   * @returns User's access profile including roles and permissions
   */
  getUserAccessProfile: () => Promise<ApiResponse<AccessProfile>>;
  
  /**
   * Gets the access profile for a specific user
   * 
   * @param userId ID of the user to get access profile for
   * @returns User's access profile including roles and permissions
   */
  getUserAccessProfileById: (userId: string) => Promise<ApiResponse<AccessProfile>>;
}>('security', {
  checkPermissions: async (permissions: string[]): Promise<ApiResponse<PermissionCheckResponse>> => {
    return await apiClient.post<PermissionCheckResponse>('/security/check-permissions', { permissions });
  },
  
  checkAccess: async (
    roles: string[], 
    permissions: string[], 
    requireAll: boolean
  ): Promise<ApiResponse<boolean>> => {
    return await apiClient.post<boolean>('/security/check-access', {
      roles,
      permissions,
      requireAll
    });
  },
  
  getUserAccessProfile: async (): Promise<ApiResponse<AccessProfile>> => {
    return await apiClient.get<AccessProfile>('/security/profile');
  },
  
  getUserAccessProfileById: async (userId: string): Promise<ApiResponse<AccessProfile>> => {
    return await apiClient.get<AccessProfile>(`/security/profile/${userId}`);
  }
});

// Fix to import the apiClient
import { apiClient } from '@/features/tanstack-query-api';
</file>

<file path="src/features/rbac/constants/permissions.ts">
/**
 * Permission and role constants for the RBAC system
 */

/**
 * System Roles
 */
export enum Role {
  // System roles
  ADMIN = 'ADMIN',
  SUPER_ADMIN = 'SUPER_ADMIN',
  USER = 'USER',
  GUEST = 'GUEST',
  
  // Pharmacy specific roles
  PHARMACIST = 'PHARMACIST',
  PHARMACY_MANAGER = 'PHARMACY_MANAGER',
  PROPRIETOR = 'PROPRIETOR',
  SALESMAN = 'SALESMAN',
  
  // Other application roles
  STUDENT = 'STUDENT',
  INSTRUCTOR = 'INSTRUCTOR'
}

/**
 * Permission constants
 * 
 * These are used throughout the application to check for specific permissions
 */
export type Permission = 
  // User management
  | 'manage_users'
  | 'view_users'
  
  // Role management
  | 'manage_roles'
  | 'view_roles'
  
  // Permission management
  | 'manage_permissions'
  | 'view_permissions'
  
  // Feature flags
  | 'manage_features'
  | 'view_features'
  
  // Pharmacy specific permissions
  | 'manage_pharmacists'
  | 'view_pharmacists'
  | 'manage_pharmacy_managers'
  | 'view_pharmacy_managers'
  | 'manage_proprietors'
  | 'view_proprietors'
  | 'manage_salesmen'
  | 'view_salesmen'
  
  // Inventory permissions
  | 'manage_inventory'
  | 'view_inventory'
  | 'manage_products'
  | 'view_products'
  
  // System permissions
  | 'manage_system'
  | 'view_system'
  | 'manage_settings'
  | 'view_settings'
  
  // Exam permissions
  | 'manage_exams'
  | 'view_exams'
  | 'create_exams'
  | 'edit_exams'
  | 'delete_exams'
  | 'grade_exams'
  | 'attempt_exams'
  
  // Report permissions
  | 'manage_reports'
  | 'view_reports'
  | 'create_reports'
  | 'export_reports'
  
  // Analytics permissions
  | 'view_analytics'
  | 'export_analytics'
  
  // Other permissions
  | string;

/**
 * Default permission sets for specific roles
 */
export const DEFAULT_PERMISSIONS: Record<Role, Permission[]> = {
  [Role.SUPER_ADMIN]: [
    'manage_users',
    'view_users',
    'manage_roles',
    'view_roles',
    'manage_permissions',
    'view_permissions',
    'manage_features',
    'view_features',
    'manage_system',
    'view_system',
    'manage_settings',
    'view_settings',
    'manage_reports',
    'view_reports',
    'create_reports',
    'export_reports',
    'view_analytics',
    'export_analytics'
  ],
  
  [Role.ADMIN]: [
    'manage_users',
    'view_users',
    'view_roles',
    'view_permissions',
    'manage_features',
    'view_features',
    'view_system',
    'manage_settings',
    'view_settings',
    'manage_reports',
    'view_reports',
    'create_reports',
    'view_analytics',
    'export_analytics'
  ],
  
  [Role.USER]: [
    'view_products'
  ],
  
  [Role.GUEST]: [],
  
  [Role.PHARMACIST]: [
    'view_products',
    'view_inventory',
    'attempt_exams',
    'view_exams'
  ],
  
  [Role.PHARMACY_MANAGER]: [
    'manage_inventory',
    'view_inventory',
    'manage_products',
    'view_products',
    'view_reports',
    'view_analytics'
  ],
  
  [Role.PROPRIETOR]: [
    'view_products',
    'view_inventory',
    'view_reports',
    'view_analytics'
  ],
  
  [Role.SALESMAN]: [
    'view_products'
  ],
  
  [Role.STUDENT]: [
    'attempt_exams',
    'view_exams'
  ],
  
  [Role.INSTRUCTOR]: [
    'manage_exams',
    'view_exams',
    'create_exams',
    'edit_exams',
    'grade_exams'
  ]
};

export default {
  Role,
  DEFAULT_PERMISSIONS
};
</file>

<file path="src/features/rbac/constants/roles.ts">
/**
 * Core roles definition for the application
 */

/**
 * Application Roles
 * Defines all user roles available in the system
 */
export enum Role {
  SUPER_ADMIN = 'SUPER_ADMIN',
  ADMIN = 'ADMIN',
  PHARMACIST = 'PHARMACIST',
  PHARMACY_MANAGER = 'PHARMACY_MANAGER',
  TECHNICIAN = 'TECHNICIAN',
  PROPRIETOR = 'PROPRIETOR',
  USER = 'USER'
}

/**
 * Role metadata with display names and descriptions
 */
export const ROLE_METADATA: Record<Role, { name: string; description: string }> = {
  [Role.SUPER_ADMIN]: {
    name: 'Super Administrator',
    description: 'Complete access to all system functions and settings'
  },
  [Role.ADMIN]: {
    name: 'Administrator',
    description: 'Manages users, content, and system settings'
  },
  [Role.PHARMACIST]: {
    name: 'Pharmacist',
    description: 'Licensed pharmacy professional with clinical responsibilities'
  },
  [Role.PHARMACY_MANAGER]: {
    name: 'Pharmacy Manager',
    description: 'Manages pharmacy operations and staff'
  },
  [Role.TECHNICIAN]: {
    name: 'Pharmacy Technician',
    description: 'Assists pharmacists with technical tasks and customer service'
  },
  [Role.PROPRIETOR]: {
    name: 'Business Owner',
    description: 'Owns or operates one or more pharmacy locations'
  },
  [Role.USER]: {
    name: 'Standard User',
    description: 'Basic access to non-administrative features'
  }
};

/**
 * Role hierarchy defines which roles implicitly include other roles.
 * The key role automatically includes permissions from all the roles in its value array.
 */
export const ROLE_HIERARCHY: Record<Role, Role[]> = {
  [Role.SUPER_ADMIN]: [Role.ADMIN, Role.PHARMACY_MANAGER, Role.PHARMACIST, Role.TECHNICIAN, Role.PROPRIETOR, Role.USER],
  [Role.ADMIN]: [Role.PHARMACY_MANAGER, Role.USER],
  [Role.PHARMACY_MANAGER]: [Role.PHARMACIST, Role.USER],
  [Role.PHARMACIST]: [Role.USER],
  [Role.TECHNICIAN]: [Role.USER],
  [Role.PROPRIETOR]: [Role.USER],
  [Role.USER]: []
};
</file>

<file path="src/features/rbac/contexts/FeatureContext.tsx">
'use client';

import React, { createContext, useContext, useState, useEffect } from 'react';
import { getAllFeatures } from '../registry';
import { featureFlagService } from '../services/featureFlagService';
import { useAccess } from '../hooks/useAccess';

// Context types
interface FeatureContextType {
  // Feature access
  isFeatureEnabled: (featureId: string) => boolean;
  isFeatureFlagEnabled: (featureId: string, flagId: string) => boolean;
  hasFeatureAccess: (featureId: string, permissionsRequired?: string[], rolesRequired?: string[]) => boolean;
  
  // Feature flags management
  enableFeature: (featureId: string) => void;
  disableFeature: (featureId: string) => void;
  enableFeatureFlag: (featureId: string, flagId: string) => void;
  disableFeatureFlag: (featureId: string, flagId: string) => void;
  
  // Feature information
  getFeatureInfo: (featureId: string) => any;
  getAllFeatureInfo: () => Record<string, any>;
  
  // Loading state
  isLoading: boolean;
}

// Create the context
const FeatureContext = createContext<FeatureContextType | undefined>(undefined);

/**
 * Provider component for feature management
 */
export const FeatureProvider: React.FC<{ 
  children: React.ReactNode,
  initialFeatures?: Record<string, boolean>
}> = ({ 
  children,
  initialFeatures = {} 
}) => {
  const [isLoading, setIsLoading] = useState(true);
  const [featureFlags, setFeatureFlags] = useState<Record<string, boolean>>({});
  const { hasAccess } = useAccess();
  
  // Initialize feature flags
  useEffect(() => {
    const initializeFlags = async () => {
      try {
        await featureFlagService.initialize();
        setFeatureFlags(featureFlagService.getAllFlags());
      } catch (error) {
        console.error('Failed to initialize feature flags', error);
      } finally {
        setIsLoading(false);
      }
    };
    
    initializeFlags();
  }, []);
  
  // Feature access functions
  const isFeatureEnabled = (featureId: string): boolean => {
    return featureFlagService.isEnabled(featureId);
  };
  
  const isFeatureFlagEnabled = (featureId: string, flagId: string): boolean => {
    return featureFlagService.isEnabled(featureId, flagId);
  };
  
  const hasFeatureAccess = (
    featureId: string, 
    permissionsRequired: string[] = [], 
    rolesRequired: string[] = []
  ): boolean => {
    // First check if the feature is enabled
    if (!isFeatureEnabled(featureId)) {
      return false;
    }
    
    // If no additional permissions or roles required, access is granted
    if (permissionsRequired.length === 0 && rolesRequired.length === 0) {
      return true;
    }
    
    // Check permissions and roles
    return hasAccess(rolesRequired, permissionsRequired);
  };
  
  // Feature flag management
  const enableFeature = (featureId: string): void => {
    featureFlagService.enableFeature(featureId);
    setFeatureFlags(featureFlagService.getAllFlags());
  };
  
  const disableFeature = (featureId: string): void => {
    featureFlagService.disableFeature(featureId);
    setFeatureFlags(featureFlagService.getAllFlags());
  };
  
  const enableFeatureFlag = (featureId: string, flagId: string): void => {
    featureFlagService.enableFeature(featureId, flagId);
    setFeatureFlags(featureFlagService.getAllFlags());
  };
  
  const disableFeatureFlag = (featureId: string, flagId: string): void => {
    featureFlagService.disableFeature(featureId, flagId);
    setFeatureFlags(featureFlagService.getAllFlags());
  };
  
  // Feature information
  const getFeatureInfo = (featureId: string): any => {
    const features = getAllFeatures();
    return features[featureId] || null;
  };
  
  const getAllFeatureInfo = (): Record<string, any> => {
    return getAllFeatures();
  };
  
  const contextValue: FeatureContextType = {
    isFeatureEnabled,
    isFeatureFlagEnabled,
    hasFeatureAccess,
    enableFeature,
    disableFeature,
    enableFeatureFlag,
    disableFeatureFlag,
    getFeatureInfo,
    getAllFeatureInfo,
    isLoading
  };
  
  return (
    <FeatureContext.Provider value={contextValue}>
      {children}
    </FeatureContext.Provider>
  );
};

/**
 * Hook for accessing feature management functionality
 */
export const useFeatures = (): FeatureContextType => {
  const context = useContext(FeatureContext);
  if (context === undefined) {
    throw new Error('useFeatures must be used within a FeatureProvider');
  }
  return context;
};

/**
 * Hook for checking a specific feature's access
 */
export const useFeature = (featureId: string, options?: {
  permissionsRequired?: string[];
  rolesRequired?: string[];
  flagId?: string;
}) => {
  const { 
    isFeatureEnabled, 
    isFeatureFlagEnabled, 
    hasFeatureAccess, 
    getFeatureInfo,
    isLoading 
  } = useFeatures();
  
  const { permissionsRequired = [], rolesRequired = [], flagId } = options || {};
  
  const isEnabled = flagId 
    ? isFeatureFlagEnabled(featureId, flagId) 
    : isFeatureEnabled(featureId);
  
  const hasAccess = hasFeatureAccess(featureId, permissionsRequired, rolesRequired);
  
  const featureInfo = getFeatureInfo(featureId);
  
  return {
    isEnabled,
    hasAccess,
    featureInfo,
    isLoading
  };
};

export default FeatureProvider;
</file>

<file path="src/features/rbac/hooks/index.ts">
/**
 * RBAC Hooks
 */
export { useAccess } from './useAccess';
export { useFeatureAccess } from './useFeatureAccess';

// Export with alternate name for compatibility
export { useAccess as usePermissions } from './useAccess';
</file>

<file path="src/features/rbac/hooks/useAccess.ts">
/**
 * Access Control Hook
 * Provides client-side RBAC functions
 */
import { useCallback } from 'react';
import { useAuth } from '@/features/auth';
import { rbacService } from '../api';
import type { AccessCheckOptions, RoleCheckOptions } from '../types';

/**
 * Hook providing functions to check user's permissions and roles
 */
export function useAccess() {
  const { user } = useAuth();
  
  /**
   * Check if user has a specific permission
   */
  const hasPermission = useCallback((permission: string, options?: RoleCheckOptions) => {
    // If no user or no permissions, deny access
    if (!user || !user.permissions) return false;
    
    // If client-side check is sufficient, return result immediately
    if (!options?.verifyOnBackend) {
      return user.permissions.includes(permission);
    }
    
    // Otherwise, verification will need to be done at the component level
    // using the RBAC API service
    return false;
  }, [user]);
  
  /**
   * Check if user has a specific role
   */
  const hasRole = useCallback((role: string, options?: RoleCheckOptions) => {
    // If no user or no roles, deny access
    if (!user || !user.roles) return false;
    
    // If client-side check is sufficient, return result immediately
    if (!options?.verifyOnBackend) {
      return user.roles.includes(role);
    }
    
    // Otherwise, verification will need to be done at the component level
    // using the RBAC API service
    return false;
  }, [user]);
  
  /**
   * Check if user has any of the specified roles
   */
  const hasAnyRole = useCallback((roles: string[], options?: RoleCheckOptions) => {
    if (!user || !user.roles || roles.length === 0) return false;
    
    if (!options?.verifyOnBackend) {
      return roles.some(role => user.roles.includes(role));
    }
    
    return false;
  }, [user]);
  
  /**
   * Check if user has all of the specified roles
   */
  const hasAllRoles = useCallback((roles: string[], options?: RoleCheckOptions) => {
    if (!user || !user.roles || roles.length === 0) return false;
    
    if (!options?.verifyOnBackend) {
      return roles.every(role => user.roles.includes(role));
    }
    
    return false;
  }, [user]);
  
  /**
   * Check if user has any of the specified permissions
   */
  const hasAnyPermission = useCallback((permissions: string[], options?: RoleCheckOptions) => {
    if (!user || !user.permissions || permissions.length === 0) return false;
    
    if (!options?.verifyOnBackend) {
      return permissions.some(permission => user.permissions.includes(permission));
    }
    
    return false;
  }, [user]);
  
  /**
   * Check if user has all of the specified permissions
   */
  const hasAllPermissions = useCallback((permissions: string[], options?: RoleCheckOptions) => {
    if (!user || !user.permissions || permissions.length === 0) return false;
    
    if (!options?.verifyOnBackend) {
      return permissions.every(permission => user.permissions.includes(permission));
    }
    
    return false;
  }, [user]);
  
  /**
   * Check complex access conditions (roles and/or permissions)
   */
  const hasAccess = useCallback((
    roles: string[] = [], 
    permissions: string[] = [],
    options?: AccessCheckOptions
  ) => {
    if (!user) return false;
    
    // Early return if no conditions provided
    if (roles.length === 0 && permissions.length === 0) return false;
    
    // If backend verification is required, component should handle that case
    if (options?.verifyOnBackend) return false;
    
    const requireAll = options?.requireAll ?? true;
    
    // Check roles
    let roleCheck = false;
    if (roles.length > 0) {
      roleCheck = requireAll
        ? hasAllRoles(roles)
        : hasAnyRole(roles);
    }
    
    // Check permissions
    let permissionCheck = false;
    if (permissions.length > 0) {
      permissionCheck = requireAll
        ? hasAllPermissions(permissions)
        : hasAnyPermission(permissions);
    }
    
    // Determine final result based on whether roles, permissions, or both were checked
    if (roles.length > 0 && permissions.length > 0) {
      // If both are checked, merge results according to requireAll
      return requireAll
        ? (roleCheck && permissionCheck)
        : (roleCheck || permissionCheck);
    } else if (roles.length > 0) {
      // Only roles were checked
      return roleCheck;
    } else {
      // Only permissions were checked
      return permissionCheck;
    }
  }, [user, hasAllRoles, hasAnyRole, hasAllPermissions, hasAnyPermission]);
  
  /**
   * Verify access on the backend
   */
  const verifyAccess = async (
    roles: string[] = [], 
    permissions: string[] = [],
    requireAll: boolean = true
  ) => {
    try {
      const response = await rbacService.checkAccess(roles, permissions, requireAll);
      return response.data || false;
    } catch (error) {
      console.error('Error verifying access:', error);
      return false;
    }
  };
  
  /**
   * Verify permissions on the backend
   */
  const verifyPermissions = async (permissions: string[]) => {
    try {
      const response = await rbacService.checkPermissions(permissions);
      return response.data || {};
    } catch (error) {
      console.error('Error verifying permissions:', error);
      return {};
    }
  };
  
  return {
    hasPermission,
    hasRole,
    hasAnyRole,
    hasAllRoles,
    hasAnyPermission,
    hasAllPermissions,
    hasAccess,
    verifyAccess,
    verifyPermissions
  };
}
</file>

<file path="src/features/rbac/hooks/useFeatureAccess.ts">
/**
 * Feature Access Hook
 * 
 * Custom hook for checking feature access and feature flags
 */
import { useContext } from 'react';
import { useFeatures } from '../contexts/FeatureContext';
import { getFeature, getFeaturePermissions } from '../registry';
import { useAccess } from './useAccess';

/**
 * Hook for checking if a feature is accessible to the current user
 * Takes into account both feature flags and user permissions
 */
export function useFeatureAccess(featureId: string, options?: {
  flagId?: string;
  permissionsRequired?: string[];
  rolesRequired?: string[];
  requireAll?: boolean;
}) {
  const { 
    isFeatureEnabled, 
    isFeatureFlagEnabled,
    getFeatureInfo,
    isLoading 
  } = useFeatures();
  
  const { hasAccess } = useAccess();
  
  const { 
    flagId, 
    permissionsRequired = [], 
    rolesRequired = [],
    requireAll = true
  } = options || {};
  
  // Get the feature data
  const feature = getFeatureInfo(featureId);
  
  // Check if the feature or feature flag is enabled
  const enabled = flagId 
    ? isFeatureFlagEnabled(featureId, flagId) 
    : isFeatureEnabled(featureId);
  
  // If no specific permissions/roles provided, use the feature's default required roles
  const effectiveRoles = rolesRequired.length > 0 
    ? rolesRequired 
    : (feature?.requiredRoles || []);
    
  // Check if the user has the required permissions and roles
  const hasRequiredAccess = hasAccess(
    effectiveRoles,
    permissionsRequired,
    { requireAll }
  );
  
  // Feature is accessible if it's enabled and the user has the required access
  const canAccess = enabled && hasRequiredAccess;
  
  return {
    canAccess,    // Can the user access the feature
    isEnabled: enabled,    // Is the feature turned on
    hasPermissions: hasRequiredAccess,  // Does the user have the required permissions
    feature,      // The feature data
    isLoading     // Is the feature system still loading
  };
}
</file>

<file path="src/features/rbac/hooks/usePermissions.ts">
/**
 * Custom hook for checking user permissions
 */
import { useAuth } from '@/features/auth/hooks';
import { useEffect, useState } from 'react';

type Permission = string;
type Role = string;

export function usePermissions() {
  const { user } = useAuth();
  const [permissions, setPermissions] = useState<Permission[]>([]);
  const [roles, setRoles] = useState<Role[]>([]);

  // Initialize permissions and roles when user changes
  useEffect(() => {
    if (user) {
      setPermissions(user.permissions || []);
      setRoles(user.roles || []);
    } else {
      setPermissions([]);
      setRoles([]);
    }
  }, [user]);

  // Check if the user has a specific permission
  const hasPermission = (permission: Permission): boolean => {
    if (!user) return false;
    
    // Check direct permissions
    if (permissions.includes(permission)) return true;
    
    // Admin role has all permissions
    if (roles.includes('admin')) return true;
    
    return false;
  };

  // Check if the user has all specified permissions
  const hasAllPermissions = (requiredPermissions: Permission[]): boolean => {
    return requiredPermissions.every(permission => hasPermission(permission));
  };

  // Check if the user has any of the specified permissions
  const hasAnyPermission = (requiredPermissions: Permission[]): boolean => {
    return requiredPermissions.some(permission => hasPermission(permission));
  };

  // Check if the user has a specific role
  const hasRole = (role: Role): boolean => {
    if (!user) return false;
    return roles.includes(role);
  };

  // Check if the user has all specified roles
  const hasAllRoles = (requiredRoles: Role[]): boolean => {
    return requiredRoles.every(role => hasRole(role));
  };

  // Check if the user has any of the specified roles
  const hasAnyRole = (requiredRoles: Role[]): boolean => {
    return requiredRoles.some(role => hasRole(role));
  };

  return {
    permissions,
    roles,
    hasPermission,
    hasAllPermissions,
    hasAnyPermission,
    hasRole,
    hasAllRoles,
    hasAnyRole,
  };
}
</file>

<file path="src/features/rbac/index.ts">
/**
 * RBAC (Role-Based Access Control) Feature
 * 
 * This feature provides a comprehensive solution for managing and enforcing
 * access control based on user roles and permissions.
 * 
 * Features:
 * - Client-side and server-side permission checking
 * - Role and permission-based UI component guards
 * - Access control hooks and utilities
 * - TanStack Query integration for data fetching
 * - Feature registry and management
 * - Feature flags
 */

// Export registry and constants
export * from './registry';
export * from './constants/roles';

// Export contexts
export { FeatureProvider, useFeatures } from './contexts/FeatureContext';

// Export hooks
export { useAccess } from './hooks';

// Export UI components
export {
  // Basic permission guards
  PermissionGuard,
  AnyPermissionGuard,
  AllPermissionsGuard,
  RoleGuard,
  AnyRoleGuard,
  
  // Permission hooks
  usePermission,
  useRole,
  
  // Backend verification components
  PermissionCheck,
  RoleCheck,
  AccessCheck,
  
  // Common role guards
  AdminGuard,
  ManagerGuard,
  ResourceGuard,
  
  // Feature control
  FeatureGuard
} from './ui';

// Export API
export {
  // Service
  rbacService,
  featureFlagService,
  
  // Query hooks
  useAccessProfile,
  useUserAccessProfile,
  useCheckPermissions,
  useCheckAccess,
  
  // Query keys
  rbacQueryKeys
} from './api';

// Export types
export type {
  AccessProfile,
  AccessCheckResult,
  PermissionCheckResponse,
  AccessCheckOptions,
  RoleCheckOptions,
  PermissionGuardProps,
  RoleGuardProps,
  AccessGuardProps,
  FeatureGuardProps,
  Feature
} from './types';

/**
 * Initialize the RBAC feature
 * This should be called at application startup
 */
export function initializeRbac() {
  // Initialize all registered features
  import('./registry').then(({ initializeFeatures }) => {
    initializeFeatures();
  });
  
  // Initialize the feature flag service
  import('./services/featureFlagService').then(({ featureFlagService }) => {
    featureFlagService.initialize();
  });
}
</file>

<file path="src/features/rbac/MIGRATION.md">
## Using Constants Instead of Strings

### Before

```tsx
<PermissionCheck permission="DELETE_USERS" verifyOnBackend={true}>
  <DeleteUserButton />
</PermissionCheck>

<AccessCheck 
  roles={['ADMIN']} 
  permissions={['MANAGE_SETTINGS']}
  requireAll={true}
  verifyOnBackend={true}
>
  <SystemSettings />
</AccessCheck>
```

### After

```tsx
import { Permission, Role } from '@/features/rbac';

<PermissionCheck permission={Permission.DELETE_USERS} verifyOnBackend={true}>
  <DeleteUserButton />
</PermissionCheck>

<AccessCheck 
  roles={[Role.ADMIN]} 
  permissions={[Permission.MANAGE_SETTINGS]}
  requireAll={true}
  verifyOnBackend={true}
>
  <SystemSettings />
</AccessCheck>
```

## Feature Guards

The new RBAC feature adds support for feature-level access control:

```tsx
import { FeatureGuard, Feature, Permission, Role } from '@/features/rbac';

// Basic feature guard (just checks if feature is enabled)
<FeatureGuard feature={Feature.EXAMS}>
  <ExamModule />
</FeatureGuard>

// Feature guard with permission requirements
<FeatureGuard 
  feature={Feature.LICENSING} 
  permissionsRequired={[Permission.VIEW_EXAMS, Permission.TAKE_EXAM]}
  requireAll={true}
>
  <LicensingModule />
</FeatureGuard>

// Feature guard with role requirements
<FeatureGuard 
  feature={Feature.ANALYTICS} 
  rolesRequired={[Role.ADMIN, Role.PHARMACY_MANAGER]}
  requireAll={false}
>
  <AnalyticsModule />
</FeatureGuard>
```# RBAC Migration Guide

This guide explains how to migrate from the old auth-based RBAC system to the new standalone RBAC feature.

## Overview

The RBAC (Role-Based Access Control) functionality has been extracted from the `auth` feature into its own standalone feature for better modularity and reusability. This guide will help you update your code to use the new RBAC feature.

## Import Changes

### Before

```tsx
import { PermissionGuard, RoleGuard, Permission, Role } from '@/features/auth';
```

### After

```tsx
import { PermissionGuard, RoleGuard, Permission, Role } from '@/features/rbac';
```

## Component Migration

### Permission Guards

#### Before

```tsx
import { PermissionGuard, Permission } from '@/features/auth';

<PermissionGuard permission={Permission.VIEW_EXAMS}>
  <ExamsList />
</PermissionGuard>
```

#### After

```tsx
import { PermissionGuard, Permission } from '@/features/rbac';

<PermissionGuard permission={Permission.VIEW_EXAMS}>
  <ExamsList />
</PermissionGuard>
```

### Role Guards

#### Before

```tsx
import { RoleGuard, Role } from '@/features/auth';

<RoleGuard role={Role.ADMIN}>
  <AdminPanel />
</RoleGuard>
```

#### After

```tsx
import { RoleGuard, Role } from '@/features/rbac';

<RoleGuard role={Role.ADMIN}>
  <AdminPanel />
</RoleGuard>
```

### Admin and Manager Guards

#### Before

```tsx
import { AdminGuard, ManagerGuard } from '@/features/auth/ui/rbac/RoleGuards';

<AdminGuard>
  <AdminDashboard />
</AdminGuard>

<ManagerGuard>
  <ManagerDashboard />
</ManagerGuard>
```

#### After

```tsx
import { AdminGuard, ManagerGuard } from '@/features/rbac';

<AdminGuard>
  <AdminDashboard />
</AdminGuard>

<ManagerGuard>
  <ManagerDashboard />
</ManagerGuard>
```

## Hook Migration

### Before

```tsx
import { useAuth } from '@/features/auth';

const MyComponent = () => {
  const { hasPermission, hasRole } = useAuth();
  
  if (hasPermission('EDIT_EXAM')) {
    // ...
  }
  
  if (hasRole('ADMIN')) {
    // ...
  }
};
```

### After

```tsx
import { useAccess } from '@/features/rbac';

const MyComponent = () => {
  const { hasPermission, hasRole } = useAccess();
  
  if (hasPermission('EDIT_EXAM')) {
    // ...
  }
  
  if (hasRole('ADMIN')) {
    // ...
  }
};
```

## Backend Verification

The new RBAC feature adds support for backend verification of permissions and roles. Here's how to use it:

```tsx
import { PermissionCheck, AccessCheck } from '@/features/rbac';

// Verify permission on the backend
<PermissionCheck permission="DELETE_USERS" verifyOnBackend={true}>
  <DeleteUserButton />
</PermissionCheck>

// Complex access check with backend verification
<AccessCheck 
  roles={['ADMIN']} 
  permissions={['MANAGE_SETTINGS']}
  requireAll={true}
  verifyOnBackend={true}
>
  <SystemSettings />
</AccessCheck>
```

## RequireAuth with RBAC

The `RequireAuth` component from the auth feature now supports RBAC parameters:

```tsx
import { RequireAuth } from '@/features/auth';

<RequireAuth
  requiredRoles={['ADMIN']}
  requiredPermissions={['MANAGE_SETTINGS']}
  requireAll={true}
>
  <ProtectedPage />
</RequireAuth>
```

## API Integration

The new RBAC feature includes TanStack Query hooks for data fetching:

```tsx
import { useAccessProfile, useCheckPermissions } from '@/features/rbac';

// Get current user's access profile
const { data: accessProfile } = useAccessProfile();

// Check specific permissions on the backend
const { data: permissionCheck } = useCheckPermissions([
  'EDIT_EXAM',
  'DELETE_EXAM'
]);
```

## Deprecation Timeline

The old RBAC components in the auth feature are now marked as deprecated and will be removed in a future version. Please migrate to the new RBAC feature as soon as possible.

## Need Help?

If you encounter any issues during migration, please refer to the [RBAC feature documentation](./README.md) or contact the development team.
</file>

<file path="src/features/rbac/README.md">
# Feature-Centric RBAC System

## Overview

This RBAC (Role-Based Access Control) system uses a feature-centric approach where each feature in the application defines its own permissions, feature flags, and role requirements. This makes the code more maintainable, portable, and clearer in showing which permissions and roles are needed for each feature.

## Architecture

### Core Components

1. **Feature Registry** - Centralized registry for features, permissions, and feature flags
2. **RBAC Registry** - Maps roles to permissions based on feature requirements
3. **Feature Flag Service** - Runtime management of feature flags
4. **Feature Context** - React context for easy access to feature status and permissions

### Directory Structure

```
src/
└── features/
    ├── auth/
    │   ├── constants/
    │   │   └── index.ts (auth-specific constants)
    │   └── ...
    ├── exams/
    │   ├── constants/
    │   │   └── index.ts (exam-specific constants)
    │   └── ...
    └── rbac/
        ├── constants/
        │   └── roles.ts (core roles definition)
        ├── contexts/
        │   └── FeatureContext.tsx (React context for features)
        ├── hooks/
        │   ├── useAccess.ts (permissions checking)
        │   └── useFeatureAccess.ts (feature access checking)
        ├── registry/
        │   ├── featureRegistry.ts (feature management)
        │   ├── rbacRegistry.ts (role-permission mapping)
        │   └── index.ts (registry exports)
        ├── services/
        │   └── featureFlagService.ts (runtime feature flags)
        ├── ui/
        │   └── FeatureGuard.tsx (component guards)
        └── index.ts (main exports)
```

## Usage

### Defining a Feature

Each feature in your application should define its permissions, feature flags, and role requirements:

```typescript
// src/features/myFeature/constants/index.ts
import { defineFeature } from '@/features/rbac/registry';
import { Role } from '@/features/rbac/constants/roles';
import { registerFeature } from '@/features/rbac/registry';

// Feature definition
export const MY_FEATURE = defineFeature(
  'myFeature',
  'My Feature',
  'Description of my feature'
);

// Feature-specific permissions
export enum MyFeaturePermission {
  VIEW = 'myFeature:view',
  EDIT = 'myFeature:edit',
  DELETE = 'myFeature:delete'
}

// Feature flags
export enum MyFeatureFlag {
  ADVANCED_MODE = 'myFeature:advanced-mode',
  BETA_FEATURES = 'myFeature:beta-features'
}

// Feature flag definitions
export const MY_FEATURE_FLAGS = {
  [MyFeatureFlag.ADVANCED_MODE]: {
    name: 'Advanced Mode',
    description: 'Enable advanced features',
    defaultEnabled: false
  },
  [MyFeatureFlag.BETA_FEATURES]: {
    name: 'Beta Features',
    description: 'Enable beta features',
    defaultEnabled: false
  }
};

// Roles that have access to this feature
export const MY_FEATURE_REQUIRED_ROLES = [
  Role.USER,
  Role.ADMIN
];

// Feature initializer
export function initializeMyFeature() {
  // Register this feature with the registry
  registerFeature(
    MY_FEATURE,
    MyFeaturePermission,
    MY_FEATURE_REQUIRED_ROLES,
    MyFeatureFlag,
    MY_FEATURE_FLAGS
  );
  
  console.log('My feature registered');
}
```

### Application Initialization

Initialize the RBAC system and register all features:

```typescript
// src/app/providers.tsx
import { FeatureProvider, initializeRbac } from '@/features/rbac';
import { initializeAuthFeature } from '@/features/auth/constants';
import { initializeExamsFeature } from '@/features/exams/constants';
import { initializeMyFeature } from '@/features/myFeature/constants';

// Initialize features
initializeAuthFeature();
initializeExamsFeature();
initializeMyFeature();

// Initialize RBAC system
initializeRbac();

export function Providers({ children }) {
  return (
    <FeatureProvider>
      {children}
    </FeatureProvider>
  );
}
```

### Using Feature Guards in Components

```tsx
import { FeatureGuard, FeatureFlagGuard } from '@/features/rbac/ui/FeatureGuard';
import { MyFeaturePermission, MyFeatureFlag } from '@/features/myFeature/constants';

function MyFeatureComponent() {
  return (
    <div>
      {/* Basic feature guard */}
      <FeatureGuard
        featureId="myFeature"
        fallback={<p>Feature not available</p>}
      >
        <div>My Feature Content</div>
      </FeatureGuard>
      
      {/* Guard with permission requirements */}
      <FeatureGuard
        featureId="myFeature"
        permissionsRequired={[MyFeaturePermission.EDIT]}
        fallback={<p>You don't have permission to edit</p>}
      >
        <EditButton />
      </FeatureGuard>
      
      {/* Specific feature flag guard */}
      <FeatureFlagGuard
        featureId="myFeature"
        flagId={MyFeatureFlag.ADVANCED_MODE}
        fallback={<p>Advanced mode is disabled</p>}
      >
        <AdvancedOptions />
      </FeatureFlagGuard>
    </div>
  );
}
```

### Using Hooks for Feature Access

```tsx
import { useFeatureAccess } from '@/features/rbac/hooks';
import { MyFeaturePermission } from '@/features/myFeature/constants';

function MyComponent() {
  const { 
    canAccess,
    isEnabled,
    hasPermissions,
    feature,
    isLoading
  } = useFeatureAccess('myFeature', {
    permissionsRequired: [MyFeaturePermission.VIEW],
    flagId: 'myFeature:advanced-mode'
  });
  
  if (isLoading) return <Loading />;
  
  if (!isEnabled) return <p>This feature is disabled</p>;
  
  if (!canAccess) return <p>You don't have access to this feature</p>;
  
  return (
    <div>
      <h1>{feature.name}</h1>
      <p>{feature.description}</p>
      {/* Feature content */}
    </div>
  );
}
```

### Feature Management UI

For admin interfaces, you can build UI components to manage feature flags:

```tsx
import { useFeatures } from '@/features/rbac';

function FeatureManagement() {
  const { 
    getAllFeatureInfo,
    isFeatureEnabled,
    enableFeature,
    disableFeature
  } = useFeatures();
  
  const features = getAllFeatureInfo();
  
  return (
    <div>
      <h1>Feature Management</h1>
      <table>
        <thead>
          <tr>
            <th>Feature</th>
            <th>Description</th>
            <th>Status</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {Object.entries(features).map(([id, feature]) => (
            <tr key={id}>
              <td>{feature.name}</td>
              <td>{feature.description}</td>
              <td>{isFeatureEnabled(id) ? 'Enabled' : 'Disabled'}</td>
              <td>
                <button 
                  onClick={() => isFeatureEnabled(id) 
                    ? disableFeature(id) 
                    : enableFeature(id)
                  }
                >
                  {isFeatureEnabled(id) ? 'Disable' : 'Enable'}
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
```

## Extending the System

### Adding New Roles

To add new roles, update the roles enum in `rbac/constants/roles.ts`:

```typescript
export enum Role {
  SUPER_ADMIN = 'SUPER_ADMIN',
  ADMIN = 'ADMIN',
  // Add new roles here
  MY_NEW_ROLE = 'MY_NEW_ROLE'
}
```

Also update the role hierarchy and metadata:

```typescript
export const ROLE_HIERARCHY: Record<Role, Role[]> = {
  // Add new role to hierarchy
  [Role.MY_NEW_ROLE]: [Role.USER]
}

export const ROLE_METADATA: Record<Role, { name: string; description: string }> = {
  // Add metadata for new role
  [Role.MY_NEW_ROLE]: {
    name: 'My New Role',
    description: 'Description of my new role'
  }
}
```

### Supporting Server-Side Feature Flags

To integrate with a server-side feature flag service, update the `loadFlagsFromApi` method in `featureFlagService.ts`:

```typescript
private async loadFlagsFromApi(): Promise<void> {
  try {
    const response = await fetch('/api/features/flags');
    const data = await response.json();
    
    // Update flags with server values
    this.flags = { ...this.flags, ...data };
  } catch (error) {
    console.error('Failed to load feature flags from API', error);
    throw error;
  }
}
```

## Benefits of This Approach

1. **Feature-Centric Organization**: Each feature owns its constants, permissions, and flags
2. **Self-Contained**: Features define all their requirements in one place
3. **Portability**: Easy to reuse features across projects
4. **Maintainability**: Clear visibility of which feature needs which permissions/roles
5. **Type Safety**: Strong TypeScript typing throughout
6. **Discoverability**: Easy to see what capabilities a feature has
7. **Namespacing**: Permissions are namespaced by feature (e.g., `exams:view`)
</file>

<file path="src/features/rbac/registry/featureRegistry.ts">
/**
 * Feature Registry
 * 
 * Centralized system for registering and managing application features,
 * their permissions, feature flags, and role requirements.
 * 
 * This is part of the RBAC feature for better portability.
 */

// Feature definition type
export interface Feature {
  id: string;
  name: string;
  description: string;
  permissions: Record<string, string>;
  requiredRoles: string[];
  defaultEnabled: boolean;
  featureFlags: Record<string, {
    id: string;
    name: string;
    description: string;
    defaultEnabled: boolean;
  }>;
}

// Global registry of all features
const featureRegistry: Record<string, Feature> = {};

// Global registry of all permissions by feature
const permissionRegistry: Record<string, Record<string, string>> = {};

/**
 * Define a new feature
 */
export function defineFeature(
  id: string, 
  name: string, 
  description: string, 
  defaultEnabled = true
): Feature {
  const feature: Feature = {
    id,
    name,
    description,
    permissions: {},
    requiredRoles: [],
    defaultEnabled,
    featureFlags: {}
  };
  
  featureRegistry[id] = feature;
  return feature;
}

/**
 * Define and register permissions for a feature
 */
export function definePermissions(featureId: string, permissionsEnum: Record<string, string>): void {
  if (!featureRegistry[featureId]) {
    throw new Error(`Feature ${featureId} not registered`);
  }
  
  // Register permissions
  permissionRegistry[featureId] = permissionsEnum;
  featureRegistry[featureId].permissions = { ...permissionsEnum };
}

/**
 * Register required roles for a feature
 */
export function defineRequiredRoles(featureId: string, roles: string[]): void {
  if (!featureRegistry[featureId]) {
    throw new Error(`Feature ${featureId} not registered`);
  }
  
  featureRegistry[featureId].requiredRoles = roles;
}

/**
 * Register feature flags for a feature
 */
export function defineFeatureFlags(
  featureId: string, 
  flagsEnum: Record<string, string>,
  defaults: Record<string, { name: string; description: string; defaultEnabled: boolean }>
): void {
  if (!featureRegistry[featureId]) {
    throw new Error(`Feature ${featureId} not registered`);
  }
  
  // Convert enum to feature flags registry
  Object.entries(flagsEnum).forEach(([key, value]) => {
    const flagDefaults = defaults[value] || { 
      name: key, 
      description: '', 
      defaultEnabled: true 
    };
    
    featureRegistry[featureId].featureFlags[value] = {
      id: value,
      name: flagDefaults.name,
      description: flagDefaults.description,
      defaultEnabled: flagDefaults.defaultEnabled
    };
  });
}

/**
 * Get all registered features
 */
export function getAllFeatures(): Record<string, Feature> {
  return { ...featureRegistry };
}

/**
 * Get a specific feature by ID
 */
export function getFeature(featureId: string): Feature | undefined {
  return featureRegistry[featureId];
}

/**
 * Get all permissions for a specific feature
 */
export function getFeaturePermissions(featureId: string): Record<string, string> {
  return permissionRegistry[featureId] || {};
}

/**
 * Get all permissions from all features
 */
export function getAllPermissions(): Record<string, Record<string, string>> {
  return { ...permissionRegistry };
}

/**
 * Get feature by permission
 */
export function getFeatureByPermission(permission: string): Feature | undefined {
  const featureId = permission.split(':')[0];
  return featureRegistry[featureId];
}

/**
 * Helper to extract all permission values as a flat array
 */
export function getAllPermissionValues(): string[] {
  return Object.values(permissionRegistry).flatMap(permSet => Object.values(permSet));
}

/**
 * Check if a feature is registered
 */
export function isFeatureRegistered(featureId: string): boolean {
  return !!featureRegistry[featureId];
}

/**
 * Get all feature flags for a specific feature
 */
export function getFeatureFlags(featureId: string): Record<string, {
  id: string;
  name: string;
  description: string;
  defaultEnabled: boolean;
}> {
  return featureRegistry[featureId]?.featureFlags || {};
}

/**
 * Clear all registered features - useful for testing
 */
export function clearRegistry(): void {
  Object.keys(featureRegistry).forEach(key => delete featureRegistry[key]);
  Object.keys(permissionRegistry).forEach(key => delete permissionRegistry[key]);
}
</file>

<file path="src/features/rbac/registry/index.ts">
/**
 * Feature Initializer
 * 
 * This module collects and registers all features, their permissions,
 * feature flags, and role requirements in the central registry.
 * 
 * Placing this in the RBAC feature ensures better portability and
 * cohesion with the access control system.
 */
import { 
  definePermissions, 
  defineRequiredRoles, 
  defineFeatureFlags,
  getAllFeatures,
  clearRegistry
} from './featureRegistry';

import { initializeRbacRegistry } from './rbacRegistry';

// Flag to track initialization status
let initialized = false;

// Registry for features to initialize
const featuresToInitialize: Array<{
  feature: any;
  permissions: any;
  roles: string[];
  featureFlags: any;
  flagDefaults: any;
}> = [];

/**
 * Register a feature for initialization
 * This should be called by each feature's module
 */
export function registerFeature(
  feature: any, 
  permissions: any, 
  roles: string[],
  featureFlags: any,
  flagDefaults: any
) {
  featuresToInitialize.push({
    feature,
    permissions,
    roles,
    featureFlags,
    flagDefaults
  });
  
  // If already initialized, update the registry
  if (initialized) {
    addFeatureToRegistry(
      feature,
      permissions,
      roles,
      featureFlags,
      flagDefaults
    );
    
    // Reinitialize RBAC registry to include new feature
    initializeRbacRegistry();
  }
}

/**
 * Add a single feature to the registry
 */
function addFeatureToRegistry(
  feature: any,
  permissions: any,
  roles: string[],
  featureFlags: any,
  flagDefaults: any
) {
  // Register permissions for the feature
  definePermissions(feature.id, permissions);
  
  // Register required roles for the feature
  defineRequiredRoles(feature.id, roles);
  
  // Register feature flags for the feature
  defineFeatureFlags(feature.id, featureFlags, flagDefaults);
}

/**
 * Initialize all registered features
 */
export function initializeFeatures() {
  if (initialized) {
    console.warn('Features already initialized, skipping');
    return;
  }
  
  // Process all registered features
  featuresToInitialize.forEach(({ feature, permissions, roles, featureFlags, flagDefaults }) => {
    addFeatureToRegistry(feature, permissions, roles, featureFlags, flagDefaults);
  });
  
  // Initialize the RBAC registry with the registered features
  initializeRbacRegistry();
  
  // Log all registered features
  console.log('Registered features:', Object.keys(getAllFeatures()));
  
  initialized = true;
}

/**
 * Check if features have been initialized
 */
export function areFeaturesInitialized(): boolean {
  return initialized;
}

/**
 * Reset and reinitialize all features
 * Useful for testing or when feature flags change at runtime
 */
export function reinitializeFeatures() {
  initialized = false;
  clearRegistry();
  initializeFeatures();
}

// Create a registry index to export all registry functionality
export * from './featureRegistry';
export * from './rbacRegistry';
</file>

<file path="src/features/rbac/registry/rbacRegistry.ts">
/**
 * RBAC Registry
 * 
 * Central registry for Role-Based Access Control that integrates with feature-specific permissions.
 * This module maps roles to permissions based on feature requirements.
 */

import { Role, ROLE_HIERARCHY } from '../constants/roles';
import { 
  getAllPermissions, 
  getAllFeatures, 
  getAllPermissionValues 
} from './featureRegistry';

// Maps roles to their granted permissions
// This is populated by the initializeRbacRegistry function
let ROLE_PERMISSIONS: Record<Role, string[]> = {
  [Role.SUPER_ADMIN]: [], // Will be populated with all permissions
  [Role.ADMIN]: [],
  [Role.PHARMACIST]: [],
  [Role.PHARMACY_MANAGER]: [],
  [Role.TECHNICIAN]: [],
  [Role.PROPRIETOR]: [],
  [Role.USER]: []
};

/**
 * Initialize the RBAC registry by collecting permissions from all features
 */
export function initializeRbacRegistry(): Record<Role, string[]> {
  const allPermissions = getAllPermissions();
  const allFeatures = getAllFeatures();
  
  // Reset the permissions map
  ROLE_PERMISSIONS = {
    [Role.SUPER_ADMIN]: [],
    [Role.ADMIN]: [],
    [Role.PHARMACIST]: [],
    [Role.PHARMACY_MANAGER]: [],
    [Role.TECHNICIAN]: [],
    [Role.PROPRIETOR]: [],
    [Role.USER]: []
  };
  
  // Populate Super Admin with all permissions
  ROLE_PERMISSIONS[Role.SUPER_ADMIN] = getAllPermissionValues();
  
  // For each feature, assign permissions based on required roles
  Object.values(allFeatures).forEach(feature => {
    const featurePermissions = Object.values(feature.permissions);
    
    // Assign feature permissions to each role that requires them
    feature.requiredRoles.forEach(roleId => {
      if (Object.values(Role).includes(roleId as Role)) {
        const role = roleId as Role;
        
        // Add all permissions for this feature to the role
        ROLE_PERMISSIONS[role] = [
          ...ROLE_PERMISSIONS[role],
          ...featurePermissions
        ];
      }
    });
  });
  
  // Apply role hierarchy - roles inherit permissions from roles below them
  Object.entries(ROLE_HIERARCHY).forEach(([roleKey, inheritedRoles]) => {
    const role = roleKey as Role;
    inheritedRoles.forEach(inheritedRole => {
      ROLE_PERMISSIONS[role] = [
        ...ROLE_PERMISSIONS[role],
        ...ROLE_PERMISSIONS[inheritedRole]
      ];
    });
  });
  
  // Deduplicate permissions
  Object.keys(ROLE_PERMISSIONS).forEach(role => {
    ROLE_PERMISSIONS[role as Role] = [...new Set(ROLE_PERMISSIONS[role as Role])];
  });
  
  return ROLE_PERMISSIONS;
}

/**
 * Get all permissions for a role
 */
export function getPermissionsForRole(role: Role): string[] {
  return ROLE_PERMISSIONS[role] || [];
}

/**
 * Check if a role has a specific permission
 */
export function roleHasPermission(role: Role, permission: string): boolean {
  return ROLE_PERMISSIONS[role]?.includes(permission) || false;
}

/**
 * Get all roles that have a specific permission
 */
export function getRolesWithPermission(permission: string): Role[] {
  return Object.entries(ROLE_PERMISSIONS)
    .filter(([_, permissions]) => permissions.includes(permission))
    .map(([role, _]) => role as Role);
}

/**
 * Reset and update the RBAC registry
 * This should be called whenever features or permissions are updated
 */
export function updateRbacRegistry(): void {
  initializeRbacRegistry();
}
</file>

<file path="src/features/rbac/services/featureFlagService.ts">
/**
 * Feature Flag Service
 * 
 * Service for managing feature flags at runtime.
 * Handles loading, saving, and checking feature flag states.
 */
import { getAllFeatures, getFeatureFlags } from '@/features/rbac/registry/featureRegistry';

// Type for feature flag state
type FeatureFlagMap = Record<string, boolean>;

/**
 * Service for managing feature flags at runtime
 */
export class FeatureFlagService {
  private flags: FeatureFlagMap = {};
  private initializing: Promise<void> | null = null;
  
  /**
   * Initialize feature flags from sources (local storage, API, etc.)
   */
  public async initialize(): Promise<void> {
    if (this.initializing) return this.initializing;
    
    this.initializing = (async () => {
      try {
        // First try loading from API
        await this.loadFlagsFromApi();
      } catch (error) {
        console.warn('Failed to load feature flags from API, using defaults or local storage');
        
        // Fall back to local storage or default
        this.loadFlagsFromLocalStorage();
      }
      
      // Ensure we have defaults for all registered features
      this.initializeDefaultFlags();
    })();
    
    return this.initializing;
  }
  
  /**
   * Check if a feature is enabled
   */
  public isEnabled(featureId: string, flagId?: string): boolean {
    // If checking a specific flag within a feature
    if (flagId) {
      const key = `${featureId}:${flagId}`;
      return this.flags[key] ?? false;
    }
    
    // If checking the entire feature
    return this.flags[featureId] ?? false;
  }
  
  /**
   * Enable a feature or a specific flag
   */
  public enableFeature(featureId: string, flagId?: string): void {
    if (flagId) {
      const key = `${featureId}:${flagId}`;
      this.flags[key] = true;
    } else {
      this.flags[featureId] = true;
    }
    this.saveToLocalStorage();
  }
  
  /**
   * Disable a feature or a specific flag
   */
  public disableFeature(featureId: string, flagId?: string): void {
    if (flagId) {
      const key = `${featureId}:${flagId}`;
      this.flags[key] = false;
    } else {
      this.flags[featureId] = false;
    }
    this.saveToLocalStorage();
  }
  
  /**
   * Get all feature flags
   */
  public getAllFlags(): FeatureFlagMap {
    return { ...this.flags };
  }
  
  /**
   * Get all flags for a specific feature
   */
  public getFeatureFlags(featureId: string): Record<string, boolean> {
    const result: Record<string, boolean> = {};
    const prefix = `${featureId}:`;
    
    // Get the feature-level flag
    result[featureId] = this.flags[featureId] ?? false;
    
    // Get all flags that belong to this feature
    Object.keys(this.flags)
      .filter(key => key.startsWith(prefix))
      .forEach(key => {
        result[key] = this.flags[key];
      });
      
    return result;
  }
  
  /**
   * Load feature flags from API
   */
  private async loadFlagsFromApi(): Promise<void> {
    // Implement API call to fetch feature flags
    // Example:
    // const response = await apiClient.get<FeatureFlagMap>('/api/features/flags');
    // this.flags = { ...this.flags, ...response.data };
    
    // For now, just throw to fall back to local storage
    throw new Error('API not implemented');
  }
  
  /**
   * Load feature flags from local storage
   */
  private loadFlagsFromLocalStorage(): void {
    if (typeof window === 'undefined') return;
    
    const savedFlags = localStorage.getItem('feature-flags');
    if (savedFlags) {
      try {
        const parsedFlags = JSON.parse(savedFlags) as FeatureFlagMap;
        this.flags = { ...this.flags, ...parsedFlags };
      } catch (error) {
        console.error('Failed to parse saved feature flags', error);
      }
    }
  }
  
  /**
   * Save current flags to local storage
   */
  private saveToLocalStorage(): void {
    if (typeof window === 'undefined') return;
    
    try {
      localStorage.setItem('feature-flags', JSON.stringify(this.flags));
    } catch (error) {
      console.error('Failed to save feature flags', error);
    }
  }
  
  /**
   * Initialize default flag values for all registered features
   */
  private initializeDefaultFlags(): void {
    // Get all features
    const features = getAllFeatures();
    
    // Initialize feature-level flags
    Object.keys(features).forEach(featureId => {
      // Set the feature-level flag if not already set
      if (this.flags[featureId] === undefined) {
        this.flags[featureId] = features[featureId].defaultEnabled;
      }
      
      // Get all feature flags for this feature
      const featureFlags = getFeatureFlags(featureId);
      
      // Set individual flags if not already set
      Object.keys(featureFlags).forEach(flagId => {
        const key = `${featureId}:${flagId}`;
        if (this.flags[key] === undefined) {
          this.flags[key] = featureFlags[flagId].defaultEnabled;
        }
      });
    });
    
    // Save to local storage
    this.saveToLocalStorage();
  }
}

// Create a singleton instance
export const featureFlagService = new FeatureFlagService();
</file>

<file path="src/features/rbac/types/index.ts">
/**
 * RBAC Types
 * Core types for the Role-Based Access Control system
 */

/**
 * Represents a feature in the application
 */
export interface Feature {
  id: string;
  name: string;
  description: string;
  permissions: Record<string, string>;
  requiredRoles: string[];
  defaultEnabled: boolean;
  featureFlags: Record<string, {
    id: string;
    name: string;
    description: string;
    defaultEnabled: boolean;
  }>;
}

/**
 * Represents a user's access profile including roles and permissions
 */
export interface AccessProfile {
  userId: string;
  roles: string[];
  permissions: string[];
}

/**
 * Result of an access check operation
 */
export interface AccessCheckResult {
  granted: boolean;
  reason?: string;
}

/**
 * Permission check response from the backend
 */
export interface PermissionCheckResponse {
  [permission: string]: boolean;
}

/**
 * Access check options
 */
export interface AccessCheckOptions {
  requireAll?: boolean;
  verifyOnBackend?: boolean;
}

/**
 * Role check options
 */
export interface RoleCheckOptions {
  verifyOnBackend?: boolean;
}

/**
 * Component props for permission-based checks
 */
export interface PermissionGuardProps {
  permission: string;
  fallback?: React.ReactNode;
  children: React.ReactNode;
  verifyOnBackend?: boolean;
}

/**
 * Component props for role-based checks
 */
export interface RoleGuardProps {
  role: string;
  fallback?: React.ReactNode;
  children: React.ReactNode;
  verifyOnBackend?: boolean;
}

/**
 * Component props for complex access checks
 */
export interface AccessGuardProps {
  roles?: string[];
  permissions?: string[];
  requireAll?: boolean;
  fallback?: React.ReactNode;
  children: React.ReactNode;
  verifyOnBackend?: boolean;
}

/**
 * Component props for feature/resource access guards
 */
export interface FeatureGuardProps {
  permissions: string[];
  fallback?: React.ReactNode;
  children: React.ReactNode;
  verifyOnBackend?: boolean;
}
</file>

<file path="src/features/rbac/ui/FeatureGuard.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { useAuth } from '@/features/auth';
import { featureFlagService } from '../services/featureFlagService';
import { getFeature, getFeaturePermissions } from '../registry';
import { rbacService } from '../api/services/rbacService';
import { useAccess } from '../hooks/useAccess';

interface FeatureGuardProps {
  featureId: string;
  children: React.ReactNode;
  fallback?: React.ReactNode;
  permissionsRequired?: string[];
  rolesRequired?: string[];
  requireAll?: boolean;
  verifyOnBackend?: boolean;
  flagId?: string;
}

/**
 * Guard component to restrict access to specific features
 * Features can be restricted based on permissions, roles, or feature flags
 */
export function FeatureGuard({ 
  featureId, 
  children, 
  fallback = null,
  permissionsRequired = [],
  rolesRequired = [],
  requireAll = true,
  verifyOnBackend = false,
  flagId
}: FeatureGuardProps) {
  const [hasAccess, setHasAccess] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const { hasAccess: checkClientAccess } = useAccess();
  const { user } = useAuth();
  
  useEffect(() => {
    const checkFeatureAccess = async () => {
      // First check if the feature exists
      const feature = getFeature(featureId);
      if (!feature) {
        console.warn(`Feature ${featureId} is not registered`);
        setHasAccess(false);
        setIsLoading(false);
        return;
      }
      
      // Check if the feature is enabled at all
      let featureEnabled = featureFlagService.isEnabled(featureId, flagId);
      if (!featureEnabled) {
        setHasAccess(false);
        setIsLoading(false);
        return;
      }
      
      // If no additional access checks are required, grant access
      if (permissionsRequired.length === 0 && rolesRequired.length === 0) {
        setHasAccess(true);
        setIsLoading(false);
        return;
      }
      
      // Handle server-side verification if needed
      if (verifyOnBackend) {
        try {
          const result = await rbacService.checkAccess(
            rolesRequired, 
            permissionsRequired, 
            requireAll
          );
          setHasAccess(result.data || false);
        } catch (error) {
          console.error('Failed to check feature access', error);
          setHasAccess(false);
        } finally {
          setIsLoading(false);
        }
        return;
      }
      
      // Client-side access check for permissions and roles
      const accessGranted = checkClientAccess(
        rolesRequired, 
        permissionsRequired, 
        { requireAll }
      );
      
      setHasAccess(accessGranted);
      setIsLoading(false);
    };
    
    checkFeatureAccess();
  }, [featureId, flagId, permissionsRequired, rolesRequired, requireAll, verifyOnBackend, checkClientAccess, user]);
  
  if (isLoading) return null;
  
  return hasAccess ? <>{children}</> : <>{fallback}</>;
}

/**
 * Specialized guard for feature flags
 */
export function FeatureFlagGuard({ 
  featureId, 
  flagId, 
  children, 
  fallback = null 
}: { 
  featureId: string;
  flagId: string;
  children: React.ReactNode;
  fallback?: React.ReactNode;
}) {
  const [isEnabled, setIsEnabled] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  
  useEffect(() => {
    // Check if the specific feature flag is enabled
    const flagEnabled = featureFlagService.isEnabled(featureId, flagId);
    setIsEnabled(flagEnabled);
    setIsLoading(false);
  }, [featureId, flagId]);
  
  if (isLoading) return null;
  
  return isEnabled ? <>{children}</> : <>{fallback}</>;
}
</file>

<file path="src/features/rbac/ui/index.ts">
/**
 * RBAC UI Components
 */

// Export permission and role guard components
export {
  PermissionGuard,
  AnyPermissionGuard,
  AllPermissionsGuard,
  RoleGuard,
  AnyRoleGuard,
  usePermission,
  useRole
} from './PermissionGuard';

// Export permission check components with backend verification
export {
  PermissionCheck,
  RoleCheck,
  AccessCheck
} from './PermissionCheck';

// Export common role-based guards
export {
  AdminGuard,
  ManagerGuard,
  FeatureGuard as ResourceGuard // Renamed to avoid conflict
} from './RoleGuards';

// Export feature guard
export { FeatureGuard } from './FeatureGuard';
</file>

<file path="src/features/rbac/ui/PermissionCheck.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { useAuth } from '@/features/auth';
import { rbacService } from '../api/services/rbacService';
import { useAccess } from '../hooks/useAccess';

interface PermissionCheckProps {
  permission: string;
  children: React.ReactNode;
  fallback?: React.ReactNode;
  verifyOnBackend?: boolean;
}

/**
 * Component to conditionally render content based on user permissions
 * Can verify permissions on the backend for critical operations
 */
export function PermissionCheck({ 
  permission, 
  children, 
  fallback = null,
  verifyOnBackend = false
}: PermissionCheckProps) {
  const [hasPermission, setHasPermission] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const { hasPermission: checkClientPermission } = useAccess();
  
  useEffect(() => {
    const checkPermission = async () => {
      if (verifyOnBackend) {
        try {
          const result = await rbacService.checkPermissions([permission]);
          setHasPermission(result.data?.[permission] || false);
        } catch (error) {
          console.error(`Failed to check permission: ${permission}`, error);
          setHasPermission(false);
        } finally {
          setIsLoading(false);
        }
      } else {
        // Use client-side permission check
        setHasPermission(checkClientPermission(permission));
        setIsLoading(false);
      }
    };
    
    checkPermission();
  }, [permission, verifyOnBackend, checkClientPermission]);
  
  if (isLoading) return null;
  
  return hasPermission ? <>{children}</> : <>{fallback}</>;
}

interface RoleCheckProps {
  role: string;
  children: React.ReactNode;
  fallback?: React.ReactNode;
  verifyOnBackend?: boolean;
}

/**
 * Component to conditionally render content based on user roles
 * Can verify roles on the backend for critical operations
 */
export function RoleCheck({ 
  role, 
  children, 
  fallback = null,
  verifyOnBackend = false
}: RoleCheckProps) {
  const [hasRole, setHasRole] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const { hasRole: checkClientRole } = useAccess();
  
  useEffect(() => {
    const checkRole = async () => {
      if (verifyOnBackend) {
        try {
          const result = await rbacService.checkAccess([role], [], false);
          setHasRole(result.data || false);
        } catch (error) {
          console.error(`Failed to check role: ${role}`, error);
          setHasRole(false);
        } finally {
          setIsLoading(false);
        }
      } else {
        // Use client-side role check
        setHasRole(checkClientRole(role));
        setIsLoading(false);
      }
    };
    
    checkRole();
  }, [role, verifyOnBackend, checkClientRole]);
  
  if (isLoading) return null;
  
  return hasRole ? <>{children}</> : <>{fallback}</>;
}

interface AccessCheckProps {
  roles?: string[];
  permissions?: string[];
  requireAll?: boolean;
  children: React.ReactNode;
  fallback?: React.ReactNode;
  verifyOnBackend?: boolean;
}

/**
 * Component to conditionally render content based on complex access rules
 * Supports checking multiple roles and permissions
 */
export function AccessCheck({ 
  roles = [], 
  permissions = [], 
  requireAll = true,
  children, 
  fallback = null,
  verifyOnBackend = false
}: AccessCheckProps) {
  const [hasAccess, setHasAccess] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const { hasAccess: checkClientAccess } = useAccess();
  
  useEffect(() => {
    const checkAccess = async () => {
      if (verifyOnBackend) {
        try {
          const result = await rbacService.checkAccess(roles, permissions, requireAll);
          setHasAccess(result.data || false);
        } catch (error) {
          console.error('Failed to check access', error);
          setHasAccess(false);
        } finally {
          setIsLoading(false);
        }
      } else {
        // Use client-side access check
        setHasAccess(checkClientAccess(roles, permissions, { requireAll }));
        setIsLoading(false);
      }
    };
    
    checkAccess();
  }, [roles, permissions, requireAll, verifyOnBackend, checkClientAccess]);
  
  if (isLoading) return null;
  
  return hasAccess ? <>{children}</> : <>{fallback}</>;
}
</file>

<file path="src/features/rbac/ui/PermissionGuard.tsx">
'use client';

/**
 * Permission-based access control components
 */
import { useEffect, useState } from 'react';
import { useAuth } from '@/features/auth';
import { Permission, Role } from '../constants/permissions';

// Component that renders children only if user has the required permission
export const PermissionGuard: React.FC<{
  permission: Permission;
  fallback?: React.ReactNode;
  children: React.ReactNode;
}> = ({ permission, fallback = null, children }) => {
  const { user } = useAuth();
  const [canAccess, setCanAccess] = useState<boolean>(false);
  
  useEffect(() => {
    // Check if user has the required permission
    if (user && user.permissions) {
      setCanAccess(user.permissions.includes(permission));
    } else {
      setCanAccess(false);
    }
  }, [user, permission]);
  
  return canAccess ? <>{children}</> : <>{fallback}</>;
};

// Component that renders children only if user has any of the required permissions
export const AnyPermissionGuard: React.FC<{
  permissions: Permission[];
  fallback?: React.ReactNode;
  children: React.ReactNode;
}> = ({ permissions, fallback = null, children }) => {
  const { user } = useAuth();
  const [canAccess, setCanAccess] = useState<boolean>(false);
  
  useEffect(() => {
    // Check if user has any of the required permissions
    if (user && user.permissions && permissions.length > 0) {
      setCanAccess(permissions.some(permission => user.permissions.includes(permission)));
    } else {
      setCanAccess(false);
    }
  }, [user, permissions]);
  
  return canAccess ? <>{children}</> : <>{fallback}</>;
};

// Component that renders children only if user has all of the required permissions
export const AllPermissionsGuard: React.FC<{
  permissions: Permission[];
  fallback?: React.ReactNode;
  children: React.ReactNode;
}> = ({ permissions, fallback = null, children }) => {
  const { user } = useAuth();
  const [canAccess, setCanAccess] = useState<boolean>(false);
  
  useEffect(() => {
    // Check if user has all of the required permissions
    if (user && user.permissions && permissions.length > 0) {
      setCanAccess(permissions.every(permission => user.permissions.includes(permission)));
    } else {
      setCanAccess(false);
    }
  }, [user, permissions]);
  
  return canAccess ? <>{children}</> : <>{fallback}</>;
};

// Component that renders children only if user has the required role
export const RoleGuard: React.FC<{
  role: Role;
  fallback?: React.ReactNode;
  children: React.ReactNode;
}> = ({ role, fallback = null, children }) => {
  const { user } = useAuth();
  const [canAccess, setCanAccess] = useState<boolean>(false);
  
  useEffect(() => {
    // Check if user has the required role
    if (user && user.roles) {
      setCanAccess(user.roles.includes(role));
    } else {
      setCanAccess(false);
    }
  }, [user, role]);
  
  return canAccess ? <>{children}</> : <>{fallback}</>;
};

// Component that renders children only if user has any of the required roles
export const AnyRoleGuard: React.FC<{
  roles: Role[];
  fallback?: React.ReactNode;
  children: React.ReactNode;
}> = ({ roles, fallback = null, children }) => {
  const { user } = useAuth();
  const [canAccess, setCanAccess] = useState<boolean>(false);
  
  useEffect(() => {
    // Check if user has any of the required roles
    if (user && user.roles && roles.length > 0) {
      setCanAccess(roles.some(role => user.roles.includes(role)));
    } else {
      setCanAccess(false);
    }
  }, [user, roles]);
  
  return canAccess ? <>{children}</> : <>{fallback}</>;
};

// Custom hook for permission checking
export const usePermission = (permission: Permission) => {
  const { user } = useAuth();
  const [canAccess, setCanAccess] = useState<boolean>(false);
  
  useEffect(() => {
    // Check if user has the required permission
    if (user && user.permissions) {
      setCanAccess(user.permissions.includes(permission));
    } else {
      setCanAccess(false);
    }
  }, [user, permission]);
  
  return { canAccess };
};

// Custom hook for role checking
export const useRole = (role: Role) => {
  const { user } = useAuth();
  const [canAccess, setCanAccess] = useState<boolean>(false);
  
  useEffect(() => {
    // Check if user has the required role
    if (user && user.roles) {
      setCanAccess(user.roles.includes(role));
    } else {
      setCanAccess(false);
    }
  }, [user, role]);
  
  return { canAccess };
};
</file>

<file path="src/features/rbac/ui/RoleGuards.tsx">
"use client";

import React from 'react';
import { AccessCheck } from './PermissionCheck';
import { Role, Permission } from '../constants/permissions';

interface GuardProps {
  children: React.ReactNode;
  fallback?: React.ReactNode;
  verifyOnBackend?: boolean;
}

interface FeatureGuardProps {
  children: React.ReactNode;
  permissions: Permission[];
  fallback?: React.ReactNode;
  verifyOnBackend?: boolean;
}

/**
 * Guard that only allows access to admin users
 */
export function AdminGuard({ children, fallback, verifyOnBackend }: GuardProps) {
  return (
    <AccessCheck 
      roles={[Role.ADMIN, 'SUPER_ADMIN']}
      requireAll={false}
      verifyOnBackend={verifyOnBackend}
      fallback={fallback}
    >
      {children}
    </AccessCheck>
  );
}

/**
 * Guard that only allows access to manager-level users (includes admins)
 */
export function ManagerGuard({ children, fallback, verifyOnBackend }: GuardProps) {
  return (
    <AccessCheck 
      roles={[Role.PHARMACY_MANAGER, Role.ADMIN, 'SUPER_ADMIN']}
      requireAll={false}
      verifyOnBackend={verifyOnBackend}
      fallback={fallback}
    >
      {children}
    </AccessCheck>
  );
}

/**
 * Guard that restricts access based on specific feature permissions
 */
export function FeatureGuard({ children, permissions, fallback, verifyOnBackend }: FeatureGuardProps) {
  return (
    <AccessCheck
      permissions={permissions}
      requireAll={true}
      verifyOnBackend={verifyOnBackend}
      fallback={fallback}
    >
      {children}
    </AccessCheck>
  );
}
</file>

<file path="src/features/shared/config/menuItems.ts">
/**
 * Menu Items Configuration
 */

import { MenuItem } from '@/features/shared/types';
import { 
  Home, 
  Settings,
  Users, 
  Package, 
  FileText, 
  GraduationCap,
  Handshake,
  Phone,
  BarChart
} from 'lucide-react';

/**
 * Main menu items configuration
 */
export const menuItems: MenuItem[] = [
  { 
    id: 'dashboard',
    label: 'Dashboard', 
    href: '/dashboard', 
    icon: Home,
    requiresAuthentication: true
  },
  { 
    id: 'exam',
    label: 'Exam Practice', 
    href: '/exam', 
    icon: GraduationCap,
    roles: ['USER', 'STUDENT']
  },
  { 
    id: 'licensing',
    label: 'Licensing', 
    href: '/licensing', 
    icon: Handshake,
    roles: ['ADMIN', 'MANAGER'],
    subItems: [
      { 
        id: 'pharmacists',
        label: 'Pharmacists', 
        href: '/licensing/pharmacist', 
        icon: Users,
        permissions: ['manage_pharmacists']
      },
      { 
        id: 'pharmacy-managers',
        label: 'Pharmacy Managers', 
        href: '/licensing/pharmacy-manager', 
        icon: Phone,
        permissions: ['manage_pharmacy_managers']
      },
      { 
        id: 'proprietors',
        label: 'Proprietors', 
        href: '/licensing/proprietor', 
        icon: Handshake,
        permissions: ['manage_proprietors']
      },
      { 
        id: 'salesmen',
        label: 'Salesmen', 
        href: '/licensing/salesman', 
        icon: Phone,
        permissions: ['manage_salesmen']
      }
    ]
  },
  { 
    id: 'inventory',
    label: 'Inventory', 
    href: '/dashboard/inventory', 
    icon: Package,
    permissions: ['manage_inventory', 'view_products']
  },
  { 
    id: 'reports',
    label: 'Reports', 
    href: '/dashboard/reports', 
    icon: FileText,
    permissions: ['view_reports']
  },
  { 
    id: 'analytics',
    label: 'Analytics', 
    href: '/dashboard/analytics', 
    icon: BarChart,
    roles: ['ADMIN', 'MANAGER'],
    permissions: ['view_analytics']
  },
  { 
    id: 'settings',
    label: 'Settings', 
    href: '/dashboard/settings', 
    icon: Settings,
    roles: ['ADMIN', 'SUPER_ADMIN', 'MANAGER']
  },
];

/**
 * Admin-specific menu items
 */
export const adminMenuItems: MenuItem[] = [
  { 
    id: 'admin-dashboard',
    label: 'Admin Dashboard', 
    href: '/admin', 
    icon: Home,
    roles: ['ADMIN', 'SUPER_ADMIN'],
  },
  { 
    id: 'admin-users',
    label: 'User Management', 
    href: '/admin/users', 
    icon: Users,
    roles: ['ADMIN', 'SUPER_ADMIN'],
    permissions: ['manage_users']
  },
  { 
    id: 'admin-permissions',
    label: 'Permissions & Roles', 
    href: '/admin/permissions', 
    icon: FileText,
    roles: ['SUPER_ADMIN'],
    permissions: ['manage_permissions', 'manage_roles']
  },
];

/**
 * Mobile menu items (simplified for mobile views)
 */
export const mobileMenuItems: MenuItem[] = menuItems.map(item => ({
  ...item,
  subItems: item.subItems ? item.subItems.slice(0, 3) : undefined // Limit deep nesting on mobile
}));

export default menuItems;
</file>

<file path="src/features/shared/types/index.ts">
/**
 * Shared Types
 */

import { LucideIcon } from 'lucide-react';
import { Permission, Role } from '@/features/auth/types';

/**
 * MenuItem interface for navigation components
 */
export interface MenuItem {
  id: string;
  label: string;
  href: string;
  icon?: LucideIcon | React.ComponentType<{ className?: string }>;
  permissions?: Permission[];
  roles?: Role[];
  subItems?: MenuItem[];
  isActive?: boolean;
  isExternal?: boolean;
  requiresAuthentication?: boolean;
  badgeText?: string | number;
  badgeVariant?: 'default' | 'success' | 'warning' | 'danger';
  dividerBefore?: boolean;
  dividerAfter?: boolean;
  onClick?: () => void;
  tooltip?: string;
}

/**
 * Function interfaces
 */
export interface GenericCallback<T = void> {
  (): T;
}

export interface GenericAsyncCallback<T = void> {
  (): Promise<T>;
}

/**
 * Pagination interface for API responses
 */
export interface PaginationParams {
  page: number;
  limit: number;
  total?: number;
  hasMore?: boolean;
}

/**
 * Common response formats
 */
export interface ApiResponse<T> {
  data: T;
  message?: string;
  status: number;
  success: boolean;
  pagination?: PaginationParams;
  timestamp?: string;
}

/**
 * Error response format
 */
export interface ApiError {
  message: string;
  code?: string;
  status: number;
  details?: Record<string, any>;
  timestamp?: string;
}

/**
 * Config options for API requests
 */
export interface ApiRequestConfig {
  baseURL?: string;
  timeout?: number;
  headers?: Record<string, string>;
  params?: Record<string, any>;
  withCredentials?: boolean;
}

/**
 * Generic filter interface
 */
export interface Filter {
  field: string;
  operator: 'eq' | 'neq' | 'gt' | 'gte' | 'lt' | 'lte' | 'contains' | 'in' | 'between';
  value: any;
}

/**
 * Generic sort interface
 */
export interface SortOption {
  field: string;
  direction: 'asc' | 'desc';
}

/**
 * Query parameters interface
 */
export interface QueryParams {
  filters?: Filter[];
  sort?: SortOption[];
  pagination?: Partial<PaginationParams>;
  search?: string;
  includes?: string[];
  fields?: string[];
}
</file>

<file path="src/features/tanstack-query-api/components/QueryProvider.tsx">
'use client';

/**
 * TanStack Query Provider
 * 
 * This component sets up the TanStack Query context with our
 * pre-configured query client.
 */
import { QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { useState } from 'react';
import { queryClient } from '../core/queryClient';
import type { PropsWithChildren } from 'react';

interface QueryProviderProps {
  /**
   * Whether to show the TanStack Query DevTools
   * (only works in development mode)
   */
  showDevtools?: boolean;
}

/**
 * TanStack Query Provider component
 * 
 * Wraps your application with the TanStack Query context
 * using our pre-configured query client.
 * 
 * @example
 * ```tsx
 * // In your app layout or root component:
 * import { QueryProvider } from '@/features/tanstack-query-api';
 * 
 * function App() {
 *   return (
 *     <QueryProvider>
 *       <YourApp />
 *     </QueryProvider>
 *   );
 * }
 * ```
 */
export function QueryProvider({ 
  children, 
  showDevtools = true 
}: PropsWithChildren<QueryProviderProps>) {
  // We use useState to ensure the QueryClient is created only once per component lifecycle
  const [client] = useState(() => queryClient);

  return (
    <QueryClientProvider client={client}>
      {children}
      {/* Only show DevTools in development */}
      {process.env.NODE_ENV !== 'production' && showDevtools && (
        <ReactQueryDevtools initialIsOpen={false} position="bottom-right" />
      )}
    </QueryClientProvider>
  );
}

export default QueryProvider;
</file>

<file path="src/features/tanstack-query-api/CONSOLIDATION_PLAN.md">
# TanStack Query Implementation Consolidation Plan

## Current State

We have two working TanStack Query implementations:

### 1. Shared API Implementation (/shared/api/)
- Uses TanStack Query hooks (useQuery, useMutation)
- Has working token management
- Used by role-specific services (pharmacist, etc.)
- Provides useApi hook with custom abstractions

### 2. Feature-Specific Implementation (/features/tanstack-query-api/)
- More detailed implementation with separate concerns
- Includes query key management
- Used by exam feature
- Provides service creation patterns

## Consolidation Strategy

1. **Keep Both Temporarily**
   - Both implementations are working and using TanStack Query correctly
   - They serve different parts of the application
   - Immediate removal could break functionality

2. **Gradual Migration Plan**
   - Phase 1: Document all API usage patterns
   - Phase 2: Create unified patterns
   - Phase 3: Migrate services one by one
   - Phase 4: Remove duplicate code

3. **Steps to Unify**
   a. Move shared/api/apiClient.ts functionality into tanstack-query-api/core/apiClient.ts
   b. Merge token management strategies
   c. Consolidate hook patterns
   d. Update imports across the application

## Next Steps

1. Create unified TypeScript types
2. Merge request handling logic
3. Create migration guide for services
4. Update documentation

## Notes

- Keep tokenManager.ts as it's a core auth utility
- Keep adapter.ts files as they handle data transformation
- Keep role-specific service files but gradually update them to use the unified implementation

## Timeline

This should be a gradual process to ensure stability. Each service should be migrated individually with proper testing.
</file>

<file path="src/features/tanstack-query-api/core/apiClient.ts">
/**
 * TanStack Query API Client
 *
 * A powerful, flexible API client for React applications with built-in
 * TypeScript support and advanced features for authentication, error handling,
 * request deduplication, timeouts, and more.
 */

// Types
export interface ApiClientConfig {
  baseURL: string;
  defaultHeaders?: Record<string, string>;
  timeout?: number;
  onUnauthorized?: () => Promise<void>;
  tokenConfig?: {
    accessTokenKey?: string;
    refreshTokenKey?: string;
    expiryKey?: string;
  };
}

export interface RequestOptions extends Omit<RequestInit, 'body'> {
  requiresAuth?: boolean;
  autoRefreshToken?: boolean;
  deduplicate?: boolean;
  timeout?: number;
  body?: any;
}

export interface ApiError extends Error {
  status?: number;
  message: string;
  details?: Record<string, any>;
}

export interface ApiResponse<T> {
  data: T | null;
  error: ApiError | null;
  status: number;
  timestamp?: string;
  metadata?: Record<string, any>;
}

// Constants
const DEFAULT_TIMEOUT = 30000;

const DEFAULT_HEADERS: Record<string, string> = {
  'Content-Type': 'application/json',
  'Accept': 'application/json',
  'Cache-Control': 'no-cache',
};

// Retry configuration
export interface RetryConfig {
  attempts: number;
  delay: number;
  statusCodesToRetry: number[];
  shouldRetry: (status: number, attempts: number) => boolean;
}

const DEFAULT_RETRY_CONFIG: RetryConfig = {
  attempts: 3,
  delay: 1000,
  statusCodesToRetry: [408, 429, 500, 502, 503, 504],
  shouldRetry: (status: number, attempts: number) => {
    return attempts < DEFAULT_RETRY_CONFIG.attempts &&
      DEFAULT_RETRY_CONFIG.statusCodesToRetry.includes(status);
  },
};

/**
 * Core API client class
 */
export class ApiClient {
  private readonly baseURL: string;
  private readonly defaultHeaders: Record<string, string>;
  private readonly timeout: number;
  private readonly onUnauthorized?: () => Promise<void>;
  private readonly accessTokenKey: string;
  private readonly refreshTokenKey: string;
  private readonly expiryKey: string;
  private activeRequests: Map<string, Promise<any>> = new Map();

  constructor(config: ApiClientConfig) {
    this.baseURL = config.baseURL;
    this.defaultHeaders = {
      ...DEFAULT_HEADERS,
      ...config.defaultHeaders
    };
    this.timeout = config.timeout || DEFAULT_TIMEOUT;
    this.onUnauthorized = config.onUnauthorized;
    
    const tokenConfig = config.tokenConfig || {};
    this.accessTokenKey = tokenConfig.accessTokenKey || 'accessToken';
    this.refreshTokenKey = tokenConfig.refreshTokenKey || 'refreshToken';
    this.expiryKey = tokenConfig.expiryKey || 'tokenExpiry';
  }

  /**
   * Main request method handling all API calls with timeout, retries, and auth
   */
  async request<T>(
    endpoint: string,
    options: RequestOptions = {}
  ): Promise<ApiResponse<T>> {
    const {
      method = 'GET',
      requiresAuth = true,
      autoRefreshToken = true,
      deduplicate = true,
      timeout = this.timeout,
      ...fetchOptions
    } = options;

    // Create a cache key for deduplication
    const cacheKey = this.getCacheKey(endpoint, method, fetchOptions.body);
    
    // Return existing request if deduplicate is enabled
    if (deduplicate && method === 'GET' && this.activeRequests.has(cacheKey)) {
      return this.activeRequests.get(cacheKey) as Promise<ApiResponse<T>>;
    }

    // Execute the request with timeout handling
    const requestPromise = this.executeRequest<T>(endpoint, {
      ...options,
      method,
      requiresAuth,
      autoRefreshToken,
      timeout,
    });

    // Store promise for deduplication
    if (deduplicate && method === 'GET') {
      this.activeRequests.set(cacheKey, requestPromise);
      requestPromise.finally(() => {
        this.activeRequests.delete(cacheKey);
      });
    }

    return requestPromise;
  }

  /**
   * Execute the actual request with timeout handling
   */
  private async executeRequest<T>(
    endpoint: string,
    options: RequestOptions
  ): Promise<ApiResponse<T>> {
    const {
      method = 'GET',
      requiresAuth = true,
      autoRefreshToken = true,
      timeout = this.timeout,
      ...fetchOptions
    } = options;

    try {
      // Prepare request URL and headers
      const url = this.getUrl(endpoint);
      const headers = await this.prepareHeaders(fetchOptions.headers, requiresAuth);
      
      // Create AbortController for timeout handling
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      
      // Prepare the fetch options
      const fetchConfig = {
        ...fetchOptions,
        method,
        headers,
        signal: controller.signal,
        credentials: 'include' as RequestCredentials,
        mode: 'cors' as RequestMode,
      };

      if (process.env.NODE_ENV !== 'production') {
        console.log(`[API] ${method} ${url}`, { 
          headers: Object.fromEntries([...headers.entries()]),
          body: fetchOptions.body ? JSON.parse(fetchOptions.body as string) : undefined,
        });
      }

      // Execute the request
      const response = await fetch(url, fetchConfig);
      clearTimeout(timeoutId);

      // Handle 401 Unauthorized with token refresh
      if (response.status === 401 && autoRefreshToken) {
        const refreshedResponse = await this.handleUnauthorized<T>(endpoint, options);
        if (refreshedResponse) return refreshedResponse;
      }

      // Parse the response
      return this.parseResponse<T>(response);
    } catch (error) {
      // Handle request errors
      console.error(`[API Error] ${method} ${endpoint}:`, error);
      
      // Check for timeout
      if (error instanceof DOMException && error.name === 'AbortError') {
        const timeoutError = new Error(`Request timeout after ${timeout}ms`) as ApiError;
        timeoutError.status = 408;
        timeoutError.message = `Request timeout after ${timeout}ms`;
        return {
          data: null,
          error: timeoutError,
          status: 408,
          timestamp: new Date().toISOString()
        };
      }

      const apiError = error instanceof Error ? error as ApiError : new Error('Unknown error') as ApiError;
      apiError.message = apiError.message || 'Unknown error';
      apiError.status = apiError.status || 0;
      return {
        data: null,
        error: apiError,
        status: 0,
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * Get access token from storage
   */
  private getToken(): string | null {
    if (typeof window === 'undefined') return null;
    
    const token = localStorage.getItem(this.accessTokenKey);
    if (!token) return null;
    
    return token.startsWith('Bearer ') ? token : `Bearer ${token}`;
  }

  /**
   * Handle unauthorized responses by refreshing token
   */
  private async handleUnauthorized<T>(
    endpoint: string,
    options: RequestOptions
  ): Promise<ApiResponse<T> | null> {
    try {
      // Get refresh token
      const refreshToken = localStorage.getItem(this.refreshTokenKey);
      if (!refreshToken) {
        throw new Error('No refresh token available');
      }
      
      // Import the auth routes constants to get the correct path
      const AUTH_ROUTES = {
        REFRESH_TOKEN: '/auth/token/refresh'
      };
      
      // Call refresh token endpoint
      const response = await fetch(`${this.baseURL}${AUTH_ROUTES.REFRESH_TOKEN}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ refreshToken }),
      });
      
      if (!response.ok) {
        throw new Error(`Token refresh failed: ${response.status}`);
      }
      
      const data = await response.json();
      if (!data.token) {
        throw new Error('No token in refresh response');
      }
      
      // Save the new token
      localStorage.setItem(this.accessTokenKey, data.token);
      
      // Save new refresh token if provided
      if (data.refreshToken) {
        localStorage.setItem(this.refreshTokenKey, data.refreshToken);
      }
      
      // Save token expiry if provided
      if (data.expiresIn) {
        const expiryTime = Date.now() + (data.expiresIn * 1000);
        localStorage.setItem(this.expiryKey, expiryTime.toString());
      }
      
      // Retry the original request with the new token
      return this.request<T>(endpoint, {
        ...options,
        autoRefreshToken: false, // Prevent infinite loop
      });
    } catch (error) {
      console.error('Token refresh failed:', error);
      
      // Handle auth failure (redirect to login, etc.)
      if (this.onUnauthorized) {
        await this.onUnauthorized();
      }
      
      return null;
    }
  }

  /**
   * Generate a cache key for request deduplication
   */
  private getCacheKey(endpoint: string, method: string, body?: any): string {
    let key = `${method}:${endpoint}`;
    if (body && typeof body === 'string') {
      key += `:${this.hashString(body)}`;
    }
    return key;
  }

  /**
   * Generate a hash for a string (for cache keys)
   */
  private hashString(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash;
  }

  /**
   * Get the full URL for an API endpoint
   */
  private getUrl(endpoint: string): string {
    const cleanEndpoint = endpoint.startsWith('/') ? endpoint : `/${endpoint}`;
    return `${this.baseURL}${cleanEndpoint}`;
  }

  /**
   * Prepare headers for the request with authentication
   */
  private async prepareHeaders(
    customHeaders: HeadersInit = {},
    requiresAuth: boolean
  ): Promise<Headers> {
    const headers = new Headers();

    // Add default headers
    Object.entries(this.defaultHeaders).forEach(([key, value]) => {
      headers.set(key, value);
    });

    // Add custom headers
    if (customHeaders instanceof Headers) {
      customHeaders.forEach((value, key) => {
        headers.set(key, value);
      });
    } else if (typeof customHeaders === 'object') {
      Object.entries(customHeaders).forEach(([key, value]) => {
        if (typeof value === 'string') {
          headers.set(key, value);
        }
      });
    }

    // Add authentication header if required
    if (requiresAuth) {
      const token = this.getToken();
      if (!token) {
        console.warn('Authentication required but token not available. Proceeding with unauthenticated request.');
        return headers;
      }
      headers.set('Authorization', token);
    }

    return headers;
  }

  /**
   * Parse response based on content type and status
   */
  private async parseResponse<T>(response: Response): Promise<ApiResponse<T>> {
    let responseBody: any = null;
    let data: T | null = null;
    
    try {
      // Parse JSON for non-empty responses
      if (response.status !== 204 && response.headers.get('content-length') !== '0') {
        const contentType = response.headers.get('content-type');
        if (contentType?.includes('application/json')) {
          responseBody = await response.json();
          
          // Check if the response follows our standard format
          if (responseBody && typeof responseBody === 'object' && 'data' in responseBody) {
            // Response is already in the ApiResponse format
            return {
              data: responseBody.data,
              error: responseBody.error,
              status: response.status,
              timestamp: responseBody.timestamp || new Date().toISOString(),
              metadata: responseBody.metadata
            };
          } else {
            // Treat the entire response body as the data
            data = responseBody;
          }
        } else {
          // Handle non-JSON responses
          const textContent = await response.text();
          console.log(`[API] Non-JSON response: ${textContent.substring(0, 100)}...`);
          data = textContent as any;
        }
      }
    } catch (error) {
      console.error('Failed to parse response:', error);
    }

    // Handle error responses
    if (!response.ok) {
      const error = new Error(response.statusText || 'Request failed') as ApiError;
      error.status = response.status;
      error.message = responseBody?.message || response.statusText || 'Request failed';
      
      // Add details from response body if available
      if (responseBody?.details) {
        error.details = responseBody.details;
      }
      
      return { 
        data: null, 
        error, 
        status: response.status,
        timestamp: responseBody?.timestamp || new Date().toISOString(),
        metadata: responseBody?.metadata
      };
    }

    return { 
      data, 
      error: null, 
      status: response.status,
      timestamp: responseBody?.timestamp || new Date().toISOString(),
      metadata: responseBody?.metadata
    };
  }

  /**
   * Convenience method for GET requests
   */
  async get<T>(endpoint: string, options?: RequestOptions): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, { ...options, method: 'GET' });
  }

  /**
   * Convenience method for POST requests
   */
  async post<T>(
    endpoint: string,
    data?: unknown,
    options?: RequestOptions
  ): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, {
      ...options,
      method: 'POST',
      body: data ? JSON.stringify(data) : undefined
    });
  }

  /**
   * Convenience method for PUT requests
   */
  async put<T>(
    endpoint: string,
    data?: unknown,
    options?: RequestOptions
  ): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, {
      ...options,
      method: 'PUT',
      body: data ? JSON.stringify(data) : undefined
    });
  }

  /**
   * Convenience method for PATCH requests
   */
  async patch<T>(
    endpoint: string,
    data?: unknown,
    options?: RequestOptions
  ): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, {
      ...options,
      method: 'PATCH',
      body: data ? JSON.stringify(data) : undefined
    });
  }

  /**
   * Convenience method for DELETE requests
   */
  async delete<T>(endpoint: string, options?: RequestOptions): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, { ...options, method: 'DELETE' });
  }
}

/**
 * Create a configured API client instance
 */
export function createApiClient(config: ApiClientConfig): ApiClient {
  return new ApiClient(config);
}

/**
 * Default API client instance with common configuration
 */
export const apiClient = createApiClient({
  baseURL: process.env.NEXT_PUBLIC_API_BASE_URL ?? 'http://localhost:8080/api',
  onUnauthorized: async () => {
    if (typeof window !== 'undefined') {
      sessionStorage.setItem('redirectAfterLogin', window.location.pathname);
      window.location.href = '/login';
    }
  }
});

export default apiClient;
</file>

<file path="src/features/tanstack-query-api/core/apiTypes.ts">
/**
 * Core API types for standardized request and response handling
 */

import { ApiError, ApiResponse } from './apiClient';

/**
 * Pagination parameters for paginated requests
 */
export interface PaginationParams {
  page: number;
  size: number;
  sort?: string;
  direction?: 'asc' | 'desc';
}

/**
 * Pagination metadata for paginated responses
 */
export interface PaginationMetadata {
  page: number;
  size: number;
  totalElements: number;
  totalPages: number;
  hasNext: boolean;
  hasPrevious: boolean;
}

/**
 * Basic interface for entities that have an ID property
 */
export interface Entity {
  id: string | number;
}
</file>

<file path="src/features/tanstack-query-api/core/queryClient.ts">
/**
 * TanStack Query Client Configuration
 * 
 * This module provides a pre-configured QueryClient for TanStack Query
 * with optimal defaults for caching, retries, and error handling.
 */
import { QueryClient } from '@tanstack/react-query';
import { ApiError } from './apiClient';

/**
 * Default error handler for query errors
 */
export const defaultQueryErrorHandler = (error: unknown) => {
  if (!error) return;

  // Handle API errors with more context
  if ((error as ApiError).status && (error as ApiError).data) {
    const apiError = error as ApiError;
    const errorData = apiError.data;
    
    console.error('[TanStack Query] API Error:', {
      status: apiError.status,
      data: errorData,
      message: errorData?.message || errorData?.error || `Request failed with status ${apiError.status}`
    });
    return;
  }

  // Generic error handling
  console.error('[TanStack Query] Error:', error instanceof Error ? error.message : 'An unexpected error occurred');
};

/**
 * Create a configured query client with optimized defaults
 */
export const createQueryClient = (options: {
  defaultStaleTime?: number;
  defaultGcTime?: number;
} = {}) => {
  const {
    defaultStaleTime = 5 * 60 * 1000, // 5 minutes
    defaultGcTime = 10 * 60 * 1000    // 10 minutes
  } = options;

  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: defaultStaleTime,
        gcTime: defaultGcTime,
        retry: (failureCount, error) => {
          // Don't retry on 401, 403, or 404 errors
          if ((error as ApiError).status) {
            const status = (error as ApiError).status;
            if (status && [401, 403, 404].includes(status)) {
              return false;
            }
          }
          return failureCount < 3;
        },
        retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
        refetchOnWindowFocus: process.env.NODE_ENV === 'production',
        refetchOnMount: true,
      },
      mutations: {
        retry: (failureCount, error) => {
          // Only retry network-related errors, not 4xx/5xx responses
          if ((error as ApiError).status) {
            return false;
          }
          return failureCount < 2;
        },
      },
    },
  });
};

/**
 * Default query client instance with common configuration
 */
export const queryClient = createQueryClient();

export default queryClient;
</file>

<file path="src/features/tanstack-query-api/core/types.ts">
/**
 * Core API types for standardized request and response handling
 */

/**
 * Standard API error format
 */
export interface ApiError {
  status: number;
  message: string;
  details?: Record<string, any>;
}

/**
 * Standard API response format
 * All responses from the API should follow this structure
 */
export interface ApiResponse<T> {
  data: T | null;
  error: ApiError | null;
  status: number;
  timestamp: string;
  metadata?: Record<string, any>;
}

/**
 * Options for API requests
 */
export interface RequestOptions extends Omit<RequestInit, 'body'> {
  requiresAuth?: boolean;
  autoRefreshToken?: boolean;
  deduplicate?: boolean;
  timeout?: number;
  body?: any;
}

/**
 * Pagination parameters for paginated requests
 */
export interface PaginationParams {
  page: number;
  size: number;
  sort?: string;
  direction?: 'asc' | 'desc';
}

/**
 * Pagination metadata for paginated responses
 */
export interface PaginationMetadata {
  page: number;
  size: number;
  totalElements: number;
  totalPages: number;
  hasNext: boolean;
  hasPrevious: boolean;
}

/**
 * Configuration for the API client
 */
export interface ApiClientConfig {
  baseURL: string;
  defaultHeaders?: Record<string, string>;
  timeout?: number;
  onUnauthorized?: () => Promise<void>;
  tokenConfig?: {
    accessTokenKey?: string;
    refreshTokenKey?: string;
    expiryKey?: string;
  };
}

/**
 * Basic interface for entities that have an ID property
 */
export interface Entity {
  id: string | number;
}
</file>

<file path="src/features/tanstack-query-api/hooks/useApi.ts">
/**
 * TanStack Query API Hooks
 * 
 * This module provides React hooks that integrate TanStack Query
 * with our API client for data fetching and mutations.
 */
import { 
  useQuery, 
  useMutation, 
  useQueryClient,
  UseQueryOptions, 
  UseMutationOptions,
  QueryKey,
  QueryFunctionContext
} from '@tanstack/react-query';
import { apiClient, ApiResponse } from '../core/apiClient';

/**
 * Enhanced query options with API-specific props
 */
export interface UseApiQueryOptions<TData, TError = Error, TQueryFnData = TData> 
  extends Omit<UseQueryOptions<TData, TError, TQueryFnData>, 'queryKey' | 'queryFn'> {
  requiresAuth?: boolean;
  deduplicate?: boolean;
  timeout?: number;
}

/**
 * Enhanced mutation options with API-specific props
 */
export interface UseApiMutationOptions<TData, TError = Error, TVariables = void, TContext = unknown> 
  extends Omit<UseMutationOptions<TData, TError, TVariables, TContext>, 'mutationFn'> {
  requiresAuth?: boolean;
}

/**
 * Parameters for paginated queries
 */
export interface PaginationParams {
  page: number;
  size: number;
}

/**
 * Hook for making GET requests with TanStack Query
 */
export function useApiQuery<TData, TError = Error, TQueryFnData = TData>(
  queryKey: QueryKey,
  endpoint: string,
  options: UseApiQueryOptions<TData, TError, TQueryFnData> = {}
) {
  const { requiresAuth = true, deduplicate = true, timeout, ...queryOptions } = options;

  return useQuery<TData, TError, TQueryFnData>({
    queryKey,
    queryFn: async () => {
      const response = await apiClient.get<TData>(endpoint, { 
        requiresAuth,
        deduplicate,
        timeout
      });
      
      if (response.error) {
        throw response.error;
      }
      
      return response.data as TData;
    },
    ...queryOptions
  });
}

/**
 * Hook for making POST requests (create operations)
 */
export function useApiMutation<TData, TVariables = unknown, TError = Error, TContext = unknown>(
  endpoint: string,
  options: UseApiMutationOptions<TData, TError, TVariables, TContext> = {}
) {
  const { requiresAuth = true, ...mutationOptions } = options;
  const queryClient = useQueryClient();

  return useMutation<TData, TError, TVariables, TContext>({
    mutationFn: async (variables) => {
      const response = await apiClient.post<TData>(endpoint, variables, { 
        requiresAuth 
      });
      
      if (response.error) {
        throw response.error;
      }
      
      return response.data as TData;
    },
    ...mutationOptions
  });
}

/**
 * Hook for making PUT requests (full updates)
 */
export function useApiPut<TData, TVariables = unknown, TError = Error, TContext = unknown>(
  endpoint: string,
  options: UseApiMutationOptions<TData, TError, TVariables, TContext> = {}
) {
  const { requiresAuth = true, ...mutationOptions } = options;
  const queryClient = useQueryClient();

  return useMutation<TData, TError, TVariables, TContext>({
    mutationFn: async (variables) => {
      const response = await apiClient.put<TData>(endpoint, variables, { 
        requiresAuth 
      });
      
      if (response.error) {
        throw response.error;
      }
      
      return response.data as TData;
    },
    ...mutationOptions
  });
}

/**
 * Hook for making PATCH requests (partial updates)
 */
export function useApiPatch<TData, TVariables = unknown, TError = Error, TContext = unknown>(
  endpoint: string,
  options: UseApiMutationOptions<TData, TError, TVariables, TContext> = {}
) {
  const { requiresAuth = true, ...mutationOptions } = options;
  const queryClient = useQueryClient();

  return useMutation<TData, TError, TVariables, TContext>({
    mutationFn: async (variables) => {
      const response = await apiClient.patch<TData>(endpoint, variables, { 
        requiresAuth 
      });
      
      if (response.error) {
        throw response.error;
      }
      
      return response.data as TData;
    },
    ...mutationOptions
  });
}

/**
 * Hook for making DELETE requests
 */
export function useApiDelete<TData, TVariables = void, TError = Error, TContext = unknown>(
  endpoint: string,
  options: UseApiMutationOptions<TData, TError, TVariables, TContext> = {}
) {
  const { requiresAuth = true, ...mutationOptions } = options;
  const queryClient = useQueryClient();

  return useMutation<TData, TError, TVariables, TContext>({
    mutationFn: async (variables) => {
      // For DELETE with body content
      const hasBody = variables !== undefined && variables !== null && variables !== void 0;
      
      const response = hasBody
        ? await apiClient.request<TData>(endpoint, { 
            method: 'DELETE',
            requiresAuth,
            body: JSON.stringify(variables)
          })
        : await apiClient.delete<TData>(endpoint, { requiresAuth });
      
      if (response.error) {
        throw response.error;
      }
      
      return response.data as TData;
    },
    ...mutationOptions
  });
}

/**
 * Hook for paginated queries
 */
export function useApiPaginatedQuery<TData, TError = Error, TQueryFnData = TData>(
  queryKey: QueryKey,
  endpoint: string,
  params: PaginationParams,
  options: UseApiQueryOptions<TData, TError, TQueryFnData> = {}
) {
  const { page, size } = params;
  const paginatedEndpoint = `${endpoint}?page=${page}&size=${size}`;
  
  return useApiQuery<TData, TError, TQueryFnData>(
    [...queryKey, { page, size }],
    paginatedEndpoint,
    options
  );
}

/**
 * Hook for infinite queries (e.g., "load more" functionality)
 */
export function useApiInfiniteQuery<TData, TError = Error, TQueryFnData = TData>(
  queryKey: QueryKey,
  endpoint: string,
  options: UseApiQueryOptions<TData, TError, TQueryFnData> = {}
) {
  const { requiresAuth = true, ...queryOptions } = options;

  return useQuery<TData, TError, TQueryFnData>({
    queryKey,
    queryFn: async (context: QueryFunctionContext) => {
      const { pageParam = 0 } = context;
      const response = await apiClient.get<TData>(
        `${endpoint}?page=${pageParam}`,
        { requiresAuth }
      );
      
      if (response.error) {
        throw response.error;
      }
      
      return response.data as TData;
    },
    ...queryOptions
  });
}

/**
 * Type-safe utility for building query keys
 */
export const createQueryKeys = <T extends Record<string, (...args: any[]) => QueryKey>>(keys: T) => keys;
</file>

<file path="src/features/tanstack-query-api/index.ts">
/**
 * TanStack Query API Integration
 * 
 * This module provides a complete solution for API communication in React applications
 * using TanStack Query (formerly React Query). It includes a custom API client,
 * query hooks, service factories, and standardized types.
 * 
 * Main features:
 * - API client with authentication, error handling, and request deduplication
 * - TanStack Query hooks for data fetching and mutations
 * - Service factories for creating type-safe API services
 * - Standardized response structures and error handling
 * - TypeScript support throughout
 */

// Export components
export { default as QueryProvider } from './components/QueryProvider';

// Export core functionality
export { 
  apiClient, 
  createApiClient 
} from './core/apiClient';

export {
  queryClient,
  createQueryClient,
  defaultQueryErrorHandler
} from './core/queryClient';

// Export hook utilities
export {
  useApiQuery,
  useApiMutation,
  useApiPut,
  useApiPatch,
  useApiDelete,
  useApiPaginatedQuery,
  useApiInfiniteQuery,
  createQueryKeys
} from './hooks/useApi';

// Export service factories
export {
  createApiService,
  createExtendedApiService
} from './services/createService';

// Export types
export {
  apiQueryKeys,
  buildQueryString
} from './utils/types';

// Export all types
export type {
  // From apiClient.ts
  ApiClientConfig,
  RequestOptions,
  ApiResponse,
  ApiError,
  RetryConfig,
} from './core/apiClient';

export type {
  // From useApi.ts
  UseApiQueryOptions,
  UseApiMutationOptions,
  PaginationParams as ApiPaginationParams,
} from './hooks/useApi';

export type {
  // From createService.ts
  ApiService,
} from './services/createService';

export type {
  // From types.ts
  ApiPaginatedResponse,
  ApiSuccessResponse,
  ApiFailureResponse,
  ApiWrappedResponse,
  ApiErrorResponse,
  FilterParams,
  QueryParams,
  PaginationParams,
} from './utils/types';
</file>

<file path="src/features/tanstack-query-api/README.md">
# TanStack Query API Integration

This package provides a complete solution for API communication in React applications using TanStack Query (formerly React Query). It includes a custom API client, query hooks, service factories, and standardized types.

## Features

- **API Client** - A robust fetch wrapper with authentication, error handling, and request deduplication
- **TanStack Query Integration** - Custom hooks for data fetching and mutations that work with TanStack Query
- **Service Factory** - Create type-safe API services for different entities
- **TypeScript Support** - Full type safety from request to response
- **Standardized Response Structures** - Consistent error handling and data access patterns

## Installation

This package is ready to use in your project. It's recommended to put it in your project's `src/features` directory.

Make sure you have the following dependencies installed:

```bash
npm install @tanstack/react-query @tanstack/react-query-devtools
```

## Usage

### Setting up the Provider

Wrap your application with the `QueryProvider` component:

```tsx
// In your app layout or root component:
import { QueryProvider } from '@/features/tanstack-query-api';

function App() {
  return (
    <QueryProvider>
      <YourApp />
    </QueryProvider>
  );
}
```

### Basic Data Fetching

Use the `useApiQuery` hook to fetch data:

```tsx
import { useApiQuery, apiQueryKeys } from '@/features/tanstack-query-api';

function UserProfile({ userId }) {
  const { data, isLoading, error } = useApiQuery(
    apiQueryKeys.users.detail(userId),
    `/users/${userId}`
  );

  if (isLoading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.email}</p>
    </div>
  );
}
```

### Mutations

Use the mutation hooks for creating, updating, or deleting data:

```tsx
import { useApiMutation } from '@/features/tanstack-query-api';

function CreateUserForm() {
  const { mutate, isLoading } = useApiMutation(
    '/users',
    {
      onSuccess: (data) => {
        console.log('User created:', data);
        // Handle success (e.g., show notification, navigate)
      },
      onError: (error) => {
        console.error('Failed to create user:', error);
        // Handle error (e.g., show error message)
      }
    }
  );

  const handleSubmit = (formData) => {
    mutate(formData);
  };

  // Form component
}
```

### Paginated Queries

For paginated data:

```tsx
import { useApiPaginatedQuery, apiQueryKeys } from '@/features/tanstack-query-api';

function UserList() {
  const [page, setPage] = useState(0);
  const { data, isLoading } = useApiPaginatedQuery(
    apiQueryKeys.users.list(),
    '/users',
    { page, size: 10 }
  );

  // Render paginated list
}
```

### Creating Services

Create reusable services for your entities:

```tsx
import { createApiService } from '@/features/tanstack-query-api';

// Define your entity type
interface User {
  id: string;
  name: string;
  email: string;
}

// Create a service
const userService = createApiService<User>('/users');

// Use the service
const response = await userService.getAll();
const user = await userService.getById('123');
```

For custom methods, use the extended service factory:

```tsx
import { createExtendedApiService, apiClient } from '@/features/tanstack-query-api';

const authService = createExtendedApiService<User, {
  login: (credentials: LoginCredentials) => Promise<ApiResponse<AuthResponse>>;
}>('/auth', {
  login: async (credentials) => {
    return apiClient.post<AuthResponse>('/auth/login', credentials);
  }
});

// Use the custom method
const response = await authService.login({ email, password });
```

## API Reference

### Core

- `apiClient` - The main API client instance
- `createApiClient(config)` - Factory function to create custom API clients
- `queryClient` - The pre-configured TanStack Query client
- `createQueryClient(options)` - Factory function to create custom query clients

### Hooks

- `useApiQuery(queryKey, endpoint, options)` - Hook for GET requests
- `useApiMutation(endpoint, options)` - Hook for POST requests
- `useApiPut(endpoint, options)` - Hook for PUT requests
- `useApiPatch(endpoint, options)` - Hook for PATCH requests
- `useApiDelete(endpoint, options)` - Hook for DELETE requests
- `useApiPaginatedQuery(queryKey, endpoint, paginationParams, options)` - Hook for paginated queries
- `useApiInfiniteQuery(queryKey, endpoint, options)` - Hook for infinite queries

### Services

- `createApiService(baseEndpoint)` - Create a basic CRUD service
- `createExtendedApiService(baseEndpoint, customMethods)` - Create a service with custom methods

### Utilities

- `apiQueryKeys` - Standard query keys for common entities
- `buildQueryString(params)` - Build URL query parameters from an object

## Best Practices

1. **Use Query Keys Consistently**
   - Leverage the `apiQueryKeys` object for consistent query keys
   - Structure keys hierarchically (e.g., `['users', userId, 'posts']`)

2. **Handle Errors Properly**
   - Check for `response.error` before using `response.data`
   - Use appropriate error boundaries at the component level

3. **Optimize Refetching**
   - Configure appropriate `staleTime` for each query
   - Use `refetchOnWindowFocus` based on data freshness requirements

4. **Leverage Type Safety**
   - Define interfaces for all request/response data
   - Use generics with API hooks for type inference

5. **Use Optimistic Updates**
   - Update the UI immediately before server confirmation
   - Handle rollback if the server request fails

## Porting to Other Projects

This entire feature can be easily ported to other projects by copying the `src/features/tanstack-query-api` directory. The module is self-contained and only requires TanStack Query as a dependency.

When porting to a new project:

1. Copy the entire directory to your new project's `src/features` folder
2. Install TanStack Query dependencies if not already installed
3. Configure your API base URL in your environment variables or directly in the code
4. Update any project-specific types or configurations as needed

## License

This module is proprietary and intended for use within your organization's projects only.
</file>

<file path="src/features/tanstack-query-api/services/createService.ts">
/**
 * API Service Factory
 * 
 * This module provides factory functions for creating type-safe API services
 * that integrate with the API client and TanStack Query.
 */
import { apiClient } from '../core/apiClient';
import type { RequestOptions, ApiResponse } from '../core/apiClient';

/**
 * Interface for standard service methods
 */
export interface ApiService<T> {
  getAll: (options?: RequestOptions) => Promise<ApiResponse<T[]>>;
  getById: (id: string | number, options?: RequestOptions) => Promise<ApiResponse<T>>;
  create: (data: Partial<T>, options?: RequestOptions) => Promise<ApiResponse<T>>;
  update: (id: string | number, data: Partial<T>, options?: RequestOptions) => Promise<ApiResponse<T>>;
  patch: (id: string | number, data: Partial<T>, options?: RequestOptions) => Promise<ApiResponse<T>>;
  remove: (id: string | number, options?: RequestOptions) => Promise<ApiResponse<void>>;
}

/**
 * Create a service for interacting with a specific API resource
 * 
 * @param baseEndpoint The base endpoint for the resource (e.g., '/users')
 * @returns A service object with methods for common CRUD operations
 */
export function createApiService<T>(baseEndpoint: string): ApiService<T> {
  // Ensure the base endpoint has the correct format
  const endpoint = baseEndpoint.startsWith('/')
    ? baseEndpoint
    : `/${baseEndpoint}`;

  return {
    /**
     * Get all resources of this type
     */
    getAll: async (options?: RequestOptions): Promise<ApiResponse<T[]>> => {
      return apiClient.get<T[]>(endpoint, options);
    },

    /**
     * Get a resource by ID
     */
    getById: async (id: string | number, options?: RequestOptions): Promise<ApiResponse<T>> => {
      return apiClient.get<T>(`${endpoint}/${id}`, options);
    },

    /**
     * Create a new resource
     */
    create: async (data: Partial<T>, options?: RequestOptions): Promise<ApiResponse<T>> => {
      return apiClient.post<T>(endpoint, data, options);
    },

    /**
     * Update a resource (complete replacement)
     */
    update: async (id: string | number, data: Partial<T>, options?: RequestOptions): Promise<ApiResponse<T>> => {
      return apiClient.put<T>(`${endpoint}/${id}`, data, options);
    },

    /**
     * Partially update a resource
     */
    patch: async (id: string | number, data: Partial<T>, options?: RequestOptions): Promise<ApiResponse<T>> => {
      return apiClient.patch<T>(`${endpoint}/${id}`, data, options);
    },

    /**
     * Delete a resource
     */
    remove: async (id: string | number, options?: RequestOptions): Promise<ApiResponse<void>> => {
      return apiClient.delete<void>(`${endpoint}/${id}`, options);
    }
  };
}

/**
 * Create a service with custom methods
 * 
 * @param baseEndpoint The base endpoint for the resource
 * @param customMethods Object containing custom methods to add to the service
 * @returns A service object with standard CRUD and custom methods
 */
export function createExtendedApiService<T, TMethods>(
  baseEndpoint: string,
  customMethods: TMethods
): ApiService<T> & TMethods {
  const baseService = createApiService<T>(baseEndpoint);
  return { ...baseService, ...customMethods };
}

export default createApiService;
</file>

<file path="src/features/tanstack-query-api/utils/types.ts">
/**
 * Common API Types
 * 
 * This module provides common types for API responses, pagination,
 * and other shared data structures used across the application.
 */

/**
 * Base type for API responses with pagination
 */
export interface ApiPaginatedResponse<T> {
  content: T[];
  pageable: {
    pageNumber: number;
    pageSize: number;
    sort: {
      empty: boolean;
      sorted: boolean;
      unsorted: boolean;
    };
    offset: number;
    paged: boolean;
    unpaged: boolean;
  };
  last: boolean;
  totalElements: number;
  totalPages: number;
  size: number;
  number: number;
  sort: {
    empty: boolean;
    sorted: boolean;
    unsorted: boolean;
  };
  first: boolean;
  numberOfElements: number;
  empty: boolean;
}

/**
 * Base pagination parameters
 */
export interface PaginationParams {
  page: number;
  size: number;
  sort?: string;
}

/**
 * Filter parameters for search functionality
 */
export interface FilterParams {
  [key: string]: string | number | boolean | undefined;
}

/**
 * Combined parameters for paginated, filtered requests
 */
export interface QueryParams extends PaginationParams, FilterParams {}

/**
 * Typing for API error response
 */
export interface ApiErrorResponse {
  timestamp: string;
  status: number;
  error: string;
  message: string;
  path: string;
  errorDetails?: Record<string, string[]>;
}

/**
 * Wrapper for standard API success response
 */
export interface ApiSuccessResponse<T> {
  data: T;
  success: true;
  message?: string;
}

/**
 * Wrapper for standard API failure response
 */
export interface ApiFailureResponse {
  success: false;
  message: string;
  error: string;
  status: number;
}

/**
 * Union type for API responses
 */
export type ApiWrappedResponse<T> = ApiSuccessResponse<T> | ApiFailureResponse;

/**
 * Utility function to build URL query strings from objects
 * 
 * @param params Object containing query parameters
 * @returns URL-encoded query string (without the leading '?')
 */
export function buildQueryString(params: Record<string, any>): string {
  return Object.entries(params)
    .filter(([_, value]) => value !== undefined && value !== null && value !== '')
    .map(([key, value]) => {
      // Handle array values
      if (Array.isArray(value)) {
        return value
          .map(v => `${encodeURIComponent(key)}=${encodeURIComponent(v)}`)
          .join('&');
      }
      return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
    })
    .join('&');
}

/**
 * Standard query key factory for common entity types
 */
export const apiQueryKeys = {
  auth: {
    user: () => ['auth', 'user'],
    session: () => ['auth', 'session'],
    login: () => ['auth', 'login'],
    register: () => ['auth', 'register'],
  },
  users: {
    all: () => ['users'],
    list: (filters?: any) => ['users', 'list', filters],
    detail: (id: string | number) => ['users', 'detail', id],
    profile: () => ['users', 'profile'],
    settings: () => ['users', 'settings'],
  },
  exams: {
    all: () => ['exams'],
    list: (filters?: any) => ['exams', 'list', filters],
    detail: (id: string | number) => ['exams', 'detail', id],
    questions: (examId: string | number) => ['exams', 'questions', examId],
    results: (examId: string | number, userId?: string) => 
      userId ? ['exams', examId, 'results', userId] : ['exams', examId, 'results'],
  },
  progress: {
    user: (userId?: string) => ['progress', 'user', userId],
    exam: (examId: string | number) => ['progress', 'exam', examId],
    detail: (userId: string, examId: string) => ['progress', 'detail', userId, examId],
    statistics: (userId?: string) => ['progress', 'statistics', userId],
  },
  dashboard: {
    stats: () => ['dashboard', 'stats'],
    timeline: (period: string) => ['dashboard', 'timeline', period],
    recommendations: () => ['dashboard', 'recommendations'],
  },
};
</file>

<file path="src/features/ui/hooks/index.ts">
/**
 * UI Feature Hooks
 */
export { useIsMobile } from './use-mobile';
</file>

<file path="src/features/ui/hooks/use-mobile.ts">
/**
 * Responsive hooks for UI components
 */
import { useEffect, useState } from 'react';

/**
 * Hook that detects if the viewport is mobile-sized
 * @param breakpoint - Width threshold in pixels
 * @returns Boolean indicating if viewport is below the breakpoint
 */
export function useIsMobile(breakpoint = 768): boolean {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    // Default to desktop on server
    if (typeof window === 'undefined') {
      setIsMobile(false);
      return;
    }

    // Check if viewport is mobile
    const checkMobile = () => {
      setIsMobile(window.innerWidth < breakpoint);
    };

    // Initial check
    checkMobile();

    // Set up listener for window resize
    window.addEventListener('resize', checkMobile);

    // Clean up listener
    return () => window.removeEventListener('resize', checkMobile);
  }, [breakpoint]);

  return isMobile;
}

/**
 * Export as default for compatibility
 */
export default useIsMobile;
</file>

<file path="src/features/ui/index.ts">
/**
 * UI Feature
 * 
 * This feature provides shared UI utilities and hooks.
 */

// Export hooks
export * from './hooks';
</file>

<file path="src/lib/utils.ts">
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="src/shared/auth/index.ts">
/**
 * Re-export auth feature for compatibility
 * This file serves as a compatibility layer for older code
 */

// Re-export everything from the auth feature
export * from '@/features/auth';

// Re-export rbac components
export {
  PermissionGuard,
  RoleGuard,
  PermissionCheck,
  usePermission,
  useRole,
  AdminGuard,
  ManagerGuard,
  ResourceGuard
} from '@/features/rbac';
</file>

<file path="src/shared/config/logger.ts">
import { LoggerConfig } from '../types/logger';
import path from 'path';

const isDevelopment = process.env.NODE_ENV === 'development';

export const loggerConfig: LoggerConfig = {
  level: isDevelopment ? 'debug' : 'info',
  directory: path.join(process.cwd(), 'logs'),
  maxSize: '10m',
  maxFiles: '14d',
  format: 'json'
};

export const logFormatConfig = {
  timestamp: true,
  json: true,
  colorize: isDevelopment,
  prettyPrint: isDevelopment,
  metadata: {
    app: 'pharmacyhub-frontend',
    environment: process.env.NODE_ENV || 'development'
  }
};

// Define log file patterns
export const logFilePatterns = {
  error: 'error-%DATE%.log',
  combined: 'combined-%DATE%.log',
  api: 'api-%DATE%.log'
};

// Define retention policies
export const retentionPolicy = {
  maxFiles: '14d',    // Keep logs for 14 days
  maxSize: '10m'      // Maximum size per file
};
</file>

<file path="src/shared/index.ts">
export * from './ui';
export * from './api';
export * from './config';
export * from './lib';
export * from './types';
</file>

<file path="src/shared/lib/logger.ts">
/**
 * Application logger
 * 
 * This module provides logging utilities for the application
 * with different log levels and environments support.
 */

type LogLevel = 'debug' | 'info' | 'warn' | 'error';

interface LoggerOptions {
  prefix?: string;
  enabled?: boolean;
  level?: LogLevel;
}

class Logger {
  private prefix: string;
  private enabled: boolean;
  private level: LogLevel;
  private levels: Record<LogLevel, number>;

  constructor(options: LoggerOptions = {}) {
    this.prefix = options.prefix || '';
    this.enabled = options.enabled ?? (process.env.NODE_ENV !== 'production');
    this.level = options.level || 'info';
    
    this.levels = {
      debug: 0,
      info: 1,
      warn: 2,
      error: 3
    };
  }

  /**
   * Format message with prefix
   */
  private format(message: string): string {
    return this.prefix ? `[${this.prefix}] ${message}` : message;
  }

  /**
   * Check if the given log level should be displayed
   */
  private shouldLog(level: LogLevel): boolean {
    return this.enabled && this.levels[level] >= this.levels[this.level];
  }

  /**
   * Log debug message
   */
  debug(message: string, ...args: any[]): void {
    if (this.shouldLog('debug')) {
      console.debug(this.format(message), ...args);
    }
  }

  /**
   * Log info message
   */
  info(message: string, ...args: any[]): void {
    if (this.shouldLog('info')) {
      console.info(this.format(message), ...args);
    }
  }

  /**
   * Log warning message
   */
  warn(message: string, ...args: any[]): void {
    if (this.shouldLog('warn')) {
      console.warn(this.format(message), ...args);
    }
  }

  /**
   * Log error message
   */
  error(message: string | Error, ...args: any[]): void {
    if (this.shouldLog('error')) {
      if (message instanceof Error) {
        console.error(this.format(message.message), message.stack, ...args);
      } else {
        console.error(this.format(message), ...args);
      }
    }
  }

  /**
   * Create a child logger with a new prefix
   */
  child(prefix: string): Logger {
    return new Logger({
      prefix: this.prefix ? `${this.prefix}:${prefix}` : prefix,
      enabled: this.enabled,
      level: this.level
    });
  }
}

/**
 * Default application logger
 */
export const logger = new Logger({ prefix: 'app' });

/**
 * Create a feature logger with the given name
 */
export function createFeatureLogger(feature: string): Logger {
  return logger.child(feature);
}

export default logger;
</file>

<file path="src/shared/ui/cards/interactive-card.tsx">
import { cn } from "@/lib/utils";
import { motion } from "framer-motion";
import { ReactNode } from "react";

interface InteractiveCardProps {
  children: ReactNode;
  onClick?: () => void;
  className?: string;
  disabled?: boolean;
}

export const InteractiveCard = ({
  children,
  onClick,
  className,
  disabled = false
}: InteractiveCardProps) => {
  return (
    <motion.div
      whileTap={disabled ? undefined : { scale: 0.98 }}
      className={cn(
        "p-4 rounded-lg shadow-sm bg-card",
        "touch-none",
        !disabled && "cursor-pointer active:bg-accent/50",
        disabled && "opacity-60 cursor-not-allowed",
        "transition-colors duration-200",
        className
      )}
      onClick={disabled ? undefined : onClick}
    >
      {children}
    </motion.div>
  );
};
</file>

<file path="src/shared/ui/CarouselImage.tsx">
import React from 'react';
import Image from 'next/image';
import {Carousel, CarouselContent, CarouselItem} from "@/components/ui/carousel";
import Autoplay from "embla-carousel-autoplay";

interface Image {
  src: string;
  alt: string;
  className?: string;
  width?: number;
  height?: number;
}

interface ImageCarouselProps {
  images: Image[];
}

const CarouselImage = ({images}: ImageCarouselProps) => {
  const plugin = React.useRef(
    Autoplay({delay: 2000, stopOnInteraction: true})
  );

  return (
    <Carousel
      className="w-full"
      plugins={[plugin.current]}
      onMouseEnter={plugin.current.stop}
      onMouseLeave={plugin.current.reset}
    >
      <CarouselContent>
        {images.map((image, index) => (
          <CarouselItem key={index}>
            <div className="relative w-full h-[200px] sm:h-[300px] md:h-[400px] lg:h-[450px] xl:h-[500px] 2xl:h-[600px]">
              <Image
                src={image.src}
                alt={image.alt}
                fill
                priority={index === 0}
                sizes="100vw"
                className={`object-cover ${image.className || ""}`}
                style={{
                  maxHeight: 'calc(100vh - 200px)',
                  objectPosition: 'center'
                }}
              />
            </div>
          </CarouselItem>
        ))}
      </CarouselContent>
    </Carousel>
  );
};

export default CarouselImage;
</file>

<file path="src/shared/ui/DebouncedSelect.tsx">
import React, {useEffect, useMemo, useRef, useState} from 'react';
import {Select, SelectContent, SelectItem, SelectTrigger, SelectValue} from "@/components/ui/select";
import {useDebounce} from '@/hooks/useDebounce';
import {Input} from '@/components/ui/input';
import {ScrollArea} from '@/components/ui/scroll-area';

interface DebouncedSelectProps {
  options: { id: string | number; name: string }[];
  value: string;
  onChange: (value: string) => void;
  placeholder: string;
}

export const DebouncedSelect: React.FC<DebouncedSelectProps> = React.memo(({
                                                                             options = [],
                                                                             value,
                                                                             onChange,
                                                                             placeholder
                                                                           }) => {
  const [search, setSearch] = useState('');
  const [isOpen, setIsOpen] = useState(false);
  const debouncedSearch = useDebounce(search, 300);
  const inputRef = useRef<HTMLInputElement>(null);

  const filteredOptions = useMemo(() =>
      options.filter(option =>
        (option?.name?.toLowerCase().includes(debouncedSearch.toLowerCase()) ||
          option?.firstName?.toLowerCase().includes(debouncedSearch.toLowerCase()) ||
          option?.lastName?.toLowerCase().includes(debouncedSearch.toLowerCase())) ?? false
      ),
    [options, debouncedSearch]
  );

  useEffect(() => {
    if (isOpen && inputRef.current) {
      inputRef.current.focus();
    }
  }, [isOpen]);

  const handleSelect = (selectedValue: string) => {
    onChange(selectedValue);
    setSearch('');
    setIsOpen(false);
  };

  return (
    <div className="relative">
      <Select
        open={isOpen}
        onOpenChange={setIsOpen}
        value={value}
        onValueChange={handleSelect}
      >
        <SelectTrigger onClick={() => setIsOpen(true)}>
          <SelectValue placeholder={placeholder}/>
        </SelectTrigger>
        <SelectContent>
          <Input
            ref={inputRef}
            placeholder="Search..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            className="mb-2"
            onKeyDown={(e) => e.stopPropagation()}
          />
          <ScrollArea className="h-[200px]">
            {filteredOptions.map((option) => (
              <SelectItem key={option.id} value={option.id.toString()}>
                {option.name || `${option.firstName} ${option.lastName}`.trim()}
              </SelectItem>
            ))}
          </ScrollArea>
        </SelectContent>
      </Select>
    </div>
  );
});

DebouncedSelect.displayName = 'DebouncedSelect';
</file>

<file path="src/shared/ui/DialogContentField.tsx">
import React from "react";
import {DialogOverlay, DialogPortal} from "@/components/ui/dialog";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import {cn} from "@/lib/utils";
import {X} from "lucide-react";
import {DialogHeaderField} from "@/components/ui/DialogHeaderField";
import {Button} from "@/components/ui/button";
import {AiOutlineEdit, AiOutlinePlus} from "react-icons/ai";

interface DialogContentFieldProps extends React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content> {
  title: string;
  icon: React.ReactNode;
  operation?: 'Edit' | 'Add';
  onSubmit?: () => void;
  isSubmitting?: boolean;
}

export const DialogContentField = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  DialogContentFieldProps
>(({className, children, title, icon, operation, onSubmit, isSubmitting, ...props}, ref) => (
  <DialogPortal>
    <DialogOverlay
      className="fixed inset-0 bg-black/40 backdrop-blur-sm
                      data-[state=open]:animate-in data-[state=closed]:animate-out
                      data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0
                      transition-all duration-300"/>
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 w-full max-w-lg translate-x-[-50%] translate-y-[-50%] bg-background",
        "flex flex-col",
        "max-h-[90vh]", // Set maximum height
        "rounded-2xl overflow-hidden", // Increased border radius
        "shadow-lg",
        "data-[state=open]:animate-in data-[state=closed]:animate-out",
        "data-[state=open]:scale-100 data-[state=closed]:scale-95",
        "data-[state=open]:slide-in-from-bottom-[48%] data-[state=closed]:slide-out-to-bottom-[48%]",
        "transition-all duration-300 ease-out",
        className
      )}
      {...props}
    >
      {/* Fixed Header */}
      <div className="flex-none">
        <DialogHeaderField
          title={operation ? 'Edit ' + title : 'Add ' + title}
          icon={icon}
        />
      </div>

      {/* Scrollable Content */}
      <div className="flex-1 overflow-y-auto min-h-0">
        <div className="p-6">
          {children}
        </div>
      </div>

      {/* Fixed Footer */}
      <div className="flex-none border-t bg-background p-4">
        <div className="flex justify-center space-x-20 px-4">
          <DialogPrimitive.Close
            className="inline-flex items-center justify-center h-10 px-6 text-sm font-medium bg-red-600 text-white rounded-full shadow-md transition-all duration-200 transform hover:bg-red-700 hover:scale-105 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-red-400 focus-visible:ring-offset-2"
          >
            <X className="h-4 w-4 mr-2"/>
            Close
          </DialogPrimitive.Close>

          <Button
            type="submit"
            onClick={onSubmit}
            disabled={isSubmitting}
            className="rounded-full px-6 shadow-md hover:scale-105 transition-transform">
            {isSubmitting ? (
              'Saving...'
            ) : operation ? (
              <>
                <AiOutlineEdit className="mr-2"/> Update
              </>
            ) : (
              <>
                <AiOutlinePlus className="mr-2"/> Add
              </>
            )}
          </Button>
        </div>
      </div>
    </DialogPrimitive.Content>
  </DialogPortal>
));

DialogContentField.displayName = "DialogContentField";
</file>

<file path="src/shared/ui/DialogHeaderField.tsx">
import React from 'react';

interface DialogHeaderFieldProps {
  title: string;
  subtitle?: string;
  icon?: React.ReactNode;
  className?: string;
}

export const DialogHeaderField: React.FC<DialogHeaderFieldProps> = ({
                                                                      title,
                                                                      icon,
                                                                      className = '',
                                                                      ...props
                                                                    }) => {
  return (
    <div
      className="bg-primary p-6 relative overflow-hidden rounded-t-lg flex justify-center items-center"
      {...props}
    >
      <div className="flex items-center space-x-4 justify-center">
        <div className="relative p-3 rounded-full bg-primary-foreground">
          <div className="relative">
            {icon && React.cloneElement(icon as React.ReactElement, {
              className: "h-8 w-8 text-primary"
            })}
          </div>
        </div>
        <h2 className="text-2xl font-semibold text-primary-foreground">
          {title}
        </h2>
      </div>
    </div>
  );
};

DialogHeaderField.displayName = "DialogHeaderField";
</file>

<file path="src/shared/ui/dialogs/adaptive-dialog.tsx">
import { cn } from "@/lib/utils";
import { useIsMobile } from "@/shared/lib/responsive";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Drawer,
  DrawerContent,
  DrawerHeader,
  DrawerTitle,
  DrawerTrigger,
} from "@/components/ui/drawer";
import { ReactNode } from "react";

interface AdaptiveDialogProps {
  trigger?: ReactNode;
  title: string;
  children: ReactNode;
  className?: string;
  open?: boolean;
  onOpenChange?: (open: boolean) => void;
}

export function AdaptiveDialog({
  trigger,
  title,
  children,
  className,
  open,
  onOpenChange
}: AdaptiveDialogProps) {
  const isMobile = useIsMobile();

  if (isMobile) {
    return (
      <Drawer open={open} onOpenChange={onOpenChange}>
        {trigger && <DrawerTrigger asChild>{trigger}</DrawerTrigger>}
        <DrawerContent className={cn("max-h-[90vh]", className)}>
          <DrawerHeader>
            <DrawerTitle>{title}</DrawerTitle>
          </DrawerHeader>
          <div className="px-4 pb-4 overflow-y-auto">
            {children}
          </div>
        </DrawerContent>
      </Drawer>
    );
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      {trigger && <DialogTrigger asChild>{trigger}</DialogTrigger>}
      <DialogContent className={cn("max-h-[85vh] overflow-y-auto", className)}>
        <DialogHeader>
          <DialogTitle>{title}</DialogTitle>
        </DialogHeader>
        {children}
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/shared/ui/FormField.tsx">
import React from 'react';
import {Label} from '@/components/ui/label';

interface FormFieldProps {
  name: string;
  label: string;
  icon: React.ElementType;
  children: React.ReactNode;
}

export const FormField: React.FC<FormFieldProps> = ({name, label, icon: Icon, children}) => (
  <div className="space-y-2">
    <Label htmlFor={name} className="flex items-center space-x-2">
      <Icon className="w-4 h-4"/>
      <span>{label}</span>
    </Label>
    {children}
  </div>
);
</file>

<file path="src/shared/ui/forms/adaptive-form.tsx">
import { cn } from "@/lib/utils";
import { useIsMobile } from "@/shared/lib/responsive";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { ReactNode } from "react";

interface AdaptiveFormProps {
  children: ReactNode;
  onSubmit: (e: React.FormEvent) => void;
  submitText?: string;
  className?: string;
  loading?: boolean;
  error?: string;
  card?: boolean;
}

export function AdaptiveForm({
  children,
  onSubmit,
  submitText = "Submit",
  className,
  loading,
  error,
  card = true
}: AdaptiveFormProps) {
  const isMobile = useIsMobile();

  const formContent = (
    <form onSubmit={onSubmit} className="space-y-6">
      <div className={cn(
        "space-y-4",
        isMobile && "space-y-6"
      )}>
        {children}
      </div>
      
      {error && (
        <p className="text-sm text-destructive">{error}</p>
      )}

      <Button
        type="submit"
        className={cn(
          "w-full",
          isMobile && "h-12 text-base"
        )}
        disabled={loading}
      >
        {loading ? "Loading..." : submitText}
      </Button>
    </form>
  );

  if (card) {
    return (
      <Card className={cn(
        "p-6",
        isMobile && "p-4",
        className
      )}>
        {formContent}
      </Card>
    );
  }

  return (
    <div className={className}>
      {formContent}
    </div>
  );
}
</file>

<file path="src/shared/ui/forms/adaptive-input.tsx">
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { cn } from "@/lib/utils";
import { useIsMobile } from "@/shared/lib/responsive";
import { forwardRef } from "react";

interface AdaptiveInputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  error?: string;
}

export const AdaptiveInput = forwardRef<HTMLInputElement, AdaptiveInputProps>(
  ({ label, error, className, ...props }, ref) => {
    const isMobile = useIsMobile();

    return (
      <div className="space-y-2">
        {label && (
          <Label className={cn(
            "block text-sm font-medium",
            isMobile && "text-base"
          )}>
            {label}
          </Label>
        )}
        <Input
          ref={ref}
          {...props}
          className={cn(
            error && "border-destructive",
            isMobile && "h-12 text-base",
            className
          )}
        />
        {error && (
          <p className="text-sm text-destructive">{error}</p>
        )}
      </div>
    );
  }
);
</file>

<file path="src/shared/ui/forms/adaptive-select.tsx">
import { cn } from "@/lib/utils";
import { useIsMobile } from "@/shared/lib/responsive";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import { forwardRef } from "react";

interface SelectOption {
  label: string;
  value: string;
}

interface AdaptiveSelectProps {
  options: SelectOption[];
  label?: string;
  placeholder?: string;
  error?: string;
  className?: string;
  value?: string;
  onChange?: (value: string) => void;
}

export const AdaptiveSelect = forwardRef<HTMLButtonElement, AdaptiveSelectProps>(
  ({ options, label, placeholder, error, className, value, onChange }, ref) => {
    const isMobile = useIsMobile();

    return (
      <div className="space-y-2">
        {label && (
          <Label className={cn(
            "block text-sm font-medium",
            isMobile && "text-base"
          )}>
            {label}
          </Label>
        )}
        <Select value={value} onValueChange={onChange}>
          <SelectTrigger 
            ref={ref}
            className={cn(
              error && "border-destructive",
              isMobile && "h-12 text-base",
              className
            )}
          >
            <SelectValue placeholder={placeholder} />
          </SelectTrigger>
          <SelectContent>
            {options.map((option) => (
              <SelectItem 
                key={option.value} 
                value={option.value}
                className={cn(
                  isMobile && "h-12 text-base"
                )}
              >
                {option.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
        {error && (
          <p className="text-sm text-destructive">{error}</p>
        )}
      </div>
    );
  }
);
</file>

<file path="src/shared/ui/images/adaptive-image.tsx">
import Image from 'next/image';
import { useState } from 'react';
import { cn } from '@/lib/utils';

interface AdaptiveImageProps {
  src: string;
  alt: string;
  sizes?: string;
  className?: string;
  aspectRatio?: 'square' | '16/9' | '4/3' | '3/2' | string;
  fill?: boolean;
  width?: number;
  height?: number;
}

export const AdaptiveImage = ({
  src,
  alt,
  sizes = '(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw',
  className,
  aspectRatio = 'square',
  fill = false,
  width,
  height,
}: AdaptiveImageProps) => {
  const [isLoading, setIsLoading] = useState(true);

  const aspectRatioClass = {
    'square': 'aspect-square',
    '16/9': 'aspect-video',
    '4/3': 'aspect-[4/3]',
    '3/2': 'aspect-[3/2]',
  }[aspectRatio] || aspectRatio;

  if (fill) {
    return (
      <div className={cn(
        "relative overflow-hidden rounded-lg",
        aspectRatioClass,
        className
      )}>
        <Image
          src={src}
          alt={alt}
          fill
          sizes={sizes}
          className={cn(
            "object-cover duration-700 ease-in-out",
            isLoading ? "scale-110 blur-2xl grayscale" : "scale-100 blur-0 grayscale-0"
          )}
          onLoadingComplete={() => setIsLoading(false)}
        />
      </div>
    );
  }

  return (
    <div className={cn(
      "overflow-hidden rounded-lg",
      aspectRatioClass,
      className
    )}>
      <Image
        src={src}
        alt={alt}
        width={width || 1920}
        height={height || 1080}
        className={cn(
          "w-full h-full object-cover duration-700 ease-in-out",
          isLoading ? "scale-110 blur-2xl grayscale" : "scale-100 blur-0 grayscale-0"
        )}
        onLoadingComplete={() => setIsLoading(false)}
      />
    </div>
  );
};
</file>

<file path="src/shared/ui/InputField.tsx">
import React from 'react';
import {Input} from '@/components/ui/input';
import {FieldError} from 'react-hook-form';
import {cn} from "@/lib/utils";
import {AlertCircle} from 'lucide-react';

interface InputFieldProps {
  name: string;
  label: string;
  icon?: React.ReactNode;
  register: any;
  placeholder?: string;
  required?: boolean;
  disabled?: boolean;
  value?: string;
  type?: string;
  error?: FieldError;
  isPercentage?: boolean;
  min?: number;
  max?: number;
  maxLength?: number;
  exactLength?: boolean;
}

export const InputField: React.FC<InputFieldProps> = ({
                                                        name,
                                                        label,
                                                        icon: Icon,
                                                        register,
                                                        placeholder,
                                                        required = false,
                                                        type = 'text',
                                                        disabled = false,
                                                        value,
                                                        error,
                                                        isPercentage = false,
                                                        min = 0,
                                                        max,
                                                        maxLength,
                                                        exactLength = false
                                                      }) => {
  // Convert type='number' to pattern input for length control
  const inputType = (type === 'number' || isPercentage) ? 'text' : type;
  const inputPattern = (type === 'number' || isPercentage) ? '[0-9]*' : undefined;

  return (
    <div className="mb-4">
      <label htmlFor={name} className="block text-sm font-medium text-gray-700">
        {label}
        {maxLength && (
          <span className="text-gray-500 text-xs ml-1">
                        {exactLength ? `(Exactly ${maxLength} digits)` : `(Max ${maxLength} digits)`}
                    </span>
        )}
      </label>

      <div className="relative">
        {Icon && (
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            {Icon}
          </div>
        )}
        <Input
          id={name}
          type={inputType}
          pattern={inputPattern}
          inputMode={type === 'number' || isPercentage ? 'numeric' : undefined}
          disabled={disabled}
          placeholder={placeholder}
          maxLength={maxLength}
          {...register(name, {
            required: required ? 'This field is required' : false,
            validate: (value: string) => {
              // Empty check for optional fields
              if (!value && !required) return true;

              // Length validation
              if (exactLength && maxLength && value.length !== maxLength) {
                return `Input must be exactly ${maxLength} digits`;
              }
              if (maxLength && value.length > maxLength) {
                return `Input cannot exceed ${maxLength} digits`;
              }

              // Number validation
              if (type === 'number' || isPercentage) {
                // Check if input contains only numbers
                if (!/^\d*$/.test(value)) {
                  return 'Please enter only numbers';
                }

                const numValue = parseFloat(value);
                if (isNaN(numValue)) {
                  return 'Please enter a valid number';
                }
                if (numValue < min) {
                  return `Value cannot be less than ${min}${isPercentage ? '%' : ''}`;
                }

              }

              if (type === 'email') {
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(value)) {
                  return 'Invalid email format';
                }
              }
              return true;
            },
            onChange: (e: React.ChangeEvent<HTMLInputElement>) => {
              // Remove non-numeric characters for number inputs
              if (type === 'number' || isPercentage) {
                e.target.value = e.target.value.replace(/[^\d]/g, '');
              }
            }
          })}
          className={cn(
            'block w-full pl-10 pr-8 py-2 border rounded-md shadow-sm sm:text-sm',
            error ?
              'border-red-600 focus:ring-red-500 focus:border-red-500' :
              'border-gray-300 focus:ring-indigo-500 focus:border-indigo-500',
            disabled && 'bg-gray-100 cursor-not-allowed'
          )}
        />
        {isPercentage && (
          <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none text-gray-500">
            %
          </div>
        )}
      </div>
      {error && (
        <p className="text-sm text-red-600 flex items-center space-x-1">
          <AlertCircle className="h-4 w-4 text-red-600" aria-hidden="true"/>
          <span>{error.message}</span>
        </p>
      )}
    </div>
  );
};

export default InputField;
</file>

<file path="src/shared/ui/layouts/responsive-container.tsx">
import { cn } from "@/lib/utils";
import { ReactNode } from "react";

interface ResponsiveContainerProps {
  children: ReactNode;
  className?: string;
}

export const ResponsiveContainer = ({
  children,
  className
}: ResponsiveContainerProps) => {
  return (
    <div className={cn(
      "w-full px-4 mx-auto sm:px-6 md:px-8 max-w-7xl",
      className
    )}>
      {children}
    </div>
  );
};
</file>

<file path="src/shared/ui/layouts/responsive-grid.tsx">
import { cn } from "@/lib/utils";
import { ReactNode } from "react";

interface ResponsiveGridProps {
  children: ReactNode;
  className?: string;
  cols?: {
    sm?: number;
    md?: number;
    lg?: number;
    xl?: number;
  };
  gap?: string;
}

export const ResponsiveGrid = ({
  children,
  className,
  cols = {
    sm: 2,
    md: 2,
    lg: 3,
    xl: 4
  },
  gap = "4"
}: ResponsiveGridProps) => {
  const getGridCols = () => {
    return {
      'grid-cols-1': true,
      [`sm:grid-cols-${cols.sm}`]: cols.sm,
      [`md:grid-cols-${cols.md}`]: cols.md,
      [`lg:grid-cols-${cols.lg}`]: cols.lg,
      [`xl:grid-cols-${cols.xl}`]: cols.xl,
    };
  };

  return (
    <div className={cn(
      "grid",
      `gap-${gap}`,
      getGridCols(),
      className
    )}>
      {children}
    </div>
  );
};
</file>

<file path="src/shared/ui/logo/ModernMinimalistLogo.tsx">
'use client';

import React from 'react';
import { Pill } from 'lucide-react';

interface ModernMinimalistLogoProps {
  size?: "small" | "default" | "large";
  animate?: boolean;
}

const ModernMinimalistLogo: React.FC<ModernMinimalistLogoProps> = ({ 
  size = "default",
  animate = true
}) => {
  // Size classes based on parameter and responsive considerations
  const sizeClasses = {
    small: {
      container: "h-7 md:h-8",
      iconBox: "h-7 w-7 md:h-8 md:w-8",
      icon: "w-3.5 h-3.5 md:w-4 md:h-4",
      text: "text-base md:text-lg"
    },
    default: {
      container: "h-8 md:h-10",
      iconBox: "h-8 w-8 md:h-10 md:w-10",
      icon: "w-5 h-5 md:w-6 md:h-6",
      text: "text-lg md:text-xl"
    },
    large: {
      container: "h-10 md:h-12",
      iconBox: "h-10 w-10 md:h-12 md:w-12",
      icon: "w-6 h-6 md:w-7 md:h-7",
      text: "text-xl md:text-2xl"
    }
  };
  
  const selectedSize = sizeClasses[size];
  
  return (
    <div className={`flex items-center space-x-2 ${selectedSize.container}`}>
      <div className={`relative ${selectedSize.iconBox} flex items-center justify-center`}>
        {/* Background square with rotation */}
        <div 
          className={`absolute inset-0 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-lg transform ${animate ? 'animate-rotate-slow' : 'rotate-45'}`}
        />
        
        {/* Counter-rotated pill icon */}
        <Pill 
          className={`relative ${selectedSize.icon} text-white transform ${animate ? 'animate-counter-rotate-slow' : '-rotate-45'}`} 
        />
      </div>
      
      {/* Text logo */}
      <span className={`font-sans ${selectedSize.text} font-bold text-gray-800`}>
        Pharmacy<span className="text-blue-600">Hub</span>
      </span>
      
      {/* Animation keyframes */}
      <style jsx>{`
        @keyframes rotate-slow {
          0% { transform: rotate(45deg); }
          100% { transform: rotate(405deg); }
        }
        @keyframes counter-rotate-slow {
          0% { transform: rotate(-45deg); }
          100% { transform: rotate(-405deg); }
        }
        .animate-rotate-slow {
          animation: rotate-slow 12s linear infinite;
        }
        .animate-counter-rotate-slow {
          animation: counter-rotate-slow 12s linear infinite;
        }
      `}</style>
    </div>
  );
};

export default ModernMinimalistLogo;
</file>

<file path="src/shared/ui/navigation/adaptive-nav.tsx">
import { useIsMobile } from "@/shared/lib/responsive";
import { cn } from "@/lib/utils";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import { Button } from "@/components/ui/button";
import { Menu } from "lucide-react";
import { useState } from "react";

interface NavItem {
  label: string;
  href: string;
  icon?: React.ReactNode;
}

interface AdaptiveNavProps {
  items: NavItem[];
  className?: string;
  logo?: React.ReactNode;
}

export const AdaptiveNav = ({
  items,
  className,
  logo
}: AdaptiveNavProps) => {
  const isMobile = useIsMobile();
  const [isOpen, setIsOpen] = useState(false);

  if (isMobile) {
    return (
      <>
        <nav className={cn(
          "fixed top-0 left-0 right-0 z-50",
          "h-16 px-4 border-b bg-background/95 backdrop-blur",
          className
        )}>
          <div className="flex items-center justify-between h-full">
            {logo}
            <Sheet open={isOpen} onOpenChange={setIsOpen}>
              <SheetTrigger asChild>
                <Button variant="ghost" size="icon">
                  <Menu className="h-5 w-5" />
                </Button>
              </SheetTrigger>
              <SheetContent side="right" className="w-[80vw] sm:w-[350px]">
                <div className="flex flex-col gap-4 mt-8">
                  {items.map((item) => (
                    <a
                      key={item.href}
                      href={item.href}
                      className="flex items-center gap-2 p-2 rounded-md hover:bg-accent"
                      onClick={() => setIsOpen(false)}
                    >
                      {item.icon}
                      <span>{item.label}</span>
                    </a>
                  ))}
                </div>
              </SheetContent>
            </Sheet>
          </div>
        </nav>
        <div className="h-16" /> {/* Spacer for fixed nav */}
      </>
    );
  }

  return (
    <nav className={cn(
      "h-16 px-8 border-b bg-background",
      className
    )}>
      <div className="flex items-center justify-between h-full max-w-7xl mx-auto">
        {logo}
        <div className="flex items-center gap-8">
          {items.map((item) => (
            <a
              key={item.href}
              href={item.href}
              className="flex items-center gap-2 text-sm font-medium hover:text-primary"
            >
              {item.icon}
              <span>{item.label}</span>
            </a>
          ))}
        </div>
      </div>
    </nav>
  );
};
</file>

<file path="src/shared/ui/navigation/adaptive-pagination.tsx">
import { cn } from "@/lib/utils";
import { useIsMobile } from "@/shared/lib/responsive";
import { Button } from "@/components/ui/button";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { useGestures } from "@/shared/lib/hooks/use-gestures";

interface AdaptivePaginationProps {
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
  className?: string;
}

export function AdaptivePagination({
  currentPage,
  totalPages,
  onPageChange,
  className
}: AdaptivePaginationProps) {
  const isMobile = useIsMobile();

  useGestures({
    onSwipeLeft: () => {
      if (currentPage < totalPages) {
        onPageChange(currentPage + 1);
      }
    },
    onSwipeRight: () => {
      if (currentPage > 1) {
        onPageChange(currentPage - 1);
      }
    }
  });

  const renderPageNumbers = () => {
    const pages: (number | string)[] = [];
    const maxVisiblePages = isMobile ? 3 : 5;

    if (totalPages <= maxVisiblePages) {
      for (let i = 1; i <= totalPages; i++) {
        pages.push(i);
      }
    } else {
      if (currentPage <= 2) {
        for (let i = 1; i <= 3; i++) pages.push(i);
        pages.push('...');
        pages.push(totalPages);
      } else if (currentPage >= totalPages - 1) {
        pages.push(1);
        pages.push('...');
        for (let i = totalPages - 2; i <= totalPages; i++) pages.push(i);
      } else {
        pages.push(1);
        if (currentPage > 3) pages.push('...');
        pages.push(currentPage - 1);
        pages.push(currentPage);
        pages.push(currentPage + 1);
        if (currentPage < totalPages - 2) pages.push('...');
        pages.push(totalPages);
      }
    }

    return pages;
  };

  return (
    <div className={cn(
      "flex items-center justify-center gap-2",
      className
    )}>
      <Button
        variant="outline"
        size={isMobile ? "icon" : "default"}
        onClick={() => onPageChange(currentPage - 1)}
        disabled={currentPage === 1}
      >
        <ChevronLeft className="h-4 w-4" />
        {!isMobile && <span className="ml-2">Previous</span>}
      </Button>

      {!isMobile && (
        <div className="flex items-center gap-1">
          {renderPageNumbers().map((page, index) => (
            typeof page === 'number' ? (
              <Button
                key={index}
                variant={page === currentPage ? "default" : "outline"}
                size="icon"
                onClick={() => onPageChange(page)}
                className="w-8 h-8"
              >
                {page}
              </Button>
            ) : (
              <span key={index} className="px-1">...</span>
            )
          ))}
        </div>
      )}

      {isMobile && (
        <span className="text-sm">
          Page {currentPage} of {totalPages}
        </span>
      )}

      <Button
        variant="outline"
        size={isMobile ? "icon" : "default"}
        onClick={() => onPageChange(currentPage + 1)}
        disabled={currentPage === totalPages}
      >
        {!isMobile && <span className="mr-2">Next</span>}
        <ChevronRight className="h-4 w-4" />
      </Button>
    </div>
  );
}
</file>

<file path="src/shared/ui/navigation/bottom-nav.tsx">
import { cn } from "@/lib/utils";
import { useIsMobile } from "@/shared/lib/responsive";
import Link from "next/link";
import { usePathname } from "next/navigation";

interface BottomNavItem {
  href: string;
  label: string;
  icon: React.ReactNode;
}

interface BottomNavProps {
  items: BottomNavItem[];
  className?: string;
}

export const BottomNav = ({ items, className }: BottomNavProps) => {
  const isMobile = useIsMobile();
  const pathname = usePathname();

  if (!isMobile) return null;

  return (
    <>
      <nav className={cn(
        "fixed bottom-0 left-0 right-0 z-50",
        "h-16 px-4 bg-background border-t",
        "safe-bottom",
        className
      )}>
        <div className="flex items-center justify-around h-full max-w-lg mx-auto">
          {items.map((item) => {
            const isActive = pathname === item.href;
            return (
              <Link
                key={item.href}
                href={item.href}
                className={cn(
                  "flex flex-col items-center justify-center",
                  "w-16 h-16 gap-1",
                  "tap-highlight-transparent touch-manipulation",
                  "transition-colors duration-200",
                  isActive ? "text-primary" : "text-muted-foreground"
                )}
              >
                {item.icon}
                <span className="text-xs font-medium">{item.label}</span>
              </Link>
            );
          })}
        </div>
      </nav>
      <div className="h-16" /> {/* Spacer for fixed nav */}
    </>
  );
};
</file>

<file path="src/shared/ui/navigation/Header.tsx">
import React from "react";
import {cn} from "@/lib/utils";
import {Button} from "@/components/ui/button";
import Link from "next/link";
import { ModernMinimalistLogo } from "@/shared/ui/logo";

interface NavbarProps {
  className?: string;
}

const Header = ({className}: NavbarProps) => {
  return (
    <header className={cn("border-b border-gray-200 bg-white", className)}>
      <div className="container mx-auto px-4 flex h-14 md:h-16 items-center justify-between">
        {/* Neon Logo */}
        <div className="flex items-center">
          <ModernMinimalistLogo size="small" animate={true} />
        </div>

        {/* Join Us Button - Visible on both mobile and desktop */}
        <Link href="/login" passHref>
          <Button
            variant="outline"
            className="text-sm md:text-base bg-gradient-to-r from-blue-600 to-indigo-600 text-white border-0 hover:opacity-90 transition-all duration-300 py-1.5 md:py-2 px-3 md:px-4"
          >
            Join Us
          </Button>
        </Link>
      </div>
    </header>
  );
};

export default Header;
</file>

<file path="src/shared/ui/navigation/MobileNavItem.tsx">
import {Button} from "@/components/ui/button";
import {NavItemProps} from "@/components/NavigationBar/NavItem";

const MobileNavItem = ({item}: NavItemProps) => {
  const Icon = item.icon;

  return (
    <Button
      variant="ghost"
      className="w-full justify-start"
      asChild
    >
      <a href={item.link}>
        <Icon className="mr-2 h-4 w-4"/>
        {item.title}
      </a>
    </Button>
  );
};

export default MobileNavItem;
</file>

<file path="src/shared/ui/navigation/NavItem.tsx">
import {Button} from "@/components/ui/button";
import {MenuItem} from "@/types/menuItem";

export interface NavItemProps {
  item: MenuItem;
}

const NavItem = ({item}: NavItemProps) => {
  const Icon = item.icon;

  return (
    <Button
      variant="ghost"
      className="flex items-center space-x-2 h-12 px-4 hover:bg-accent"
      asChild
    >
      <a href={item.link}>
        <Icon className="h-4 w-4"/>
        <span>{item.title}</span>
      </a>
    </Button>
  );
};
export default NavItem;
</file>

<file path="src/shared/ui/navigation/UserMenu.tsx">
// src/components/Layout/UserMenu.tsx
import React from 'react';
import {useRouter} from 'next/navigation';
import {useAuthContext} from "@/context/AuthContext";
import {Button} from "@/components/ui/button";
import {Avatar, AvatarFallback, AvatarImage} from "@/components/ui/avatar";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {FaSignOutAlt, FaUser} from "react-icons/fa";

interface UserMenuProps {
  user: {
    name: string;
    email: string;
  } | null;
}

const UserMenu: React.FC<UserMenuProps> = ({user}) => {
  const router = useRouter();
  const {logout} = useAuthContext();

  if (!user) return null;

  const handleLogout = () => {
    logout();
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" className="relative h-8 w-8 rounded-full">
          <Avatar className="h-8 w-8">
            <AvatarImage src="/avatars/01.png" alt={user.name}/>
            <AvatarFallback>{user.name?.charAt(0)}</AvatarFallback>
          </Avatar>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-56" align="end" forceMount>
        <DropdownMenuLabel className="font-normal">
          <div className="flex flex-col space-y-1">
            <p className="text-sm font-medium leading-none">{user.name}</p>
            <p className="text-xs leading-none text-muted-foreground">
              {user.email}
            </p>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator/>
        <DropdownMenuItem onClick={() => router.push("/account-settings")}>
          <FaUser className="mr-2 h-4 w-4"/>
          <span>Account settings</span>
        </DropdownMenuItem>
        <DropdownMenuItem onClick={handleLogout}>
          <FaSignOutAlt className="mr-2 h-4 w-4"/>
          <span>Log out</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
};

export default UserMenu;
</file>

<file path="src/shared/ui/RadioButtonField.tsx">
import React, {ElementType} from 'react';
import {Control, Controller} from 'react-hook-form';
import {Label} from "@/components/ui/label";
import {RadioGroup, RadioGroupItem} from "@/components/ui/radio-group";

interface Option {
  value: string;
  label: string;
}

interface RadioButtonFieldProps {
  name: string;
  label?: string;
  icon?: ElementType;
  control: Control<any>;
  options: Option[];
  required?: boolean;
}

export const RadioButtonField: React.FC<RadioButtonFieldProps> = ({
                                                                    name,
                                                                    label,
                                                                    icon: Icon,
                                                                    control,
                                                                    options,
                                                                    required,
                                                                  }) => {
  return (
    <div className="space-y-2">
      <div className="flex items-center gap-2">
        {Icon && (
          <Icon
            className="h-4 w-4"
            aria-hidden="true"
          />
        )}
        {label && (
          <Label htmlFor={name}>
            {label}
            {required && <span className="text-destructive ml-1">*</span>}
          </Label>
        )}
      </div>
      <Controller
        control={control}
        name={name}
        render={({field}) => (
          <RadioGroup
            onValueChange={field.onChange}
            value={field.value}
            className="flex flex-row flex-wrap gap-6"
          >
            {options.map((option) => (
              <div key={option.value} className="flex items-center space-x-2">
                <RadioGroupItem value={option.value} id={`${name}-${option.value}`}/>
                <Label htmlFor={`${name}-${option.value}`} className="cursor-pointer">{option.label}</Label>
              </div>
            ))}
          </RadioGroup>
        )}
      />
    </div>
  );
};
</file>

<file path="src/shared/ui/search/adaptive-search.tsx">
import { cn } from "@/lib/utils";
import { useIsMobile } from "@/shared/lib/responsive";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Search, X } from "lucide-react";
import { useState } from "react";
import { useDebouncedCallback } from "@/shared/lib/hooks/use-debounced-callback";

interface AdaptiveSearchProps {
  onSearch: (value: string) => void;
  placeholder?: string;
  className?: string;
  initialValue?: string;
  debounceMs?: number;
}

export function AdaptiveSearch({
  onSearch,
  placeholder = "Search...",
  className,
  initialValue = "",
  debounceMs = 300
}: AdaptiveSearchProps) {
  const isMobile = useIsMobile();
  const [value, setValue] = useState(initialValue);
  const [isFocused, setIsFocused] = useState(false);

  const debouncedSearch = useDebouncedCallback((searchValue: string) => {
    onSearch(searchValue);
  }, debounceMs);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    setValue(newValue);
    debouncedSearch(newValue);
  };

  const handleClear = () => {
    setValue("");
    onSearch("");
  };

  return (
    <div className={cn(
      "relative flex items-center gap-2",
      isMobile && isFocused && "fixed inset-x-0 top-0 z-50 bg-background p-4",
      className
    )}>
      <div className="relative flex-1">
        <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
        <Input
          value={value}
          onChange={handleChange}
          placeholder={placeholder}
          className={cn(
            "pl-9 pr-8",
            isMobile && "h-12 text-base"
          )}
          onFocus={() => setIsFocused(true)}
          onBlur={() => setIsFocused(false)}
        />
        {value && (
          <Button
            variant="ghost"
            size="icon"
            className="absolute right-1 top-1/2 -translate-y-1/2 h-6 w-6"
            onClick={handleClear}
          >
            <X className="h-4 w-4" />
          </Button>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/shared/ui/SelectField.tsx">
import React, {ElementType} from 'react';
import {Control, Controller} from 'react-hook-form';
import {Select, SelectContent, SelectItem, SelectTrigger, SelectValue,} from "@/components/ui/select";
import {Label} from "@/components/ui/label";

interface Option {
  value: string;
  label: string;
}

interface SelectFieldProps {
  name: string;
  label?: string;
  icon?: ElementType;
  control: Control<any>;
  options: Option[];
  placeholder?: string;
  required?: boolean;
}

export const SelectField: React.FC<SelectFieldProps> = ({
                                                          name,
                                                          label,
                                                          icon: Icon,
                                                          control,
                                                          options,
                                                          placeholder,
                                                          required,
                                                        }) => {
  return (
    <div className="space-y-2">
      <div className="flex items-center gap-2">
        {Icon && (
          <Icon
            className="h-4 w-4"
            aria-hidden="true"
          />
        )}
        {label && (
          <Label htmlFor={name}>
            {label}
            {required && <span className="text-destructive ml-1">*</span>}
          </Label>
        )}
      </div>
      <Controller
        control={control}
        name={name}
        render={({field}) => (
          <Select
            value={field.value}
            onValueChange={field.onChange}
          >
            <SelectTrigger id={name} aria-label={label}>
              <SelectValue placeholder={placeholder}/>
            </SelectTrigger>
            <SelectContent>
              {options.map((option) => (
                <SelectItem
                  key={option.value}
                  value={option.value}
                >
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        )}
      />
    </div>
  );
};
</file>

<file path="src/shared/ui/sidebar/app-sidebar.tsx">
"use client"

import * as React from "react"
import {GraduationCap} from "lucide-react"

import {NavMain} from "@/components/NavSideBar/nav-main"
import {NavUser} from "@/components/NavSideBar/nav-user"
import {SideBarHeader} from "@/components/NavSideBar/sidebar-header"
import {Sidebar, SidebarContent, SidebarFooter, SidebarHeader, SidebarRail,} from "@/components/ui/sidebar"

// Universal access sidebar data
const data = {
  Nav: [
    {
      title: "Exams",
      url: "#",
      icon: GraduationCap,
      isActive: true,
      items: [
        {
          title: "Available Exams",
          url: "/exams",
        },
        {
          title: "My Results",
          url: "/exams/results",
        },
      ],
    },
  ],
}

export function AppSidebar({...props}: React.ComponentProps<typeof Sidebar>) {
  return (
    <Sidebar collapsible="icon" {...props}>
      <SidebarHeader>
        <SideBarHeader/>
      </SidebarHeader>
      <SidebarContent>
        <NavMain items={data.Nav}/>
      </SidebarContent>
      <SidebarFooter>
        <NavUser/>
      </SidebarFooter>
      <SidebarRail/>
    </Sidebar>
  )
}
</file>

<file path="src/shared/ui/sidebar/nav-main.tsx">
"use client"

import {ChevronRight, type LucideIcon} from "lucide-react"

import {Collapsible, CollapsibleContent, CollapsibleTrigger,} from "@/components/ui/collapsible"
import {
  SidebarGroup,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
} from "@/components/ui/sidebar"

export function NavMain({
                          items,
                        }: {
  items: {
    title: string
    url: string
    icon?: LucideIcon
    isActive?: boolean
    items?: {
      title: string
      url: string
    }[]
  }[]
}) {
  return (
    <SidebarGroup>
      <SidebarGroupLabel>Platform</SidebarGroupLabel>
      <SidebarMenu>
        {items.map((item) => (
          <Collapsible
            key={item.title}
            asChild
            defaultOpen={item.isActive}
            className="group/collapsible"
          >
            <SidebarMenuItem>
              <CollapsibleTrigger asChild>
                <SidebarMenuButton tooltip={item.title}>
                  {item.icon && <item.icon/>}
                  <span>{item.title}</span>
                  <ChevronRight
                    className="ml-auto transition-transform duration-200 group-data-[state=open]/collapsible:rotate-90"/>
                </SidebarMenuButton>
              </CollapsibleTrigger>
              <CollapsibleContent>
                <SidebarMenuSub>
                  {item.items?.map((subItem) => (
                    <SidebarMenuSubItem key={subItem.title}>
                      <SidebarMenuSubButton asChild>
                        <a href={subItem.url}>
                          <span>{subItem.title}</span>
                        </a>
                      </SidebarMenuSubButton>
                    </SidebarMenuSubItem>
                  ))}
                </SidebarMenuSub>
              </CollapsibleContent>
            </SidebarMenuItem>
          </Collapsible>
        ))}
      </SidebarMenu>
    </SidebarGroup>
  )
}
</file>

<file path="src/shared/ui/sidebar/nav-projects.tsx">
"use client"

import {Folder, Forward, type LucideIcon, MoreHorizontal, Trash2,} from "lucide-react"

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"
import {
  SidebarGroup,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuButton,
  SidebarMenuItem,
  useSidebar,
} from "@/components/ui/sidebar"

export function NavProjects({
                              projects,
                            }: {
  projects: {
    name: string
    url: string
    icon: LucideIcon
  }[]
}) {
  const {isMobile} = useSidebar()

  return (
    <SidebarGroup className="group-data-[collapsible=icon]:hidden">
      <SidebarGroupLabel>Projects</SidebarGroupLabel>
      <SidebarMenu>
        {projects.map((item) => (
          <SidebarMenuItem key={item.name}>
            <SidebarMenuButton asChild>
              <a href={item.url}>
                <item.icon/>
                <span>{item.name}</span>
              </a>
            </SidebarMenuButton>
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <SidebarMenuAction showOnHover>
                  <MoreHorizontal/>
                  <span className="sr-only">More</span>
                </SidebarMenuAction>
              </DropdownMenuTrigger>
              <DropdownMenuContent
                className="w-48 rounded-lg"
                side={isMobile ? "bottom" : "right"}
                align={isMobile ? "end" : "start"}
              >
                <DropdownMenuItem>
                  <Folder className="text-muted-foreground"/>
                  <span>View Project</span>
                </DropdownMenuItem>
                <DropdownMenuItem>
                  <Forward className="text-muted-foreground"/>
                  <span>Share Project</span>
                </DropdownMenuItem>
                <DropdownMenuSeparator/>
                <DropdownMenuItem>
                  <Trash2 className="text-muted-foreground"/>
                  <span>Delete Project</span>
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </SidebarMenuItem>
        ))}
        <SidebarMenuItem>
          <SidebarMenuButton className="text-sidebar-foreground/70">
            <MoreHorizontal className="text-sidebar-foreground/70"/>
            <span>More</span>
          </SidebarMenuButton>
        </SidebarMenuItem>
      </SidebarMenu>
    </SidebarGroup>
  )
}
</file>

<file path="src/shared/ui/sidebar/nav-tabs.tsx">
"use client"

import {type LucideIcon,} from "lucide-react"
import {
  SidebarGroup,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
} from "@/components/ui/sidebar"

export function NavTabs({
                          menu, MainTitle
                        }: {
  menu: {
    name: string
    url: string
    icon: LucideIcon
  }[];
  MainTitle: string;
}) {
  return (
    <SidebarGroup className="group-data-[collapsible=icon]:hidden">
      <SidebarGroupLabel>{MainTitle}</SidebarGroupLabel>
      <SidebarMenu>
        {menu.map((item) => (
          <SidebarMenuItem key={item.name}>
            <SidebarMenuButton asChild>
              <a href={item.url}>
                <item.icon/>
                <span>{item.name}</span>
              </a>
            </SidebarMenuButton>
          </SidebarMenuItem>
        ))}
      </SidebarMenu>
    </SidebarGroup>
  )
}
</file>

<file path="src/shared/ui/sidebar/nav-user.tsx">
"use client"

import {BadgeCheck, Bell, ChevronsUpDown, CreditCard, LogOut, Sparkles,} from "lucide-react"

import {Avatar, AvatarFallback, AvatarImage,} from "@/components/ui/avatar"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"
import {SidebarMenu, SidebarMenuButton, SidebarMenuItem, useSidebar,} from "@/components/ui/sidebar"
import {useAuth} from "@/hooks/useAuth";
import React, {useState} from "react";
import RegistrationForm from "@/components/RegistrationForm/registration-from";
import {useAuthContext} from "@/context/AuthContext";

export function NavUser() {
  const {isMobile} = useSidebar()
  const {user} = useAuth();
  const {logout} = useAuthContext();
  const [isRegistrationDialogOpen, setIsRegistrationDialogOpen] = useState(false);
  const handleRegister = () => {
    setIsRegistrationDialogOpen(true);
  }
  const handleLogout = () => {
    console.log("Logout Click");
    logout();
  }

  return (
    <>
      <SidebarMenu>
        <SidebarMenuItem>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <SidebarMenuButton
                size="lg"
                className="data-[state=open]:bg-sidebar-accent data-[state=open]:text-sidebar-accent-foreground"
              >
                <Avatar className="h-8 w-8 rounded-lg">
                  <AvatarImage src={"/avatars/shadcn.jpg"} alt={user?.firstName}/>
                  <AvatarFallback className="rounded-lg">CN</AvatarFallback>
                </Avatar>
                <div className="grid flex-1 text-left text-sm leading-tight">
                  <span className="truncate font-semibold">{user?.firstName}</span>
                  <span className="truncate text-xs">{user?.emailAddress}</span>
                </div>
                <ChevronsUpDown className="ml-auto size-4"/>
              </SidebarMenuButton>
            </DropdownMenuTrigger>
            <DropdownMenuContent
              className="w-[--radix-dropdown-menu-trigger-width] min-w-56 rounded-lg"
              side={isMobile ? "bottom" : "right"}
              align="end"
              sideOffset={4}
            >
              <DropdownMenuLabel className="p-0 font-normal">
                <div className="flex items-center gap-2 px-1 py-1.5 text-left text-sm">
                  <Avatar className="h-8 w-8 rounded-lg">
                    <AvatarImage src={"/avatars/shadcn.jpg"} alt={user?.firstName}/>
                    <AvatarFallback className="rounded-lg">CN</AvatarFallback>
                  </Avatar>
                  <div className="grid flex-1 text-left text-sm leading-tight">
                    <span className="truncate font-semibold">{user?.firstName}</span>
                    <span className="truncate text-xs">{user?.emailAddress}</span>
                  </div>
                </div>
              </DropdownMenuLabel>
              <DropdownMenuSeparator/>
              <DropdownMenuGroup>
                <DropdownMenuItem>
                  <Sparkles/>
                  Upgrade to Pro
                </DropdownMenuItem>
              </DropdownMenuGroup>
              <DropdownMenuSeparator/>
              <DropdownMenuGroup>
                <DropdownMenuItem onClick={handleRegister}>
                  <BadgeCheck/>
                  Register
                </DropdownMenuItem>
                <DropdownMenuItem>
                  <CreditCard/>
                  Billing
                </DropdownMenuItem>
                <DropdownMenuItem>
                  <Bell/>
                  Notifications
                </DropdownMenuItem>
              </DropdownMenuGroup>
              <DropdownMenuSeparator/>
              <DropdownMenuItem onClick={handleLogout}>
                <LogOut/>
                Log out
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </SidebarMenuItem>
      </SidebarMenu>
      <RegistrationForm
        open={isRegistrationDialogOpen}
        onOpenChange={setIsRegistrationDialogOpen}/>
    </>
  )
}
</file>

<file path="src/shared/ui/sidebar/sidebar-header.tsx">
"use client"

import * as React from "react"

import {DropdownMenu, DropdownMenuTrigger,} from "@/components/ui/dropdown-menu"
import {SidebarMenu, SidebarMenuButton, SidebarMenuItem,} from "@/components/ui/sidebar"

export function SideBarHeader() {
  return (
    <SidebarMenu>
      <SidebarMenuItem>
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <SidebarMenuButton
              size="lg"
              className="data-[state=open]:bg-sidebar-accent data-[state=open]:text-sidebar-accent-foreground"
            >
              <div
                className="flex aspect-square size-8 items-center justify-center rounded-lg text-sidebar-primary-foreground">
                <img
                  src="/Images/PharmacyHub.png"
                  alt="Pharmacy Hub logo"
                  className="size 4"
                />
              </div>
              <div className="grid flex-1 text-left text-sm leading-tight">
                <span className="truncate font-semibold">
                  Pharmacy Hub
                </span>
                <span className="truncate text-xs">Enterprise</span>
              </div>
            </SidebarMenuButton>
          </DropdownMenuTrigger>

        </DropdownMenu>
      </SidebarMenuItem>
    </SidebarMenu>
  )
}
</file>

<file path="src/shared/ui/sidebar/SideBarLayout.tsx">
import {SidebarInset, SidebarProvider, SidebarTrigger} from "@/components/ui/sidebar";
import {Separator} from "@/components/ui/separator";
import {Breadcrumb, BreadcrumbItem, BreadcrumbLink, BreadcrumbList} from "@/components/ui/breadcrumb";
import {AppSidebar} from "@/components/NavSideBar/app-sidebar";

export const SidebarLayout: React.FC<{ children: React.ReactNode }> = ({children}) => {
  return (
    <SidebarProvider>
      <AppSidebar/>
      <SidebarInset>
        <header
          className="flex h-16 shrink-0 items-center gap-2 transition-[width,height] ease-linear group-has-[[data-collapsible=icon]]/sidebar-wrapper:h-12">
          <div className="flex items-center gap-2 px-4">
            <SidebarTrigger className="-ml-1"/>
            <Separator orientation="vertical" className="mr-2 h-4"/>
            <Breadcrumb>
              <BreadcrumbList>
                <BreadcrumbItem className="hidden md:block">
                  <BreadcrumbLink href="/dashboard">
                    Dashboard
                  </BreadcrumbLink>
                </BreadcrumbItem>
              </BreadcrumbList>
            </Breadcrumb>
          </div>
        </header>
        <div className="ml-4 mr-4">
          {children}
        </div>

      </SidebarInset>
    </SidebarProvider>
  );
};
</file>

<file path="src/shared/ui/tables/adaptive-table.tsx">
import { cn } from "@/lib/utils";
import { useIsMobile } from "@/shared/lib/responsive";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Card } from "@/components/ui/card";

interface Column<T> {
  header: string;
  accessorKey: keyof T;
  cell?: (value: any) => React.ReactNode;
  mobileVisible?: boolean;
}

interface AdaptiveTableProps<T> {
  data: T[];
  columns: Column<T>[];
  className?: string;
  onRowClick?: (row: T) => void;
}

export function AdaptiveTable<T>({
  data,
  columns,
  className,
  onRowClick
}: AdaptiveTableProps<T>) {
  const isMobile = useIsMobile();

  if (isMobile) {
    return (
      <div className={cn("space-y-4", className)}>
        {data.map((row, idx) => (
          <Card 
            key={idx} 
            className={cn(
              "p-4",
              onRowClick && "cursor-pointer hover:bg-accent/50 transition-colors"
            )}
            onClick={() => onRowClick?.(row)}
          >
            <div className="space-y-2">
              {columns
                .filter(col => col.mobileVisible !== false)
                .map((column) => {
                  const value = row[column.accessorKey];
                  return (
                    <div
                      key={String(column.accessorKey)}
                      className="flex justify-between items-center gap-4"
                    >
                      <span className="text-sm font-medium text-muted-foreground">
                        {column.header}
                      </span>
                      <span className="text-sm text-right">
                        {column.cell ? column.cell(value) : String(value)}
                      </span>
                    </div>
                  );
              })}
            </div>
          </Card>
        ))}
      </div>
    );
  }

  return (
    <div className={cn("rounded-md border", className)}>
      <Table>
        <TableHeader>
          <TableRow>
            {columns.map((column) => (
              <TableHead key={String(column.accessorKey)}>
                {column.header}
              </TableHead>
            ))}
          </TableRow>
        </TableHeader>
        <TableBody>
          {data.map((row, idx) => (
            <TableRow 
              key={idx}
              className={cn(
                onRowClick && "cursor-pointer hover:bg-accent/50 transition-colors"
              )}
              onClick={() => onRowClick?.(row)}
            >
              {columns.map((column) => {
                const value = row[column.accessorKey];
                return (
                  <TableCell key={String(column.accessorKey)}>
                    {column.cell ? column.cell(value) : String(value)}
                  </TableCell>
                );
              })}
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}
</file>

<file path="src/shared/ui/UserCard.tsx">
import React, {useState} from "react";
import {Button} from "@/components/ui/button";
import {Card, CardContent} from "@/components/ui/card";
import {useAuth} from "@/hooks/useAuth";
import DetailedUserCard from "@/components/ui/DetailedUserCard";
import RegistrationForm from "@/components/RegistrationForm/registration-from";

type ButtonConfig = {
  name: string;
  action: () => void;
  variant?: "default" | "destructive" | "outline" | "secondary";
};

type UserCardProps = {
  name: string;
  fields: { name: string; value: string }[];
  imageUrl?: string;
  buttons?: ButtonConfig[];
  maxButtons?: number;
};

const UserCard = ({
                    name,
                    fields,
                    imageUrl,
                    buttons = [],
                    maxButtons = 2
                  }: UserCardProps) => {
  const [isDetailedDialogOpen, setIsDetailedDialogOpen] = useState(false);
  const [isRegistrationDialogOpen, setIsRegistrationDialogOpen] = useState(false);
  const {user} = useAuth();

  const handleButtonClick = (button: ButtonConfig, e: React.MouseEvent) => {
    e.stopPropagation();
    if (user?.registered) {
      button.action();
    } else {
      setIsRegistrationDialogOpen(true);
    }
  };

  // Limit buttons to maxButtons
  const displayButtons = buttons.slice(0, maxButtons);

  return (
    <>
      <Card
        className="w-full max-w-4xl cursor-pointer hover:shadow-lg transition-shadow"
        onClick={() => setIsDetailedDialogOpen(true)}
      >
        <CardContent className="flex items-center justify-between p-4 md:p-6">
          <div className="flex items-center space-x-2 md:space-x-4">
            <div className="h-10 w-10 md:h-12 md:w-12 rounded-full bg-gray-200 flex-shrink-0">
              {imageUrl && (
                <img
                  src={imageUrl}
                  alt={name}
                  className="h-full w-full rounded-full object-cover"
                />
              )}
            </div>
            <div className="min-w-0">
              <h3 className="font-medium text-sm md:text-base truncate">{name}</h3>
              <h1 className="text-xs md:text-sm truncate">
                City: {fields.find(f => f.name === "City")?.value}
              </h1>
              <h1 className="text-xs md:text-sm truncate">
                Area: {fields.find(f => f.name === "Area")?.value}
              </h1>
            </div>
          </div>
          <div className="flex space-x-2">
            {displayButtons.map((button, index) => (
              <Button
                key={index}
                onClick={(e) => handleButtonClick(button, e)}
                variant={button.variant || "default"}
                className="ml-2 text-xs md:text-sm"
                size="sm"
              >
                {button.name}
              </Button>
            ))}
          </div>
        </CardContent>
      </Card>

      <DetailedUserCard
        name={name}
        fields={fields}
        ImageUrl={imageUrl}
        open={isDetailedDialogOpen}
        onOpenChange={setIsDetailedDialogOpen}
        isConnected={false}
        onConnect={() => {
        }} // Placeholder, as buttons are now dynamic
        additionalButtons={displayButtons}
      />

      <RegistrationForm
        open={isRegistrationDialogOpen}
        onOpenChange={setIsRegistrationDialogOpen}
      />
    </>
  );
};

export default UserCard;
</file>

<file path="src/utils/password.ts">
import { PASSWORD_CONFIG as PASSWORD } from '@/features/auth/config/auth';

interface PasswordValidationResult {
  isValid: boolean;
  errors: string[];
}

interface PasswordStrength {
  score: number; // 0-4 (very weak to very strong)
  label: 'very-weak' | 'weak' | 'medium' | 'strong' | 'very-strong';
  suggestions: string[];
}

export const validatePassword = (password: string): PasswordValidationResult => {
  const errors: string[] = [];

  // Check minimum length
  if (password.length < PASSWORD.MIN_LENGTH) {
    errors.push(`Password must be at least ${PASSWORD.MIN_LENGTH} characters long`);
  }

  // Check for uppercase letters
  if (PASSWORD.REQUIRE_UPPERCASE && !/[A-Z]/.test(password)) {
    errors.push('Password must contain at least one uppercase letter');
  }

  // Check for lowercase letters
  if (PASSWORD.REQUIRE_LOWERCASE && !/[a-z]/.test(password)) {
    errors.push('Password must contain at least one lowercase letter');
  }

  // Check for numbers
  if (PASSWORD.REQUIRE_NUMBER && !/\d/.test(password)) {
    errors.push('Password must contain at least one number');
  }

  // Check for special characters
  if (PASSWORD.REQUIRE_SPECIAL && !/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    errors.push('Password must contain at least one special character');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

export const calculatePasswordStrength = (password: string): PasswordStrength => {
  let score = 0;
  const suggestions: string[] = [];

  // Length contribution (up to 2 points)
  if (password.length >= PASSWORD.MIN_LENGTH) {
    score += 1;
    if (password.length >= PASSWORD.MIN_LENGTH * 1.5) {
      score += 1;
    }
  } else {
    suggestions.push('Make the password longer');
  }

  // Character variety contribution (up to 2 points)
  let varietyScore = 0;
  
  if (/[A-Z]/.test(password)) varietyScore++;
  else suggestions.push('Add uppercase letters');
  
  if (/[a-z]/.test(password)) varietyScore++;
  else suggestions.push('Add lowercase letters');
  
  if (/\d/.test(password)) varietyScore++;
  else suggestions.push('Add numbers');
  
  if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) varietyScore++;
  else suggestions.push('Add special characters');

  score += Math.min(2, varietyScore / 2);

  // Determine label based on score
  let label: PasswordStrength['label'] = 'very-weak';
  if (score >= 3.5) label = 'very-strong';
  else if (score >= 3) label = 'strong';
  else if (score >= 2) label = 'medium';
  else if (score >= 1) label = 'weak';

  return {
    score,
    label,
    suggestions
  };
};

export const isCommonPassword = (password: string): boolean => {
  // List of the most common passwords to check against
  const commonPasswords = [
    'password',
    '123456',
    '12345678',
    'qwerty',
    'abc123',
    'admin',
    'welcome',
    'password1',
    // Add more common passwords as needed
  ];

  return commonPasswords.includes(password.toLowerCase());
};

export const generateStrongPassword = (): string => {
  const length = PASSWORD.MIN_LENGTH + 4; // Min length plus some extra
  const charset = {
    uppercase: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
    lowercase: 'abcdefghijklmnopqrstuvwxyz',
    numbers: '0123456789',
    special: '!@#$%^&*(),.?":{}|<>'
  };

  let password = '';

  // Ensure at least one character from each required set
  if (PASSWORD.REQUIRE_UPPERCASE) {
    password += charset.uppercase[Math.floor(Math.random() * charset.uppercase.length)];
  }
  if (PASSWORD.REQUIRE_LOWERCASE) {
    password += charset.lowercase[Math.floor(Math.random() * charset.lowercase.length)];
  }
  if (PASSWORD.REQUIRE_NUMBER) {
    password += charset.numbers[Math.floor(Math.random() * charset.numbers.length)];
  }
  if (PASSWORD.REQUIRE_SPECIAL) {
    password += charset.special[Math.floor(Math.random() * charset.special.length)];
  }

  // Fill the rest with random characters
  const allChars = [
    ...charset.uppercase,
    ...charset.lowercase,
    ...charset.numbers,
    ...charset.special
  ].join('');

  while (password.length < length) {
    password += allChars[Math.floor(Math.random() * allChars.length)];
  }

  // Shuffle the password
  return password
    .split('')
    .sort(() => Math.random() - 0.5)
    .join('');
};

/*
Usage Example:

const password = 'MyPassword123!';

// Validate password
const validation = validatePassword(password);
if (!validation.isValid) {
  console.log('Password errors:', validation.errors);
}

// Check password strength
const strength = calculatePasswordStrength(password);
console.log('Password strength:', strength.label);
console.log('Suggestions:', strength.suggestions);

// Check if it's a common password
if (isCommonPassword(password)) {
  console.log('Please choose a less common password');
}

// Generate a strong password
const newPassword = generateStrongPassword();
console.log('Generated password:', newPassword);
*/
</file>

<file path="tailwind.config.ts">
/** @type {import('tailwindcss').Config} */
import type {Config} from "tailwindcss"

const {fontFamily} = require("tailwindcss/defaultTheme")

const config = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: '2rem',
      screens: {
        '2xl': '1400px'
      }
    },
    extend: {
      fontFamily: {
        sans: [
          'var(--font-sans)',
          ...fontFamily.sans
        ]
      },
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))'
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))'
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))'
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))'
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))'
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))'
        },
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))'
        },
        chart: {
          '1': 'hsl(var(--chart-1))',
          '2': 'hsl(var(--chart-2))',
          '3': 'hsl(var(--chart-3))',
          '4': 'hsl(var(--chart-4))',
          '5': 'hsl(var(--chart-5))'
        },
        sidebar: {
          DEFAULT: 'hsl(var(--sidebar-background))',
          foreground: 'hsl(var(--sidebar-foreground))',
          primary: 'hsl(var(--sidebar-primary))',
          'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
          accent: 'hsl(var(--sidebar-accent))',
          'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
          border: 'hsl(var(--sidebar-border))',
          ring: 'hsl(var(--sidebar-ring))'
        }
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)'
      },
      keyframes: {
        'accordion-down': {
          from: {
            height: '0'
          },
          to: {
            height: 'var(--radix-accordion-content-height)'
          }
        },
        'accordion-up': {
          from: {
            height: 'var(--radix-accordion-content-height)'
          },
          to: {
            height: '0'
          }
        },
        'blob': {
          '0%': { transform: 'translate(0px, 0px) scale(1)' },
          '33%': { transform: 'translate(30px, -50px) scale(1.1)' },
          '66%': { transform: 'translate(-20px, 20px) scale(0.9)' },
          '100%': { transform: 'translate(0px, 0px) scale(1)' }
        },
        'float': {
          '0%, 100%': { transform: 'translateY(0px)' },
          '50%': { transform: 'translateY(-10px)' }
        }
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
        'blob': 'blob 7s infinite',
        'float': 'float 3s ease-in-out infinite'
      }
    }
  },
  plugins: [
    require("tailwindcss-animate"),
    function({ addUtilities, addBase }) {
      const newUtilities = {
        '.animation-delay-2000': {
          'animation-delay': '2s',
        },
        '.animation-delay-4000': {
          'animation-delay': '4s',
        },
      }
      addUtilities(newUtilities)
      
      // Add support for prefers-reduced-motion
      addBase({
        '@media (prefers-reduced-motion)': {
          '.animate-blob, .animate-float': {
            'animation': 'none',
          }
        }
      })
    }
  ],
} satisfies Config

export default config
</file>

<file path="ts-errors-fix-summary.md">
# PharmacyHub TypeScript Error Fixes

## Summary of Changes

This document outlines the approach taken to fix the TypeScript errors in the PharmacyHub frontend project while respecting the feature-based architecture.

### Core Approach

1. **Direct Import Fixes:** 
   - Updated imports to point directly to the correct feature modules
   - Maintained the feature-based architecture and organization
   - No introduction of wrapper components or bridge files that would add maintenance overhead

2. **Feature Exports Enhancement:**
   - Added alternative exports in existing feature index files for backward compatibility
   - Used feature hooks with alias exports for legacy imports

3. **Type Consistency:**
   - Fixed type definitions across components
   - Replaced "icon" values with "default" for size props
   - Updated the input props where necessary

### Key Features Fixed

1. **Auth Feature:**
   - Added hooks exports with aliases for useSession
   - Fixed imports to point to the auth feature module

2. **RBAC Feature:**
   - Enhanced hooks exports with usePermissions alias
   - Updated component imports to use the RBAC feature

3. **UI Feature:**
   - Created necessary UI hooks for mobile responsiveness
   - Fixed import paths in components

### Type Definitions

1. **Auth Types:**
   - Created comprehensive auth type definitions
   - Defined roles, permissions, user profiles

2. **Shared Types:**
   - Implemented shared type definitions
   - Defined MenuItem interface for navigation

### Config Files

1. **Auth Config:**
   - Created auth configuration with routes and settings

2. **Menu Items:**
   - Implemented menu item configuration for navigation

## Testing and Verification

All error fixes have been tested for compatibility with the existing architecture. The changes:

1. Maintain the feature-based architecture
2. Do not introduce new directories or structural changes
3. Use existing feature modules for functionality
4. Fix type errors while maintaining backward compatibility

## Next Steps

1. Consider a more comprehensive refactoring to fully align with the feature-based architecture
2. Standardize imports across all components
3. Create a proper feature registry system
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path="wiki/architecture/README.md">
# Architecture Overview

## System Architecture

PharmacyHub is built using a modern, scalable frontend architecture following Feature-Sliced Design (FSD) principles. The application is built with Next.js 15 and uses TypeScript for enhanced type safety and developer experience.

### Core Technologies

- **Framework**: Next.js 15 with App Router
- **Language**: TypeScript
- **State Management**: Zustand + React Query
- **Styling**: Tailwind CSS + shadcn/ui
- **Authentication**: Keycloak + NextAuth.js
- **API Integration**: Axios + React Query
- **Form Management**: React Hook Form + Zod
- **UI Components**: Radix UI + shadcn/ui
- **Charts & Visualization**: Recharts

## Project Structure

```
src/
├── app/                 # Next.js App Router pages
├── components/          # Shared UI components
├── config/             # Application configuration
├── context/            # React context definitions
├── features/           # Feature-based modules
├── hooks/              # Custom React hooks
├── lib/                # Utility functions and shared logic
├── services/           # API and external service integrations
├── shared/             # Shared utilities, types, and components
├── store/              # Global state management
├── types/              # TypeScript type definitions
└── utils/              # Helper functions
```

### Key Directories

#### Features Directory
The features directory follows the Feature-Sliced Design methodology:

```
features/
├── auth/              # Authentication feature
│   ├── api/          # API integration
│   ├── lib/          # Feature-specific utilities
│   ├── model/        # State and types
│   └── ui/           # Feature-specific components
├── exam/             # Exam management feature
├── licensing/        # Licensing management feature
└── [feature]/        # Other features follow the same structure
```

Each feature module is self-contained and includes:
- API integration layer
- Business logic
- UI components
- State management
- Type definitions

## Design Patterns

### 1. Component Architecture
- Follows Atomic Design principles
- Uses composition over inheritance
- Implements Container/Presenter pattern for complex components

### 2. State Management
- Uses Zustand for global state management
- Implements React Query for server state
- Follows CQRS pattern for data operations

### 3. Authentication Flow
- Implements JWT-based authentication
- Uses Keycloak for identity management
- Implements role-based access control (RBAC)

### 4. Error Handling
- Centralized error handling
- Custom error boundaries
- Typed error responses

### 5. Performance Optimization
- Implements code splitting
- Uses dynamic imports
- Optimizes images and assets
- Implements caching strategies

## Design Decisions

### 1. Feature-Sliced Design
- Adopted for better code organization and scalability
- Enables independent feature development
- Facilitates code reuse and maintenance

### 2. TypeScript First
- Strict type checking enabled
- Interface-based development
- Comprehensive type definitions

### 3. Component Library
- Uses shadcn/ui for consistent design
- Custom component extensions
- Responsive design patterns

### 4. State Management Strategy
- Zustand for simple global state
- React Query for server state
- Context for component-level state

### 5. Authentication & Authorization
- Keycloak integration for enterprise-grade security
- Role-based access control
- Permission-based feature flags

## Configuration Management

### Environment Variables
Core environment variables are managed in `.env` files:

- `NEXT_PUBLIC_API_URL`: Backend API endpoint
- `NEXT_PUBLIC_KEYCLOAK_URL`: Keycloak server URL
- `NEXT_PUBLIC_KEYCLOAK_REALM`: Keycloak realm name
- `NEXT_PUBLIC_KEYCLOAK_CLIENT_ID`: Client ID for Keycloak

### Feature Flags
Feature flags are managed in `config/featureFlags.ts`:

- Development features
- Beta features
- Role-based feature access

## Development Guidelines

### Code Organization
1. Follow Feature-Sliced Design principles
2. Keep features self-contained
3. Use shared components for common UI elements
4. Implement proper type definitions

### Best Practices
1. Write unit tests for business logic
2. Implement error boundaries
3. Use proper TypeScript types
4. Follow naming conventions
5. Document complex logic

### Performance Considerations
1. Implement code splitting
2. Optimize bundle size
3. Use proper caching strategies
4. Implement proper loading states

## Monitoring and Logging

### Winston Logger Configuration
The application uses Winston for logging with the following levels:

- ERROR: Application errors
- WARN: Warning conditions
- INFO: General information
- DEBUG: Detailed debug information

### Performance Monitoring
- Implements performance metrics
- Tracks page load times
- Monitors API response times

## Deployment Strategy

### Build Process
1. TypeScript compilation
2. Asset optimization
3. Bundle generation
4. Environment configuration

### Deployment Environments
- Development
- Staging
- Production

Each environment has its own:
- Configuration
- Feature flags
- API endpoints
- Logging levels
</file>

<file path="wiki/contributing/README.md">
# Contributing Guide

[Previous sections remain the same...]

## Troubleshooting

### 1. Common Issues

#### Build Issues
```bash
# Clear Next.js cache
rm -rf .next
npm run build

# Clear node modules
rm -rf node_modules package-lock.json
npm install
```

#### Development Issues
```bash
# Reset local environment
rm -rf .next node_modules package-lock.json
npm install
npm run dev

# Check TypeScript issues
npm run type-check

# Fix linting issues
npm run lint -- --fix
```

#### Testing Issues
```bash
# Clear Jest cache
npm run test -- --clearCache

# Update snapshots
npm run test -- -u

# Run specific tests
npm run test -- -t "test name"
```

### 2. Environment Issues

#### API Connection
```typescript
// Check API configuration
console.log('API URL:', process.env.NEXT_PUBLIC_API_URL);

// Test API connection
fetch(process.env.NEXT_PUBLIC_API_URL + '/health')
  .then(response => response.json())
  .then(data => console.log('API Health:', data));
```

#### Authentication Issues
```typescript
// Check auth configuration
console.log('Auth Config:', {
  keycloakUrl: process.env.NEXT_PUBLIC_KEYCLOAK_URL,
  realm: process.env.NEXT_PUBLIC_KEYCLOAK_REALM,
  clientId: process.env.NEXT_PUBLIC_KEYCLOAK_CLIENT_ID
});
```

## Development Tools

### 1. VS Code Extensions

Required extensions:
- ESLint
- Prettier
- TypeScript and JavaScript Language Features
- Jest Runner
- GitLens
- Error Lens

```json
// .vscode/extensions.json
{
  "recommendations": [
    "dbaeumer.vscode-eslint",
    "esbenp.prettier-vscode",
    "ms-typescript-language",
    "firsttris.vscode-jest-runner",
    "eamodio.gitlens",
    "usernamehw.errorlens"
  ]
}
```

### 2. VS Code Settings

```json
// .vscode/settings.json
{
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  },
  "typescript.tsdk": "node_modules/typescript/lib",
  "typescript.enablePromptUseWorkspaceTsdk": true,
  "javascript.updateImportsOnFileMove.enabled": "always",
  "typescript.updateImportsOnFileMove.enabled": "always"
}
```

### 3. Debug Configuration

```json
// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "chrome",
      "request": "launch",
      "name": "Launch Chrome against localhost",
      "url": "http://localhost:3000",
      "webRoot": "${workspaceFolder}"
    },
    {
      "type": "node",
      "request": "launch",
      "name": "Jest Current File",
      "program": "${workspaceFolder}/node_modules/.bin/jest",
      "args": ["${fileBasename}", "--config", "jest.config.js"],
      "console": "integratedTerminal",
      "windows": {
        "program": "${workspaceFolder}/node_modules/jest/bin/jest"
      }
    }
  ]
}
```

## Project Maintenance

### 1. Dependency Updates

Regular dependency updates:
```bash
# Check outdated packages
npm outdated

# Update packages
npm update

# Update major versions
npx npm-check-updates -u
npm install
```

Security audits:
```bash
# Run security audit
npm audit

# Fix security issues
npm audit fix
```

### 2. Performance Monitoring

```typescript
// src/lib/performance.ts
export const monitorPerformance = {
  logMetric: (metric: string, value: number) => {
    if (process.env.NODE_ENV === 'production') {
      // Send to monitoring service
      console.log(`[Performance] ${metric}: ${value}`);
    }
  },
  
  trackApiCall: async (name: string, call: Promise<any>) => {
    const start = performance.now();
    try {
      const result = await call;
      const duration = performance.now() - start;
      monitorPerformance.logMetric(`api_call_${name}`, duration);
      return result;
    } catch (error) {
      monitorPerformance.logMetric(`api_error_${name}`, 1);
      throw error;
    }
  }
};
```

### 3. Error Tracking

```typescript
// src/lib/error-tracking.ts
export const errorTracking = {
  captureError: (error: Error, context?: Record<string, any>) => {
    console.error('[Error]', {
      message: error.message,
      stack: error.stack,
      context
    });
    // Send to error tracking service
  },
  
  withErrorBoundary: (Component: React.ComponentType) => {
    return class ErrorBoundary extends React.Component {
      componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
        errorTracking.captureError(error, errorInfo);
      }
      
      render() {
        return <Component {...this.props} />;
      }
    };
  }
};
```

## Communication Guidelines

### 1. Issue Reporting

When creating an issue:
- Use issue templates
- Provide clear reproduction steps
- Include relevant logs
- Add appropriate labels
- Link related issues/PRs

### 2. PR Descriptions

Include in PR descriptions:
- Clear description of changes
- Link to related issues
- Screenshots/videos if UI changes
- Breaking changes warning
- Testing instructions
- Deployment considerations

### 3. Documentation Updates

When updating documentation:
- Keep README.md updated
- Update API documentation
- Update component documentation
- Add migration guides
- Update changelog

## Support Resources

### 1. Documentation
- [Project Wiki](../README.md)
- [API Documentation](../api/README.md)
- [Architecture Guide](../architecture/README.md)
- [Testing Guide](../testing/README.md)

### 2. Team Communication
- Discord Channel: `#pharmacyhub-dev`
- Tech Lead: Available in `#tech-support`
- Weekly Dev Meetings: Tuesday 10:00 AM UTC

### 3. Useful Links
- [Project Board](https://github.com/orgs/pharmacyhub/projects/1)
- [CI/CD Pipeline](https://github.com/pharmacyhub/pharmacyhub-frontend/actions)
- [Error Tracking Dashboard](https://sentry.io/pharmacyhub)
- [Performance Monitoring](https://grafana.pharmacyhub.com)
</file>

<file path="wiki/decisions/README.md">
# Architecture Decision Records (ADR)

## What is an ADR?
An Architecture Decision Record (ADR) is a document that captures an important architectural decision made along with its context and consequences.

## ADR Template

### Title
```markdown
# ADR [number]: [title]

## Status
[Proposed, Accepted, Deprecated, Superseded]

## Context
What is the issue that we're seeing that is motivating this decision or change?

## Decision
What is the change that we're proposing and/or doing?

## Consequences
What becomes easier or more difficult to do because of this change?

## Alternatives Considered
What other approaches did we consider and why weren't they chosen?

## References
- Links to relevant documentation
- Related ADRs
- External resources
```

## Sample ADRs

### ADR 1: Next.js App Router Migration
```markdown
# ADR 1: Next.js App Router Migration

## Status
Accepted

## Context
- Current Pages Router becoming deprecated
- Need for better server-side rendering
- Improved performance requirements
- Better support for React Server Components

## Decision
Migrate to Next.js App Router architecture:
- Use server components by default
- Implement client components where needed
- Adopt new data fetching patterns
- Use new routing conventions

## Consequences
### Positive
- Better performance
- Improved SEO
- Reduced client-side JavaScript
- Future-proof architecture

### Negative
- Learning curve for team
- Migration effort required
- Some libraries need updates
- Initial setup complexity

## Alternatives Considered
1. Stay with Pages Router
   - Simpler but becoming obsolete
2. Different meta-framework
   - Less ecosystem support
3. Custom solution
   - Too much maintenance

## References
- [Next.js App Router Documentation](https://nextjs.org/docs)
- [Migration Guide](https://nextjs.org/docs/app/building-your-application/upgrading/app-router-migration)
```

### ADR 2: State Management Strategy
```markdown
# ADR 2: State Management Strategy

## Status
Accepted

## Context
- Need for efficient state management
- Multiple state types (server, client, UI)
- Performance considerations
- Team expertise

## Decision
Implement hybrid state management:
- Zustand for global UI state
- React Query for server state
- Context for local component state
- localStorage for persistence

## Consequences
### Positive
- Clear separation of concerns
- Optimized for different state types
- Reduced boilerplate
- Better performance

### Negative
- Multiple patterns to learn
- Integration complexity
- Initial setup overhead

## Alternatives Considered
1. Redux
   - Too much boilerplate
   - Overkill for our needs
2. MobX
   - Less TypeScript support
3. Jotai/Recoil
   - Less mature ecosystem

## References
- [Zustand Documentation](https://github.com/pmndrs/zustand)
- [React Query Documentation](https://tanstack.com/query/latest)
```

## Important Areas for ADRs

### 1. Architecture Decisions
- Framework choices
- State management
- Routing strategy
- Data fetching
- Authentication

### 2. Technical Stack
- Build tools
- Testing frameworks
- CI/CD tools
- Monitoring solutions
- Deployment strategy

### 3. Development Practices
- Code organization
- Testing strategy
- Documentation approach
- Release process
- Performance optimization

### 4. Security Decisions
- Authentication method
- Authorization strategy
- API security
- Data protection
- Error handling

## Maintaining ADRs

### 1. When to Write an ADR
- Major architectural changes
- Technology stack changes
- Security-related decisions
- Performance optimizations
- Process changes

### 2. Review Process
- Team discussion
- Technical review
- Impact assessment
- Implementation plan
- Documentation update

### 3. Organization
- Chronological order
- Category-based
- Status tracking
- Version control
- Cross-referencing
</file>

<file path="wiki/deployment/README.md">
# Build & Deployment Guide

## Overview

This guide covers the build and deployment processes for the PharmacyHub frontend application. The application uses Next.js 15 and follows a containerized deployment approach.

## Build Process

### Local Build

```bash
# Install dependencies
npm install

# Build the application
npm run build

# Start production server
npm run start
```

### Build Configuration

#### Next.js Configuration
```typescript
// next.config.ts
const nextConfig = {
  reactStrictMode: true,
  output: 'standalone',
  images: {
    domains: ['your-image-domain.com'],
  },
  async redirects() {
    return [
      // Redirect configurations
    ];
  },
};

export default nextConfig;
```

### Environment Configuration

```env
# .env.production
NEXT_PUBLIC_API_URL=https://api.pharmacyhub.com
NEXT_PUBLIC_KEYCLOAK_URL=https://auth.pharmacyhub.com
NEXT_PUBLIC_KEYCLOAK_REALM=pharmacyhub
NEXT_PUBLIC_KEYCLOAK_CLIENT_ID=pharmacyhub-client
```

## Docker Setup

### Dockerfile
```dockerfile
# Dockerfile
# Build stage
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Production stage
FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV production
COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

EXPOSE 3000
ENV PORT 3000
CMD ["node", "server.js"]
```

### Docker Compose
```yaml
# docker-compose.yml
version: '3.8'
services:
  frontend:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - NEXT_PUBLIC_API_URL=https://api.pharmacyhub.com
```

## Deployment Environments

### 1. Development Environment

```bash
# Development server
npm run dev

# Environment variables (.env.development)
NEXT_PUBLIC_API_URL=http://localhost:8080
NEXT_PUBLIC_KEYCLOAK_URL=http://localhost:8080
```

### 2. Staging Environment

```bash
# Build for staging
npm run build

# Environment variables (.env.staging)
NEXT_PUBLIC_API_URL=https://staging-api.pharmacyhub.com
NEXT_PUBLIC_KEYCLOAK_URL=https://staging-auth.pharmacyhub.com
```

### 3. Production Environment

```bash
# Build for production
NODE_ENV=production npm run build

# Environment variables (.env.production)
NEXT_PUBLIC_API_URL=https://api.pharmacyhub.com
NEXT_PUBLIC_KEYCLOAK_URL=https://auth.pharmacyhub.com
```

## CI/CD Pipeline

### GitHub Actions Workflow

```yaml
# .github/workflows/deploy.yml
name: Deploy PharmacyHub Frontend

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run tests
        run: npm test
        
      - name: Build application
        run: npm run build
        
      - name: Build and push Docker image
        run: |
          docker build -t pharmacyhub-frontend .
          docker push your-registry/pharmacyhub-frontend:latest
```

## Kubernetes Deployment

### Deployment Configuration
```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pharmacyhub-frontend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: pharmacyhub-frontend
  template:
    metadata:
      labels:
        app: pharmacyhub-frontend
    spec:
      containers:
        - name: pharmacyhub-frontend
          image: your-registry/pharmacyhub-frontend:latest
          ports:
            - containerPort: 3000
          env:
            - name: NODE_ENV
              value: "production"
            - name: NEXT_PUBLIC_API_URL
              valueFrom:
                configMapKeyRef:
                  name: frontend-config
                  key: api_url
```

### Service Configuration
```yaml
# k8s/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: pharmacyhub-frontend
spec:
  type: ClusterIP
  ports:
    - port: 80
      targetPort: 3000
  selector:
    app: pharmacyhub-frontend
```

## Monitoring & Logging

### Application Logging
```typescript
// src/lib/logger.ts
import winston from 'winston';

export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});
```

### Health Checks
```typescript
// src/app/api/health/route.ts
import { type NextRequest } from 'next/server';

export async function GET(request: NextRequest) {
  return new Response(
    JSON.stringify({
      status: 'healthy',
      timestamp: new Date().toISOString()
    }),
    {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    }
  );
}
```

## Performance Optimization

### Build Optimization
- Enable minification
- Implement code splitting
- Optimize images and assets
- Configure caching headers

### Runtime Optimization
- Enable compression
- Implement CDN integration
- Configure service worker
- Optimize API calls

## Rollback Procedures

### Manual Rollback
```bash
# Revert to previous version
kubectl rollout undo deployment/pharmacyhub-frontend

# Verify rollback
kubectl rollout status deployment/pharmacyhub-frontend
```

### Automated Rollback
```yaml
# In GitHub Actions workflow
steps:
  - name: Deploy
    run: |
      kubectl apply -f k8s/
      kubectl rollout status deployment/pharmacyhub-frontend || kubectl rollout undo deployment/pharmacyhub-frontend
```

## Security Considerations

### 1. Environment Security
- Secure environment variables
- Implement secrets management
- Configure CORS properly

### 2. Runtime Security
- Enable security headers
- Implement CSP
- Configure rate limiting

### 3. Build Security
- Scan dependencies
- Audit npm packages
- Implement security tests

## Troubleshooting

### Common Issues

1. Build Failures
```bash
# Clear Next.js cache
rm -rf .next
# Reinstall dependencies
rm -rf node_modules package-lock.json
npm install
```

2. Deployment Issues
```bash
# Check pod status
kubectl get pods
# Check pod logs
kubectl logs -f deployment/pharmacyhub-frontend
```

3. Runtime Issues
```bash
# Check application logs
kubectl logs -f deployment/pharmacyhub-frontend
# Check service status
kubectl describe service pharmacyhub-frontend
```
</file>

<file path="wiki/development/README.md">
# Development Guide

## Getting Started

### Prerequisites
- Node.js (version compatible with Next.js 15)
- npm or yarn package manager
- Git for version control

### Environment Setup

1. **Clone the Repository**
```bash
git clone [repository-url]
cd pharmacyhub-frontend
```

2. **Install Dependencies**
```bash
npm install
# or
yarn install
```

3. **Environment Configuration**
Create a `.env.local` file in the root directory:
```env
NEXT_PUBLIC_API_URL=
NEXT_PUBLIC_KEYCLOAK_URL=
NEXT_PUBLIC_KEYCLOAK_REALM=
NEXT_PUBLIC_KEYCLOAK_CLIENT_ID=
```

4. **Start Development Server**
```bash
npm run dev
# or
yarn dev
```

## Project Structure

### Core Directories

```
src/
├── app/                 # Next.js App Router pages and layouts
├── components/          # Reusable UI components
├── features/           # Feature modules following FSD
├── shared/             # Shared utilities and components
└── types/              # TypeScript type definitions
```

### Feature Module Structure
Each feature follows the Feature-Sliced Design pattern:
```
feature/
├── api/                # API integration
├── lib/                # Feature-specific utilities
├── model/             # State management and types
└── ui/                # Feature-specific components
```

## Development Workflow

### 1. Code Style & Standards

#### TypeScript Configuration
```typescript
// tsconfig.json key settings
{
  "compilerOptions": {
    "strict": true,
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "noEmit": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [{"name": "next"}]
  }
}
```

#### ESLint Configuration
The project uses Next.js's ESLint configuration with custom rules.

### 2. Component Development

#### UI Components
- Use shadcn/ui components as base
- Implement responsive design
- Follow accessibility guidelines

Example component structure:
```typescript
// src/components/ui/MyComponent.tsx
import React from 'react';
import { cn } from '@/lib/utils';

interface MyComponentProps {
  // Props definition
}

export const MyComponent: React.FC<MyComponentProps> = ({
  // Props destructuring
}) => {
  return (
    // JSX implementation
  );
};
```

### 3. State Management

#### Zustand Store Pattern
```typescript
// src/features/[feature]/model/store.ts
import { create } from 'zustand';

interface StoreState {
  // State definition
}

export const useStore = create<StoreState>((set) => ({
  // Store implementation
}));
```

#### React Query Usage
```typescript
// src/features/[feature]/api/queries.ts
import { useQuery } from '@tanstack/react-query';

export const useFeatureData = () => {
  return useQuery({
    queryKey: ['feature'],
    queryFn: () => // API call implementation
  });
};
```

### 4. API Integration

#### API Client Setup
```typescript
// src/lib/api.ts
import axios from 'axios';

export const apiClient = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  // Additional configuration
});
```

#### Service Pattern
```typescript
// src/features/[feature]/api/service.ts
import { apiClient } from '@/lib/api';

export const featureService = {
  // Service methods
};
```

## Testing Strategy

### Unit Testing
- Test business logic
- Test utility functions
- Test hooks and state management

### Integration Testing
- Test feature workflows
- Test API integration
- Test authentication flows

### E2E Testing
- Test critical user journeys
- Test form submissions
- Test navigation flows

## Performance Optimization

### 1. Code Splitting
- Use dynamic imports
- Implement route-based splitting
- Optimize component loading

### 2. Image Optimization
- Use Next.js Image component
- Implement lazy loading
- Optimize image formats

### 3. State Management
- Implement proper caching
- Optimize re-renders
- Use proper memoization

## Debugging

### Development Tools
- React Developer Tools
- React Query DevTools
- Next.js DevTools

### Logging
```typescript
// src/lib/logger.ts
import { logger } from '@/shared/lib/logger';

logger.info('Log message', {
  // Additional context
});
```

## Build & Deployment

### Build Process
```bash
# Production build
npm run build

# Start production server
npm run start
```

### Environment-Specific Builds
- Development
- Staging
- Production

## Contributing Guidelines

### 1. Branch Naming
- feature/feature-name
- bugfix/issue-description
- hotfix/urgent-fix

### 2. Commit Messages
- Follow conventional commits
- Include ticket references
- Provide clear descriptions

### 3. Pull Requests
- Include description
- Link related issues
- Add necessary labels

## Troubleshooting

### Common Issues
1. Authentication Issues
   - Check Keycloak configuration
   - Verify token handling
   - Check CORS settings

2. Build Issues
   - Clear Next.js cache
   - Update dependencies
   - Check TypeScript errors

3. State Management Issues
   - Check store implementation
   - Verify React Query setup
   - Debug state updates

## Additional Resources

### Documentation
- Next.js Documentation
- shadcn/ui Components
- Keycloak Documentation

### Tools
- VS Code Extensions
- Chrome DevTools
- React Developer Tools
</file>

<file path="wiki/features/README.md">
# Features & Components

## Core Features

### 1. Authentication Module
Location: `src/features/auth/`

#### Components
- **LoginForm** (`src/features/auth/ui/login/LoginForm.tsx`)
  - Handles user authentication
  - Implements form validation
  - Manages authentication state

- **RegisterForm** (`src/features/auth/ui/register/RegisterForm.tsx`)
  - User registration flow
  - Email verification
  - Form validation

- **Password Recovery** (`src/features/auth/ui/password-recovery/`)
  - Password reset flow
  - Security verification
  - Email notifications

#### Authentication Flow
```typescript
// src/features/auth/api/authService.ts
export const authService = {
  login: async (credentials) => {
    // Login implementation
  },
  register: async (userData) => {
    // Registration implementation
  },
  resetPassword: async (email) => {
    // Password reset implementation
  }
};
```

### 2. Exam Management
Location: `src/features/exam/`

#### Components
- **ExamLayout** (`src/components/exam/ExamLayout.tsx`)
  - Exam interface structure
  - Navigation controls
  - Timer integration

- **QuestionCard** (`src/components/exam/QuestionCard.tsx`)
  - Question display
  - Answer selection
  - Validation feedback

#### Exam State Management
```typescript
// src/features/exam/model/store.ts
interface ExamState {
  currentQuestion: number;
  answers: Record<number, string>;
  timeRemaining: number;
  isSubmitted: boolean;
}

const useExamStore = create<ExamState>((set) => ({
  // Exam state implementation
}));
```

### 3. Licensing Management
Location: `src/features/licensing/`

#### Components

##### Registration Forms
```typescript
// src/features/licensing/ui/forms/
- PharmacistForm
- PharmacyManagerForm
- ProprietorForm
- SalesmanForm
```

##### List Components
```typescript
// src/features/licensing/ui/
- PharmacistList
- PharmacyManagerList
- ProprietorList
- SalesmanList
```

#### Licensing Models
```typescript
// src/features/licensing/model/types.ts
interface LicenseBase {
  id: string;
  status: 'PENDING' | 'APPROVED' | 'REJECTED';
  submissionDate: string;
  expiryDate: string;
}

interface PharmacistLicense extends LicenseBase {
  // Pharmacist-specific fields
}

interface PharmacyManagerLicense extends LicenseBase {
  // Manager-specific fields
}
```

## UI Component Library

### 1. Form Components
Location: `src/components/ui/`

#### Input Component
```typescript
// src/components/ui/input.tsx
export interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  error?: string;
  label?: string;
}

export const Input: React.FC<InputProps> = ({
  error,
  label,
  ...props
}) => {
  // Input implementation
};
```

#### Select Component
```typescript
// src/components/ui/select.tsx
export interface SelectProps {
  options: Array<{ value: string; label: string }>;
  value: string;
  onChange: (value: string) => void;
}
```

### 2. Layout Components

#### Responsive Container
```typescript
// src/shared/ui/layouts/responsive-container.tsx
export const ResponsiveContainer: React.FC<{
  children: React.ReactNode;
  className?: string;
}> = ({ children, className }) => {
  // Responsive container implementation
};
```

#### Sidebar Navigation
```typescript
// src/components/dashboard/Sidebar.tsx
export const Sidebar = () => {
  // Navigation implementation with role-based menu items
};
```

### 3. Feedback Components

#### Toast Notifications
```typescript
// src/components/ui/toast.tsx
export const useToast = () => {
  const toast = (message: string, type: 'success' | 'error' | 'info') => {
    // Toast implementation
  };
  return toast;
};
```

#### Loading States
```typescript
// src/components/ui/loading-spinner.tsx
export const LoadingSpinner: React.FC<{
  size?: 'sm' | 'md' | 'lg';
  className?: string;
}> = ({ size = 'md', className }) => {
  // Loading spinner implementation
};
```

## Feature Integration

### 1. API Integration
Location: `src/shared/api/`

```typescript
// src/shared/api/apiClient.ts
export const apiClient = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

apiClient.interceptors.request.use((config) => {
  // Request interceptor implementation
  return config;
});
```

### 2. State Management

#### Global Store
```typescript
// src/store/index.ts
interface GlobalState {
  theme: 'light' | 'dark';
  language: string;
  notifications: Notification[];
}

export const useGlobalStore = create<GlobalState>((set) => ({
  // Global state implementation
}));
```

#### Feature-Specific Stores
```typescript
// Example: src/features/exam/store/examStore.ts
interface ExamState {
  currentExam: Exam | null;
  answers: Answer[];
  timeRemaining: number;
}

export const useExamStore = create<ExamState>((set) => ({
  // Exam-specific state implementation
}));
```

## Component Usage Guidelines

### 1. Form Usage
```typescript
// Example form implementation
import { Input, Select, Button } from '@/components/ui';

const MyForm = () => {
  const handleSubmit = (data) => {
    // Form submission logic
  };

  return (
    <form onSubmit={handleSubmit}>
      <Input
        name="username"
        label="Username"
        required
      />
      <Select
        name="role"
        label="Role"
        options={roleOptions}
      />
      <Button type="submit">Submit</Button>
    </form>
  );
};
```

### 2. Layout Implementation
```typescript
// Example page layout
import { ResponsiveContainer, Sidebar, Header } from '@/components/ui';

const PageLayout = ({ children }) => {
  return (
    <div className="min-h-screen">
      <Header />
      <div className="flex">
        <Sidebar />
        <ResponsiveContainer>
          {children}
        </ResponsiveContainer>
      </div>
    </div>
  );
};
```

### 3. Error Handling
```typescript
// Example error boundary usage
import { ErrorBoundary } from '@/components/common';

const FeatureComponent = () => {
  return (
    <ErrorBoundary fallback={<ErrorFallback />}>
      {/* Feature content */}
    </ErrorBoundary>
  );
};
```

## Maintenance and Updates

### 1. Component Updates
- Follow semantic versioning
- Document breaking changes
- Maintain backwards compatibility
- Update type definitions

### 2. Testing Requirements
- Unit tests for components
- Integration tests for features
- E2E tests for critical flows
- Accessibility testing

### 3. Performance Considerations
- Implement proper memoization
- Optimize re-renders
- Use proper loading states
- Monitor component performance
</file>

<file path="wiki/guides/advanced-patterns.md">
# Advanced Implementation Patterns

[Previous content remains the same...]

## Advanced State Management Patterns

### 1. Command Pattern Implementation
```typescript
// src/shared/lib/command.ts
export interface Command<T> {
  execute(): Promise<Result<T>>;
  undo?(): Promise<Result<void>>;
}

export class CommandBus {
  private handlers: Map<string, CommandHandler> = new Map();

  public register(commandType: string, handler: CommandHandler): void {
    this.handlers.set(commandType, handler);
  }

  public async execute<T>(command: Command<T>): Promise<Result<T>> {
    const handler = this.handlers.get(command.constructor.name);
    if (!handler) {
      return Result.fail(`No handler for command ${command.constructor.name}`);
    }

    try {
      return await handler.execute(command);
    } catch (error) {
      return Result.fail(error);
    }
  }
}

// Example Command Implementation
export class CreateFeatureCommand implements Command<Feature> {
  constructor(private readonly data: FeatureDTO) {}

  async execute(): Promise<Result<Feature>> {
    // Implementation
    return Result.ok(new Feature(this.data));
  }

  async undo(): Promise<Result<void>> {
    // Undo implementation
    return Result.ok();
  }
}
```

### 2. Query Pattern Implementation
```typescript
// src/shared/lib/query.ts
export interface Query<T> {
  execute(): Promise<Result<T>>;
}

export class QueryBus {
  private handlers: Map<string, QueryHandler> = new Map();

  public register<T>(queryType: string, handler: QueryHandler<T>): void {
    this.handlers.set(queryType, handler);
  }

  public async execute<T>(query: Query<T>): Promise<Result<T>> {
    const handler = this.handlers.get(query.constructor.name);
    if (!handler) {
      return Result.fail(`No handler for query ${query.constructor.name}`);
    }

    try {
      return await handler.execute(query);
    } catch (error) {
      return Result.fail(error);
    }
  }
}

// Example Query Implementation
export class GetFeatureByIdQuery implements Query<Feature> {
  constructor(private readonly id: string) {}

  async execute(): Promise<Result<Feature>> {
    // Implementation
    return Result.ok(/* feature */);
  }
}
```

### 3. Advanced Store Patterns
```typescript
// src/shared/lib/store.ts
export interface Store<T> {
  getState(): T;
  setState(updater: (state: T) => T): void;
  subscribe(listener: (state: T) => void): () => void;
}

export class StoreImplementation<T> implements Store<T> {
  private state: T;
  private listeners: ((state: T) => void)[] = [];

  constructor(initialState: T) {
    this.state = initialState;
  }

  public getState(): T {
    return this.state;
  }

  public setState(updater: (state: T) => T): void {
    this.state = updater(this.state);
    this.notify();
  }

  public subscribe(listener: (state: T) => void): () => void {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }

  private notify(): void {
    this.listeners.forEach(listener => listener(this.state));
  }
}

// Store with middleware support
export type Middleware<T> = (
  store: Store<T>
) => (next: (action: any) => void) => (action: any) => void;

export class MiddlewareStore<T> extends StoreImplementation<T> {
  private middlewares: Middleware<T>[] = [];

  public use(middleware: Middleware<T>): void {
    this.middlewares.push(middleware);
  }

  public dispatch(action: any): void {
    const composedMiddleware = this.composeMiddleware();
    composedMiddleware(action);
  }

  private composeMiddleware() {
    const store = this;
    const chain = this.middlewares.map(middleware => middleware(store));
    return chain.reduce((a, b) => next => a(b(next)));
  }
}
```

### 4. Reactive State Management
```typescript
// src/shared/lib/reactive.ts
export class Observable<T> {
  private subscribers: ((value: T) => void)[] = [];
  private currentValue: T;

  constructor(initialValue: T) {
    this.currentValue = initialValue;
  }

  public subscribe(subscriber: (value: T) => void): () => void {
    this.subscribers.push(subscriber);
    subscriber(this.currentValue);
    return () => {
      this.subscribers = this.subscribers.filter(s => s !== subscriber);
    };
  }

  public getValue(): T {
    return this.currentValue;
  }

  public next(value: T): void {
    this.currentValue = value;
    this.notify();
  }

  private notify(): void {
    this.subscribers.forEach(subscriber => subscriber(this.currentValue));
  }
}

// React hook for using observables
export function useObservable<T>(observable: Observable<T>): T {
  const [value, setValue] = useState<T>(observable.getValue());

  useEffect(() => {
    return observable.subscribe(setValue);
  }, [observable]);

  return value;
}
```

### 5. State Machine Pattern
```typescript
// src/shared/lib/state-machine.ts
interface State {
  name: string;
  onEnter?: () => void;
  onExit?: () => void;
}

interface Transition {
  from: string;
  to: string;
  event: string;
  guard?: () => boolean;
  action?: () => void;
}

export class StateMachine {
  private currentState: State;
  private states: Map<string, State> = new Map();
  private transitions: Transition[] = [];

  constructor(initialState: State) {
    this.currentState = initialState;
    this.addState(initialState);
  }

  public addState(state: State): void {
    this.states.set(state.name, state);
  }

  public addTransition(transition: Transition): void {
    this.transitions.push(transition);
  }

  public trigger(event: string): boolean {
    const transition = this.transitions.find(t =>
      t.from === this.currentState.name &&
      t.event === event &&
      (!t.guard || t.guard())
    );

    if (!transition) return false;

    const nextState = this.states.get(transition.to);
    if (!nextState) return false;

    this.currentState.onExit?.();
    transition.action?.();
    this.currentState = nextState;
    this.currentState.onEnter?.();

    return true;
  }

  public getCurrentState(): string {
    return this.currentState.name;
  }
}

// Example usage
const featureStateMachine = new StateMachine({
  name: 'draft',
  onEnter: () => console.log('Entered draft state')
});

featureStateMachine.addState({
  name: 'published',
  onEnter: () => console.log('Published feature')
});

featureStateMachine.addTransition({
  from: 'draft',
  to: 'published',
  event: 'publish',
  guard: () => checkPublishPermission(),
  action: () => publishFeature()
});
```

### 6. Composite Store Pattern
```typescript
// src/shared/lib/composite-store.ts
export class CompositeStore<T> {
  private stores: Map<keyof T, Store<any>> = new Map();

  public addStore<K extends keyof T>(key: K, store: Store<T[K]>): void {
    this.stores.set(key, store);
  }

  public getStore<K extends keyof T>(key: K): Store<T[K]> {
    const store = this.stores.get(key);
    if (!store) {
      throw new Error(`No store found for key ${String(key)}`);
    }
    return store;
  }

  public getState(): T {
    const state = {} as T;
    this.stores.forEach((store, key) => {
      state[key] = store.getState();
    });
    return state;
  }

  public subscribe(listener: (state: T) => void): () => void {
    const unsubscribers: (() => void)[] = [];
    this.stores.forEach(store => {
      unsubscribers.push(store.subscribe(() => {
        listener(this.getState());
      }));
    });
    return () => unsubscribers.forEach(u => u());
  }
}

// Example usage
interface AppState {
  feature: FeatureState;
  ui: UIState;
  auth: AuthState;
}

const appStore = new CompositeStore<AppState>();
appStore.addStore('feature', new StoreImplementation<FeatureState>(initialFeatureState));
appStore.addStore('ui', new StoreImplementation<UIState>(initialUIState));
appStore.addStore('auth', new StoreImplementation<AuthState>(initialAuthState));
```

These advanced patterns provide robust solutions for complex state management needs. Would you like me to:

1. Add more patterns?
2. Include testing strategies for these patterns?
3. Show more real-world usage examples?
4. Add middleware implementations?
5. Something else?
</file>

<file path="wiki/guides/ddd-fsd-patterns.md">
# DDD and FSD Patterns Guide

## Domain-Driven Design in Frontend

### 1. Domain Layer Implementation

```typescript
// src/entities/[domain]/model.ts
export class DomainEntity {
  private readonly props: DomainProps;

  constructor(props: DomainProps) {
    this.validateProps(props);
    this.props = props;
  }

  // Domain methods that encapsulate business logic
  public performBusinessOperation(): Result<void> {
    if (!this.isValidOperation()) {
      return Result.fail('Invalid operation');
    }
    return Result.ok();
  }

  // Value object getters
  public get value(): ValueObject {
    return this.props.value;
  }

  private validateProps(props: DomainProps): void {
    // Validation logic
  }
}
```

### 2. Domain Events

```typescript
// src/entities/[domain]/events.ts
export class DomainEvent {
  constructor(
    public readonly type: string,
    public readonly payload: unknown,
    public readonly metadata: EventMetadata
  ) {}
}

export class DomainEventBus {
  private handlers: Map<string, EventHandler[]> = new Map();

  public subscribe(eventType: string, handler: EventHandler): void {
    const handlers = this.handlers.get(eventType) || [];
    this.handlers.set(eventType, [...handlers, handler]);
  }

  public publish(event: DomainEvent): void {
    const handlers = this.handlers.get(event.type) || [];
    handlers.forEach(handler => handler(event));
  }
}
```

### 3. Repository Pattern

```typescript
// src/entities/[domain]/repository.ts
export interface DomainRepository<T extends DomainEntity> {
  findById(id: string): Promise<T | null>;
  save(entity: T): Promise<void>;
  delete(id: string): Promise<void>;
  findAll(criteria: SearchCriteria): Promise<T[]>;
}

// Implementation
export class APIDomainRepository implements DomainRepository<DomainEntity> {
  constructor(private readonly apiClient: ApiClient) {}

  async findById(id: string): Promise<DomainEntity | null> {
    const response = await this.apiClient.get(`/domain/${id}`);
    return response.data ? new DomainEntity(response.data) : null;
  }

  async save(entity: DomainEntity): Promise<void> {
    await this.apiClient.post('/domain', entity.toDTO());
  }
}
```

## Feature-Sliced Design Implementation

### 1. Layers Organization

```typescript
// src/features/[feature]/index.ts
export * from './api';
export * from './model';
export * from './ui';
export * from './lib';

// src/features/[feature]/api/index.ts
export * from './queries';
export * from './mutations';
export * from './types';
```

### 2. Segments Implementation

```typescript
// src/features/[feature]/model/types.ts
export interface FeatureEntity {
  id: string;
  properties: PropertyMap;
  metadata: Metadata;
}

// src/features/[feature]/model/store.ts
interface FeatureState {
  entities: FeatureEntity[];
  selected: string | null;
  loading: boolean;
}

export const useFeatureStore = create<FeatureState>((set) => ({
  entities: [],
  selected: null,
  loading: false,
  setEntities: (entities: FeatureEntity[]) => set({ entities }),
  setSelected: (id: string | null) => set({ selected: id }),
  setLoading: (loading: boolean) => set({ loading })
}));
```

### 3. Slice Integration

```typescript
// src/features/[feature]/ui/components/FeatureList/index.tsx
export const FeatureList: React.FC = () => {
  const { entities, loading } = useFeatureStore();
  const { data } = useFeatureQuery();

  useEffect(() => {
    if (data) {
      setEntities(data.map(toDomain));
    }
  }, [data, setEntities]);

  if (loading) return <LoadingSpinner />;

  return (
    <div>
      {entities.map(entity => (
        <FeatureItem key={entity.id} entity={entity} />
      ))}
    </div>
  );
};
```

## Clean Architecture in Frontend

### 1. Use Cases

```typescript
// src/features/[feature]/model/use-cases/create-feature.ts
export class CreateFeatureUseCase {
  constructor(
    private readonly repository: FeatureRepository,
    private readonly validator: FeatureValidator
  ) {}

  async execute(dto: CreateFeatureDTO): Promise<Result<FeatureEntity>> {
    // Validation
    const validationResult = this.validator.validate(dto);
    if (!validationResult.isValid) {
      return Result.fail(validationResult.errors);
    }

    // Business logic
    const entity = new FeatureEntity(dto);
    const domainResult = entity.validateBusinessRules();
    if (!domainResult.isSuccess) {
      return Result.fail(domainResult.error);
    }

    // Persistence
    await this.repository.save(entity);
    return Result.ok(entity);
  }
}
```

### 2. Adapters

```typescript
// src/features/[feature]/api/adapters.ts
export class APIFeatureRepository implements FeatureRepository {
  constructor(private readonly apiClient: ApiClient) {}

  async findById(id: string): Promise<FeatureEntity> {
    const response = await this.apiClient.get(`/features/${id}`);
    return this.mapToDomain(response.data);
  }

  private mapToDomain(dto: FeatureDTO): FeatureEntity {
    return new FeatureEntity({
      id: dto.id,
      properties: this.mapProperties(dto.properties),
      metadata: this.mapMetadata(dto.metadata)
    });
  }
}
```

### 3. Controllers (UI Components)

```typescript
// src/features/[feature]/ui/containers/FeatureContainer.tsx
export const FeatureContainer: React.FC = () => {
  const createFeatureUseCase = useCreateFeatureUseCase();
  const [loading, setLoading] = useState(false);

  const handleCreate = async (data: CreateFeatureDTO) => {
    setLoading(true);
    try {
      const result = await createFeatureUseCase.execute(data);
      if (result.isSuccess) {
        // Handle success
      } else {
        // Handle failure
      }
    } finally {
      setLoading(false);
    }
  };

  return <FeatureForm onSubmit={handleCreate} loading={loading} />;
};
```

## Integration Patterns

### 1. Command Pattern

```typescript
// src/features/[feature]/model/commands.ts
export interface Command<T> {
  execute(): Promise<Result<T>>;
  undo?(): Promise<Result<void>>;
}

export class CreateFeatureCommand implements Command<FeatureEntity> {
  constructor(
    private readonly data: CreateFeatureDTO,
    private readonly useCase: CreateFeatureUseCase
  ) {}

  async execute(): Promise<Result<FeatureEntity>> {
    return this.useCase.execute(this.data);
  }
}
```

### 2. Query Pattern

```typescript
// src/features/[feature]/model/queries.ts
export interface Query<T> {
  execute(): Promise<Result<T>>;
}

export class GetFeatureQuery implements Query<FeatureEntity> {
  constructor(
    private readonly id: string,
    private readonly repository: FeatureRepository
  ) {}

  async execute(): Promise<Result<FeatureEntity>> {
    try {
      const entity = await this.repository.findById(this.id);
      return Result.ok(entity);
    } catch (error) {
      return Result.fail(error);
    }
  }
}
```

### 3. Event-Driven Pattern

```typescript
// src/features/[feature]/model/events.ts
export class FeatureCreatedEvent extends DomainEvent {
  constructor(public readonly feature: FeatureEntity) {
    super('FEATURE_CREATED', feature, {
      timestamp: new Date(),
      userId: getCurrentUserId()
    });
  }
}

// Event handlers
export class FeatureEventHandlers {
  @EventHandler(FeatureCreatedEvent)
  handleFeatureCreated(event: FeatureCreatedEvent): void {
    // Handle feature creation
    notifySubscribers(event);
    updateUI(event.feature);
  }
}
```

## Testing Strategies

### 1. Domain Testing

```typescript
// src/__tests__/domain/feature.test.ts
describe('FeatureEntity', () => {
  it('should create valid entity', () => {
    const entity = new FeatureEntity(validProps);
    expect(entity.isValid()).toBe(true);
  });

  it('should enforce business rules', () => {
    const entity = new FeatureEntity(invalidProps);
    const result = entity.performBusinessOperation();
    expect(result.isSuccess).toBe(false);
  });
});
```

### 2. Use Case Testing

```typescript
// src/__tests__/use-cases/create-feature.test.ts
describe('CreateFeatureUseCase', () => {
  let useCase: CreateFeatureUseCase;
  let repository: MockFeatureRepository;

  beforeEach(() => {
    repository = new MockFeatureRepository();
    useCase = new CreateFeatureUseCase(repository);
  });

  it('should create feature', async () => {
    const result = await useCase.execute(validDTO);
    expect(result.isSuccess).toBe(true);
    expect(repository.save).toHaveBeenCalled();
  });
});
```

## Performance Considerations

### 1. State Management Optimization

```typescript
// src/features/[feature]/model/store.ts
export const useFeatureStore = create<FeatureState>()(
  devtools(
    persist(
      (set) => ({
        // Store implementation with performance optimizations
        setEntities: (entities) => set(
          produce((state) => {
            state.entities = entities;
          })
        ),
      }),
      {
        name: 'feature-storage',
        partialize: (state) => ({
          entities: state.entities
        })
      }
    )
  )
);
```

### 2. Query Optimization

```typescript
// src/features/[feature]/api/queries.ts
export const useFeatureQuery = (id: string) => {
  return useQuery({
    queryKey: ['feature', id],
    queryFn: () => repository.findById(id),
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 30 * 60 * 1000, // 30 minutes
    select: (data) => new FeatureEntity(data)
  });
};
```

This comprehensive guide covers the implementation of DDD and FSD patterns in the frontend, along with clean architecture principles and practical patterns for feature development. Would you like me to:

1. Add more specific examples of domain modeling?
2. Include more testing scenarios?
3. Add more patterns or architectural examples?
4. Something else?
</file>

<file path="wiki/guides/detailed-feature-guide.md">
# Comprehensive Feature Implementation Guide

## Tech Stack Overview

### Core Technologies
- Next.js 15 (App Router)
- TypeScript 5.x
- React 19.x
- Zustand (State Management)
- React Query (Server State)
- shadcn/ui (Component Library)
- Tailwind CSS (Styling)

### Testing Stack
- Jest
- React Testing Library
- Cypress (E2E)
- MSW (API Mocking)

### Development Tools
- ESLint
- Prettier
- Husky (Git Hooks)
- Docker
- Keycloak (Auth)

## Feature-Sliced Design Structure

### Base Directory Structure
```
src/
├── features/          # Feature modules
├── entities/          # Business entities
├── shared/           # Shared code
└── widgets/          # Composite components
```

### Feature Module Structure
```
feature-name/
├── api/              # API layer
│   ├── endpoints.ts
│   ├── queries.ts
│   ├── mutations.ts
│   └── types.ts
├── model/           # Domain model
│   ├── types.ts
│   ├── store.ts
│   └── constants.ts
├── ui/              # UI components
│   ├── components/
│   │   └── [ComponentName]/
│   │       ├── index.tsx
│   │       ├── styles.ts
│   │       └── types.ts
│   └── pages/
├── lib/             # Feature-specific utilities
│   ├── utils.ts
│   └── helpers.ts
└── index.ts         # Public API
```

## Feature Implementation Steps

### 1. Domain Analysis
```typescript
// src/entities/[domain]/types.ts
export interface DomainEntity {
  id: string;
  // Core domain properties
}

// Domain invariants and business rules
export class DomainModel {
  private entity: DomainEntity;

  constructor(data: DomainEntity) {
    this.validateEntity(data);
    this.entity = data;
  }

  private validateEntity(data: DomainEntity) {
    // Business rule validations
  }

  // Domain methods
}
```

### 2. Feature Setup

#### a. Feature Configuration
```typescript
// src/features/[feature]/config.ts
export const FEATURE_CONFIG = {
  name: 'featureName',
  routes: {
    base: '/feature',
    detail: '/feature/:id',
  },
  permissions: {
    read: 'feature:read',
    write: 'feature:write',
  },
};
```

#### b. API Types
```typescript
// src/features/[feature]/api/types.ts
import { DomainEntity } from '@/entities/domain';

export interface FeatureDTO {
  // DTO properties
}

export interface FeatureRequest {
  // Request properties
}

export interface FeatureResponse {
  // Response properties
}

// Type transformers
export const toEntity = (dto: FeatureDTO): DomainEntity => ({
  // Transform DTO to domain entity
});

export const toDTO = (entity: DomainEntity): FeatureDTO => ({
  // Transform domain entity to DTO
});
```

### 3. API Layer Implementation

#### a. API Service
```typescript
// src/features/[feature]/api/endpoints.ts
import { apiClient } from '@/shared/api';
import type { FeatureRequest, FeatureResponse } from './types';

export const featureApi = {
  getAll: async (): Promise<FeatureResponse[]> => {
    const response = await apiClient.get('/feature');
    return response.data;
  },

  getById: async (id: string): Promise<FeatureResponse> => {
    const response = await apiClient.get(`/feature/${id}`);
    return response.data;
  },

  create: async (data: FeatureRequest): Promise<FeatureResponse> => {
    const response = await apiClient.post('/feature', data);
    return response.data;
  },
};
```

#### b. React Query Implementation
```typescript
// src/features/[feature]/api/queries.ts
import { useQuery, useMutation } from '@tanstack/react-query';
import { featureApi } from './endpoints';
import { FEATURE_CONFIG } from '../config';

export const useFeatures = () => {
  return useQuery({
    queryKey: [FEATURE_CONFIG.name, 'list'],
    queryFn: featureApi.getAll,
  });
};

export const useFeature = (id: string) => {
  return useQuery({
    queryKey: [FEATURE_CONFIG.name, id],
    queryFn: () => featureApi.getById(id),
  });
};

export const useCreateFeature = () => {
  return useMutation({
    mutationFn: featureApi.create,
    onSuccess: () => {
      // Handle success
    },
  });
};
```

### 4. State Management

#### a. Store Implementation
```typescript
// src/features/[feature]/model/store.ts
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import type { DomainEntity } from '@/entities/domain';

interface FeatureState {
  entities: DomainEntity[];
  selected: string | null;
  filters: Record<string, unknown>;
  setEntities: (entities: DomainEntity[]) => void;
  setSelected: (id: string | null) => void;
  setFilters: (filters: Record<string, unknown>) => void;
}

export const useFeatureStore = create<FeatureState>()(
  devtools(
    (set) => ({
      entities: [],
      selected: null,
      filters: {},
      setEntities: (entities) => set({ entities }),
      setSelected: (id) => set({ selected: id }),
      setFilters: (filters) => set({ filters }),
    }),
    {
      name: 'FeatureStore',
    }
  )
);
```

#### b. Selectors
```typescript
// src/features/[feature]/model/selectors.ts
import { useFeatureStore } from './store';

export const useSelectedEntity = () => {
  const [entities, selected] = useFeatureStore(
    (state) => [state.entities, state.selected]
  );
  return entities.find((entity) => entity.id === selected);
};

export const useFilteredEntities = () => {
  const [entities, filters] = useFeatureStore(
    (state) => [state.entities, state.filters]
  );
  return entities.filter((entity) => {
    // Apply filters
  });
};
```

### 5. UI Components

#### a. Base Component Template
```typescript
// src/features/[feature]/ui/components/FeatureComponent/index.tsx
import { FC } from 'react';
import { useFeatures } from '../../../api/queries';
import { useFeatureStore } from '../../../model/store';
import styles from './styles';
import type { FeatureComponentProps } from './types';

export const FeatureComponent: FC<FeatureComponentProps> = ({
  // Props
}) => {
  const { data, isLoading } = useFeatures();
  const setEntities = useFeatureStore((state) => state.setEntities);

  // Component logic

  return (
    <div className={styles.root}>
      {/* Component JSX */}
    </div>
  );
};
```

#### b. Form Implementation
```typescript
// src/features/[feature]/ui/components/FeatureForm/index.tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { schema } from './schema';
import type { FeatureFormData } from './types';

export const FeatureForm: FC<FeatureFormProps> = ({
  onSubmit,
}) => {
  const form = useForm<FeatureFormData>({
    resolver: zodResolver(schema),
    defaultValues: {
      // Default values
    },
  });

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        {/* Form fields */}
      </form>
    </Form>
  );
};
```

### 6. Testing Implementation

#### a. Unit Tests
```typescript
// src/features/[feature]/__tests__/unit/FeatureComponent.test.tsx
import { render, screen } from '@testing-library/react';
import { FeatureComponent } from '../../ui/components/FeatureComponent';

describe('FeatureComponent', () => {
  it('renders correctly', () => {
    render(<FeatureComponent />);
    expect(screen.getByRole('main')).toBeInTheDocument();
  });

  // More test cases
});
```

#### b. Integration Tests
```typescript
// src/features/[feature]/__tests__/integration/FeatureFlow.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { FeatureFlow } from '../../ui/components/FeatureFlow';

describe('FeatureFlow', () => {
  it('completes the feature flow', async () => {
    render(<FeatureFlow />);
    
    // Test complete feature flow
    await userEvent.click(screen.getByRole('button'));
    await waitFor(() => {
      expect(screen.getByText('Success')).toBeInTheDocument();
    });
  });
});
```

### 7. Error Handling

```typescript
// src/features/[feature]/lib/errors.ts
export class FeatureError extends Error {
  constructor(
    message: string,
    public code: string,
    public details?: Record<string, unknown>
  ) {
    super(message);
    this.name = 'FeatureError';
  }
}

// Error handler
export const handleFeatureError = (error: unknown) => {
  if (error instanceof FeatureError) {
    // Handle specific feature errors
  }
  // Handle other errors
};
```

### 8. Performance Optimization

```typescript
// src/features/[feature]/ui/components/FeatureList/index.tsx
import { useVirtualizer } from '@tanstack/react-virtual';

export const FeatureList: FC<FeatureListProps> = ({
  items,
}) => {
  const parentRef = useRef<HTMLDivElement>(null);

  const virtualizer = useVirtualizer({
    count: items.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 50,
  });

  return (
    <div ref={parentRef} className="h-[500px] overflow-auto">
      <div
        style={{
          height: `${virtualizer.getTotalSize()}px`,
          position: 'relative',
        }}
      >
        {virtualizer.getVirtualItems().map((virtualItem) => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              transform: `translateY(${virtualItem.start}px)`,
            }}
          >
            {/* Item content */}
          </div>
        ))}
      </div>
    </div>
  );
};
```

### 9. Security Implementation

```typescript
// src/features/[feature]/lib/security.ts
import { Permission } from '@/shared/types';

export const checkFeaturePermission = (
  requiredPermission: Permission,
  userPermissions: Permission[]
): boolean => {
  // Check permissions
};

// Permission guard component
export const FeaturePermissionGuard: FC<{
  permission: Permission;
  children: ReactNode;
}> = ({ permission, children }) => {
  const hasPermission = usePermission(permission);
  
  if (!hasPermission) {
    return <Unauthorized />;
  }
  
  return <>{children}</>;
};
```

### 10. Documentation

```typescript
/**
 * Feature documentation should include:
 * 1. Overview
 * 2. Technical architecture
 * 3. Domain model
 * 4. API endpoints
 * 5. Component usage
 * 6. State management
 * 7. Error handling
 * 8. Security
 * 9. Performance considerations
 * 10. Testing strategy
 */
```

### 11. Deployment Considerations

```yaml
# Feature deployment checklist:
- [ ] Feature flag configuration
- [ ] Environment variables
- [ ] API endpoints configuration
- [ ] Database migrations
- [ ] Cache invalidation
- [ ] Monitoring setup
- [ ] Security checks
- [ ] Performance metrics
- [ ] Documentation updates
- [ ] User analytics setup
```

This guide provides a comprehensive approach to feature implementation following FSD and DDD patterns, with our specific tech stack. Would you like me to:

1. Add more specific examples for certain types of features?
2. Include more detailed testing scenarios?
3. Add more security implementations?
4. Expand on any particular section?
</file>

<file path="wiki/guides/feature-implementation.md">
# Feature Implementation Guide

## Initial Planning Phase

### 1. Feature Requirements Document
```markdown
# Feature Name: [Name]

## Overview
- Feature description
- Business value
- User stories
- Acceptance criteria

## Technical Requirements
- API endpoints needed
- Data models
- State management needs
- Security requirements
- Performance considerations

## Dependencies
- External services
- Internal dependencies
- Library requirements
- API dependencies
```

### 2. Feature Architecture Document
```markdown
# Feature Architecture

## Component Structure
- Page components
- Feature components
- Shared components
- Custom hooks

## Data Flow
- API interactions
- State management
- Event handling
- Error handling

## Security Considerations
- Authentication requirements
- Authorization rules
- Data validation
- Security best practices
```

## Implementation Checklist

### 1. Initial Setup
```markdown
[ ] Create feature directory structure:
    ```
    src/features/[feature-name]/
    ├── api/
    │   ├── service.ts
    │   ├── queries.ts
    │   └── mutations.ts
    ├── components/
    │   └── index.ts
    ├── hooks/
    │   └── index.ts
    ├── lib/
    │   └── utils.ts
    ├── model/
    │   ├── types.ts
    │   └── store.ts
    └── index.ts
    ```

[ ] Setup feature routing
[ ] Create initial test files
[ ] Add feature flag (if needed)
```

### 2. API Integration
```markdown
[ ] Define API interfaces
[ ] Create API service
[ ] Implement React Query hooks
[ ] Add error handling
[ ] Implement retry logic
[ ] Add request/response logging
```

### 3. Component Development
```markdown
[ ] Create base components
[ ] Implement state management
[ ] Add form validation
[ ] Implement error boundaries
[ ] Add loading states
[ ] Implement responsive design
[ ] Add accessibility features
```

### 4. Testing Implementation
```markdown
[ ] Unit tests for utilities
[ ] Component tests
[ ] Integration tests
[ ] E2E tests
[ ] Performance tests
[ ] Security tests
```

### 5. Documentation
```markdown
[ ] Update API documentation
[ ] Add component documentation
[ ] Update feature documentation
[ ] Add usage examples
[ ] Update README
```

## Code Examples

### 1. Feature Module Structure
```typescript
// src/features/[feature-name]/index.ts
export * from './api/service';
export * from './components';
export * from './hooks';
export * from './model/types';
export * from './model/store';

// src/features/[feature-name]/api/service.ts
import { apiClient } from '@/lib/api';
import type { FeatureData } from '../model/types';

export const featureService = {
  getData: async (): Promise<FeatureData> => {
    const response = await apiClient.get('/feature-endpoint');
    return response.data;
  },
  // Other service methods
};

// src/features/[feature-name]/model/types.ts
export interface FeatureData {
  id: string;
  // Other properties
}

// src/features/[feature-name]/model/store.ts
import { create } from 'zustand';

interface FeatureState {
  // State definition
}

export const useFeatureStore = create<FeatureState>((set) => ({
  // Store implementation
}));
```

### 2. Component Implementation
```typescript
// src/features/[feature-name]/components/FeatureComponent.tsx
import { useQuery } from '@tanstack/react-query';
import { featureService } from '../api/service';
import { useFeatureStore } from '../model/store';

export const FeatureComponent: React.FC = () => {
  const { data, isLoading, error } = useQuery({
    queryKey: ['feature'],
    queryFn: featureService.getData
  });

  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorDisplay error={error} />;

  return (
    // Component implementation
  );
};
```

## Testing Examples

### 1. Component Tests
```typescript
// src/features/[feature-name]/__tests__/FeatureComponent.test.tsx
import { render, screen } from '@testing-library/react';
import { FeatureComponent } from '../components/FeatureComponent';

describe('FeatureComponent', () => {
  it('should render successfully', () => {
    render(<FeatureComponent />);
    expect(screen.getByRole('main')).toBeInTheDocument();
  });

  it('should handle user interactions', async () => {
    render(<FeatureComponent />);
    // Test user interactions
  });
});
```

### 2. Integration Tests
```typescript
// src/features/[feature-name]/__tests__/integration/FeatureFlow.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { FeatureFlow } from '../components/FeatureFlow';

describe('Feature Flow', () => {
  it('should complete the feature flow', async () => {
    render(<FeatureFlow />);
    // Test complete feature flow
  });
});
```

## Performance Considerations

### 1. Component Optimization
```typescript
// Implement proper memoization
const MemoizedComponent = memo(Component, (prev, next) => {
  return prev.id === next.id;
});

// Use proper hooks dependencies
useEffect(() => {
  // Effect implementation
}, [dependencies]);

// Implement virtualization for lists
import { useVirtualizer } from '@tanstack/react-virtual';
```

### 2. State Management Optimization
```typescript
// Implement selective store updates
const useSelectiveStore = create<Store>((set) => ({
  update: (data: Partial<Store>) => set(data, true)
}));

// Optimize React Query
const { data } = useQuery({
  queryKey: ['key'],
  queryFn: fetchData,
  staleTime: 5 * 60 * 1000,
  cacheTime: 10 * 60 * 1000
});
```

## Security Implementation

### 1. Input Validation
```typescript
// Implement Zod schema
import { z } from 'zod';

const schema = z.object({
  // Schema definition
});

// Validate input
const validateInput = (data: unknown) => {
  return schema.parse(data);
};
```

### 2. Authentication & Authorization
```typescript
// Implement auth guard
const AuthGuard: React.FC = ({ children }) => {
  const { isAuthenticated, hasPermission } = useAuth();

  if (!isAuthenticated) return <LoginRedirect />;
  if (!hasPermission('feature:access')) return <Unauthorized />;

  return <>{children}</>;
};
```

## Deployment Checklist

### 1. Pre-deployment
```markdown
[ ] Run all tests
[ ] Check bundle size
[ ] Run performance tests
[ ] Security audit
[ ] Documentation review
```

### 2. Deployment
```markdown
[ ] Feature flag configuration
[ ] Environment variables
[ ] Database migrations
[ ] Cache invalidation
[ ] Monitoring setup
```

### 3. Post-deployment
```markdown
[ ] Smoke tests
[ ] Performance monitoring
[ ] Error tracking
[ ] User feedback
[ ] Documentation updates
```
</file>

<file path="wiki/guides/feature-specific-implementations.md">
# Feature-Specific Implementation Guides

## Form Feature Implementation

### 1. Form Domain Model
```typescript
// src/features/forms/model/types.ts
export interface FormField {
  id: string;
  type: 'text' | 'number' | 'select' | 'date';
  label: string;
  validation: ValidationRules;
  value: unknown;
}

export interface FormSection {
  id: string;
  title: string;
  fields: FormField[];
}

export interface FormEntity {
  id: string;
  sections: FormSection[];
  metadata: FormMetadata;
}

// Validation Rules
export interface ValidationRules {
  required?: boolean;
  pattern?: RegExp;
  min?: number;
  max?: number;
  custom?: (value: unknown) => boolean;
}
```

### 2. Form Store Implementation
```typescript
// src/features/forms/model/store.ts
interface FormState {
  values: Record<string, unknown>;
  errors: Record<string, string>;
  touched: Record<string, boolean>;
  isSubmitting: boolean;
}

export const useFormStore = create<FormState>((set) => ({
  values: {},
  errors: {},
  touched: {},
  isSubmitting: false,
  
  setValue: (field: string, value: unknown) =>
    set(state => ({
      values: { ...state.values, [field]: value },
      touched: { ...state.touched, [field]: true }
    })),

  setError: (field: string, error: string) =>
    set(state => ({
      errors: { ...state.errors, [field]: error }
    })),

  reset: () => set({ values: {}, errors: {}, touched: {} }),
}));
```

### 3. Form Components
```typescript
// src/features/forms/ui/components/DynamicForm/index.tsx
export const DynamicForm: React.FC<{
  sections: FormSection[];
  onSubmit: (values: Record<string, unknown>) => Promise<void>;
}> = ({ sections, onSubmit }) => {
  const { values, setValue, errors } = useFormStore();
  const form = useForm({
    resolver: zodResolver(generateSchema(sections))
  });

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        {sections.map(section => (
          <FormSection
            key={section.id}
            section={section}
            values={values}
            onChange={setValue}
            errors={errors}
          />
        ))}
        <Button type="submit">Submit</Button>
      </form>
    </Form>
  );
};

// Field Component
const FormField: React.FC<{
  field: FormField;
  value: unknown;
  onChange: (value: unknown) => void;
  error?: string;
}> = ({ field, value, onChange, error }) => {
  const renderField = () => {
    switch (field.type) {
      case 'text':
        return (
          <Input
            value={value as string}
            onChange={e => onChange(e.target.value)}
            error={error}
          />
        );
      case 'select':
        return (
          <Select
            value={value as string}
            onChange={onChange}
            options={field.options}
            error={error}
          />
        );
      // Add other field types
    }
  };

  return (
    <FormControl error={!!error}>
      <Label>{field.label}</Label>
      {renderField()}
      {error && <FormError>{error}</FormError>}
    </FormControl>
  );
};
```

## Dashboard Feature Implementation

### 1. Dashboard Domain Model
```typescript
// src/features/dashboard/model/types.ts
export interface DashboardWidget {
  id: string;
  type: 'chart' | 'stats' | 'table' | 'list';
  title: string;
  data: unknown;
  layout: WidgetLayout;
  settings: WidgetSettings;
}

export interface DashboardLayout {
  widgets: DashboardWidget[];
  layout: LayoutGrid;
}

interface WidgetLayout {
  x: number;
  y: number;
  width: number;
  height: number;
}
```

### 2. Dashboard Store
```typescript
// src/features/dashboard/model/store.ts
interface DashboardState {
  widgets: DashboardWidget[];
  layout: LayoutGrid;
  activeWidgets: string[];
  settings: DashboardSettings;
}

export const useDashboardStore = create<DashboardState>((set) => ({
  widgets: [],
  layout: [],
  activeWidgets: [],
  settings: defaultSettings,

  updateLayout: (layout: LayoutGrid) => set({ layout }),
  
  updateWidget: (widgetId: string, data: Partial<DashboardWidget>) =>
    set(state => ({
      widgets: state.widgets.map(w =>
        w.id === widgetId ? { ...w, ...data } : w
      )
    })),

  toggleWidget: (widgetId: string) =>
    set(state => ({
      activeWidgets: state.activeWidgets.includes(widgetId)
        ? state.activeWidgets.filter(id => id !== widgetId)
        : [...state.activeWidgets, widgetId]
    }))
}));
```

### 3. Dashboard Components
```typescript
// src/features/dashboard/ui/components/Dashboard/index.tsx
export const Dashboard: React.FC = () => {
  const { widgets, layout, updateLayout } = useDashboardStore();

  return (
    <div className="dashboard">
      <GridLayout
        layout={layout}
        onLayoutChange={updateLayout}
        cols={12}
        rowHeight={100}
      >
        {widgets.map(widget => (
          <div key={widget.id}>
            <DashboardWidget widget={widget} />
          </div>
        ))}
      </GridLayout>
    </div>
  );
};

// Widget Component
const DashboardWidget: React.FC<{ widget: DashboardWidget }> = ({ widget }) => {
  const renderWidget = () => {
    switch (widget.type) {
      case 'chart':
        return <ChartWidget data={widget.data} settings={widget.settings} />;
      case 'stats':
        return <StatsWidget data={widget.data} settings={widget.settings} />;
      case 'table':
        return <TableWidget data={widget.data} settings={widget.settings} />;
      default:
        return null;
    }
  };

  return (
    <Card className="widget">
      <CardHeader>
        <CardTitle>{widget.title}</CardTitle>
        <WidgetMenu widget={widget} />
      </CardHeader>
      <CardContent>{renderWidget()}</CardContent>
    </Card>
  );
};
```

## Data Visualization Feature

### 1. Chart Domain Model
```typescript
// src/features/charts/model/types.ts
export interface ChartData {
  labels: string[];
  datasets: ChartDataset[];
  metadata: ChartMetadata;
}

export interface ChartDataset {
  label: string;
  data: number[];
  color: string;
  type: 'line' | 'bar' | 'pie';
}

export interface ChartOptions {
  responsive: boolean;
  scales: ScaleOptions;
  plugins: PluginOptions;
}
```

### 2. Chart Store
```typescript
// src/features/charts/model/store.ts
interface ChartState {
  data: ChartData[];
  activeChart: string | null;
  filters: ChartFilters;
  settings: ChartSettings;
}

export const useChartStore = create<ChartState>((set) => ({
  data: [],
  activeChart: null,
  filters: defaultFilters,
  settings: defaultSettings,

  setData: (data: ChartData[]) => set({ data }),
  
  updateFilters: (filters: Partial<ChartFilters>) =>
    set(state => ({
      filters: { ...state.filters, ...filters }
    })),

  updateSettings: (settings: Partial<ChartSettings>) =>
    set(state => ({
      settings: { ...state.settings, ...settings }
    }))
}));
```

### 3. Chart Components
```typescript
// src/features/charts/ui/components/Chart/index.tsx
export const Chart: React.FC<{
  data: ChartData;
  options?: ChartOptions;
}> = ({ data, options = defaultOptions }) => {
  const { filters, settings } = useChartStore();
  const chartRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    if (!chartRef.current) return;

    const chart = new Chart(chartRef.current, {
      data: applyFilters(data, filters),
      options: {
        ...options,
        ...settings,
        plugins: {
          ...options.plugins,
          tooltip: {
            callbacks: {
              label: (context) => formatTooltip(context, settings)
            }
          }
        }
      }
    });

    return () => chart.destroy();
  }, [data, filters, settings, options]);

  return (
    <div className="chart-container">
      <canvas ref={chartRef} />
      <ChartControls />
    </div>
  );
};

// Chart Controls
const ChartControls: React.FC = () => {
  const { filters, updateFilters, settings, updateSettings } = useChartStore();

  return (
    <div className="chart-controls">
      <FilterSection
        filters={filters}
        onChange={updateFilters}
      />
      <SettingsSection
        settings={settings}
        onChange={updateSettings}
      />
    </div>
  );
};
```

### 4. Data Processing Utilities
```typescript
// src/features/charts/lib/data-processing.ts
export const processChartData = (
  rawData: unknown[],
  config: DataProcessingConfig
): ChartData => {
  // Data transformation logic
  const transformedData = rawData.map(item => ({
    // Transform data according to config
  }));

  // Aggregate data if needed
  const aggregatedData = aggregateData(transformedData, config.aggregation);

  // Format for chart
  return formatChartData(aggregatedData, config.format);
};

export const applyFilters = (
  data: ChartData,
  filters: ChartFilters
): ChartData => {
  // Apply filters to data
  return {
    ...data,
    datasets: data.datasets.map(dataset => ({
      ...dataset,
      data: dataset.data.filter(d => 
        // Apply filter conditions
      )
    }))
  };
};
```

These implementations follow our established patterns while providing specific solutions for common feature types. Each implementation includes:

1. Domain modeling
2. State management
3. UI components
4. Business logic
5. Data processing
6. Type safety

Would you like me to:
1. Add more feature-specific implementations?
2. Add testing strategies for these features?
3. Include more advanced patterns?
4. Something else?
</file>

<file path="wiki/guides/feature-workflow.md">
# Feature Implementation Workflow

## Feature Development Lifecycle

```mermaid
graph TD
    A[Requirements Analysis] --> B[Architecture Planning]
    B --> C[Feature Setup]
    C --> D[Implementation]
    D --> E[Testing]
    E --> F[Code Review]
    F --> G[Documentation]
    G --> H[Deployment]
    H --> I[Monitoring]
    
    subgraph Planning
    A --> |Define Scope| A1[Create Requirements Doc]
    A --> |Technical Analysis| A2[Create Technical Spec]
    A1 --> B
    A2 --> B
    end
    
    subgraph Development
    C --> |Setup Structure| C1[Create Feature Directory]
    C --> |Setup Tests| C2[Create Test Files]
    C1 --> D
    C2 --> D
    D --> |Components| D1[Create Components]
    D --> |API| D2[Implement API]
    D --> |State| D3[Setup State Management]
    end
    
    subgraph Quality
    E --> |Unit Tests| E1[Component Tests]
    E --> |Integration| E2[Feature Tests]
    E --> |E2E| E3[Flow Tests]
    F --> |Review| F1[Code Review]
    F --> |Security| F2[Security Review]
    end
    
    subgraph Release
    G --> |Docs| G1[Update Documentation]
    G --> |Examples| G2[Add Usage Examples]
    H --> |Deploy| H1[Stage Deployment]
    H --> |Verify| H2[Production Deployment]
    end
```

## Feature Implementation States

```mermaid
stateDiagram-v2
    [*] --> Planning
    Planning --> InDevelopment
    InDevelopment --> Testing
    Testing --> Review
    Review --> Documenting
    Documenting --> Deploying
    Deploying --> Monitoring
    Monitoring --> [*]
    
    state Planning {
        [*] --> RequirementsGathering
        RequirementsGathering --> ArchitecturePlanning
        ArchitecturePlanning --> TechnicalSpec
        TechnicalSpec --> [*]
    }
    
    state InDevelopment {
        [*] --> FeatureSetup
        FeatureSetup --> Implementation
        Implementation --> InitialTesting
        InitialTesting --> [*]
    }
    
    state Testing {
        [*] --> UnitTests
        UnitTests --> IntegrationTests
        IntegrationTests --> E2ETests
        E2ETests --> [*]
    }
```

## Component Development Flow

```mermaid
graph TD
    A[Start Component] --> B{Requires API?}
    B -- Yes --> C[Create API Service]
    B -- No --> D[Create Component]
    C --> E[Setup React Query]
    E --> D
    D --> F[Add State Management]
    F --> G[Implement UI]
    G --> H[Add Error Handling]
    H --> I[Add Loading States]
    I --> J[Write Tests]
    J --> K[Document Component]
    K --> L[Code Review]
    L --> M[Deploy]
```

## Testing Flow

```mermaid
graph TD
    A[Start Testing] --> B[Unit Tests]
    B --> C[Component Tests]
    C --> D[Integration Tests]
    D --> E[E2E Tests]
    E --> F[Performance Tests]
    F --> G[Security Tests]
    G --> H[Code Coverage]
    H --> I{Coverage >= 80%}
    I -- Yes --> J[Complete]
    I -- No --> B
```
</file>

<file path="wiki/performance/README.md">
# Performance Optimization Guide

## Performance Monitoring

### 1. Web Vitals Tracking

```typescript
// src/lib/web-vitals.ts
import { onCLS, onFID, onLCP, onTTFB } from 'web-vitals';

export function reportWebVitals(metric: any) {
  // Send to analytics service
  if (process.env.NODE_ENV === 'production') {
    // Example: Send to Google Analytics
    window.gtag?.('event', metric.name, {
      value: Math.round(metric.value * 1000),
      event_category: 'Web Vitals',
      event_label: metric.id,
      non_interaction: true,
    });
  }
}

export function initWebVitals() {
  onCLS(reportWebVitals);
  onFID(reportWebVitals);
  onLCP(reportWebVitals);
  onTTFB(reportWebVitals);
}
```

### 2. Custom Performance Monitoring

```typescript
// src/lib/performance-monitoring.ts
import { logger } from '@/lib/logger';

export class PerformanceMonitor {
  private static marks: Record<string, number> = {};

  static startMark(name: string) {
    this.marks[name] = performance.now();
  }

  static endMark(name: string) {
    const startTime = this.marks[name];
    if (startTime) {
      const duration = performance.now() - startTime;
      logger.info(`Performance: ${name} took ${duration}ms`);
      delete this.marks[name];
      return duration;
    }
    return 0;
  }

  static measureApiCall(name: string, promise: Promise<any>) {
    this.startMark(name);
    return promise.finally(() => this.endMark(name));
  }
}
```

### 3. Error Tracking

```typescript
// src/lib/error-tracking.ts
import { captureException } from '@/lib/logger';

export class ErrorTracker {
  static track(error: Error, context?: Record<string, any>) {
    captureException(error, {
      context,
      tags: {
        feature: context?.feature,
        environment: process.env.NODE_ENV
      }
    });
  }

  static async trackPromise<T>(
    promise: Promise<T>,
    context?: Record<string, any>
  ): Promise<T> {
    try {
      return await promise;
    } catch (error) {
      this.track(error as Error, context);
      throw error;
    }
  }
}
```

## Frontend Optimization Techniques

### 1. React Component Optimization

```typescript
// src/components/exam/QuestionList.tsx
import { useCallback, useMemo } from 'react';

export const QuestionList: React.FC<QuestionListProps> = ({ questions, onSelect }) => {
  // Memoize expensive computations
  const sortedQuestions = useMemo(() => 
    questions.sort((a, b) => a.order - b.order),
    [questions]
  );

  // Memoize callback functions
  const handleSelect = useCallback((id: string) => {
    onSelect(id);
  }, [onSelect]);

  return (
    <div>
      {sortedQuestions.map(question => (
        <QuestionCard
          key={question.id}
          question={question}
          onSelect={handleSelect}
        />
      ))}
    </div>
  );
};
```

### 2. Virtual List Implementation

```typescript
// src/components/common/VirtualList.tsx
import { useVirtualizer } from '@tanstack/react-virtual';

export const VirtualList = <T,>({
  items,
  renderItem,
  itemHeight = 50
}: VirtualListProps<T>) => {
  const parentRef = useRef<HTMLDivElement>(null);

  const virtualizer = useVirtualizer({
    count: items.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => itemHeight,
  });

  return (
    <div ref={parentRef} style={{ height: '400px', overflow: 'auto' }}>
      <div
        style={{
          height: `${virtualizer.getTotalSize()}px`,
          width: '100%',
          position: 'relative',
        }}
      >
        {virtualizer.getVirtualItems().map((virtualItem) => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              transform: `translateY(${virtualItem.start}px)`,
              width: '100%',
            }}
          >
            {renderItem(items[virtualItem.index])}
          </div>
        ))}
      </div>
    </div>
  );
};
```

### 3. Image Lazy Loading

```typescript
// src/components/common/LazyImage.tsx
import { useState, useEffect } from 'react';
import { cn } from '@/lib/utils';

export const LazyImage: React.FC<LazyImageProps> = ({
  src,
  alt,
  className,
  ...props
}) => {
  const [isLoaded, setIsLoaded] = useState(false);
  const [error, setError] = useState(false);

  useEffect(() => {
    const img = new Image();
    img.src = src;
    img.onload = () => setIsLoaded(true);
    img.onerror = () => setError(true);
  }, [src]);

  if (error) {
    return <div className="image-error">Failed to load image</div>;
  }

  return (
    <>
      {!isLoaded && <div className="image-placeholder" />}
      <img
        src={src}
        alt={alt}
        className={cn(
          'transition-opacity duration-300',
          isLoaded ? 'opacity-100' : 'opacity-0',
          className
        )}
        {...props}
      />
    </>
  );
};
```

## Resource Loading Optimization

### 1. Script Loading

```typescript
// next.config.ts
const nextConfig = {
  experimental: {
    optimizeFonts: true,
    optimizeImages: true,
    scriptLoader: {
      strategy: 'worker'
    }
  }
};

export default nextConfig;
```

### 2. Font Loading

```typescript
// src/app/layout.tsx
import { Inter } from 'next/font/google';

const inter = Inter({
  subsets: ['latin'],
  display: 'swap',
  preload: true,
  variable: '--font-inter',
});

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" className={inter.variable}>
      <body>{children}</body>
    </html>
  );
}
```

### 3. Asset Preloading

```typescript
// src/components/common/AssetPreloader.tsx
export const AssetPreloader: React.FC = () => {
  return (
    <head>
      <link
        rel="preload"
        href="/fonts/custom-font.woff2"
        as="font"
        type="font/woff2"
        crossOrigin="anonymous"
      />
      <link
        rel="preload"
        href="/critical-image.jpg"
        as="image"
      />
    </head>
  );
};
```

## Performance Testing

### 1. Lighthouse CI Configuration

```yaml
# lighthouserc.js
module.exports = {
  ci: {
    collect: {
      numberOfRuns: 3,
      startServerCommand: 'npm run start',
      url: ['http://localhost:3000']
    },
    assert: {
      assertions: {
        'categories:performance': ['error', { minScore: 0.9 }],
        'categories:accessibility': ['error', { minScore: 0.9 }],
        'categories:best-practices': ['error', { minScore: 0.9 }],
        'categories:seo': ['error', { minScore: 0.9 }]
      }
    },
    upload: {
      target: 'temporary-public-storage'
    }
  }
};
```

### 2. Performance Testing Scripts

```json
// package.json
{
  "scripts": {
    "test:performance": "lighthouse http://localhost:3000 --output-path=./performance-report.html",
    "test:load": "k6 run load-test.js",
    "analyze:bundle": "ANALYZE=true next build"
  }
}
```

## Performance Best Practices

### 1. Code Guidelines
- Use code splitting for large components
- Implement proper memoization
- Optimize images and assets
- Minimize bundle size
- Use proper caching strategies

### 2. Monitoring Guidelines
- Track Core Web Vitals
- Monitor API performance
- Track error rates
- Monitor bundle sizes
- Track user interactions

### 3. Optimization Checklist
- Image optimization
- Code splitting
- Bundle optimization
- Caching strategy
- Performance monitoring
- Error tracking
- Resource loading
- Component optimization
</file>

<file path="wiki/README.md">
# PharmacyHub Frontend Documentation

Welcome to the PharmacyHub Frontend documentation. This wiki serves as the comprehensive guide to the frontend architecture, development practices, and codebase organization.

## Documentation Sections

1. [Architecture Overview](./architecture/README.md)
   - System Architecture
   - Design Patterns
   - Project Structure

2. [Authentication & Security](./security/README.md)
   - Authentication Flows
   - RBAC Implementation
   - Security Best Practices

3. [Development Guide](./development/README.md)
   - Setup Instructions
   - Development Workflow
   - Code Standards

4. [Features & Components](./features/README.md)
   - Core Components
   - Feature Modules
   - State Management

5. [API Integration](./api/README.md)
   - API Architecture
   - Integration Patterns
   - Error Handling

6. [Build & Deployment](./deployment/README.md)
   - Build Process
   - Deployment Workflow
   - Environment Configuration

7. [Testing](./testing/README.md)
   - Testing Strategy
   - Test Coverage
   - Testing Guidelines

8. [Performance](./performance/README.md)
   - Optimization Techniques
   - Monitoring
   - Best Practices

## Getting Started

For new team members, we recommend starting with:
1. [Architecture Overview](./architecture/README.md)
2. [Development Guide](./development/README.md)
3. [Features & Components](./features/README.md)

## Contributing

Please follow our [Documentation Guidelines](./contributing/README.md) when updating this wiki.
</file>

<file path="wiki/security/README.md">
# Authentication & Security

## Authentication Flow

### Overview
PharmacyHub implements a robust authentication system using Keycloak and NextAuth.js. The authentication flow is designed to be secure, scalable, and maintainable.

### Implementation Details

#### 1. Authentication Provider
```typescript
// src/providers/AuthProvider.tsx
- Manages authentication state
- Handles token refresh
- Provides authentication context
```

#### 2. Auth Guards
Located in `src/components/auth/`:

- `AuthGuard.tsx`: Protects routes requiring authentication
- `RoleGuards.tsx`: Implements role-based access control
- `PermissionGuard.tsx`: Handles feature-level permissions

### Authentication Flow

1. **Initial Authentication**
   ```typescript
   // src/features/auth/api/authService.ts
   - Handles login requests
   - Manages token storage
   - Implements refresh token logic
   ```

2. **Token Management**
   - JWT token storage
   - Automatic token refresh
   - Secure token handling

3. **Session Management**
   ```typescript
   // src/hooks/useSession.ts
   - Manages user sessions
   - Handles session expiry
   - Implements session persistence
   ```

## Role-Based Access Control (RBAC)

### Role Definitions
Located in `src/shared/config/roles.json`:

```json
{
  "ADMIN": {
    "permissions": ["all"]
  },
  "PHARMACIST": {
    "permissions": ["read:drugs", "write:prescriptions"]
  },
  "PHARMACY_MANAGER": {
    "permissions": ["manage:inventory", "read:reports"]
  }
}
```

### Permission Implementation

1. **Permission Guards**
   ```typescript
   // src/components/auth/PermissionGuard.tsx
   - Checks user permissions
   - Implements permission inheritance
   - Handles permission denial
   ```

2. **Permission Hooks**
   ```typescript
   // src/hooks/usePermissions.ts
   - Provides permission checking
   - Handles role-based permissions
   - Implements permission caching
   ```

### Role-Based Components
Located in `src/components/auth/RoleGuards.tsx`:

```typescript
- AdminOnly
- PharmacistOnly
- ManagerOnly
```

## Security Mechanisms

### 1. API Security

#### Request Interceptors
```typescript
// src/lib/api.ts
- Adds authentication headers
- Handles token refresh
- Implements request signing
```

#### Response Interceptors
```typescript
// src/lib/api.ts
- Validates responses
- Handles authentication errors
- Implements retry logic
```

### 2. CORS Configuration
```typescript
// next.config.ts
- Defines allowed origins
- Implements CORS policies
- Handles preflight requests
```

### 3. Input Validation
```typescript
// src/features/auth/lib/validation.ts
- Implements Zod schemas
- Validates user input
- Sanitizes data
```

## Security Best Practices

### 1. Password Security
```typescript
// src/utils/password.ts
- Implements password validation
- Enforces password policies
- Handles password hashing
```

### 2. Session Security
- Implements session timeouts
- Handles concurrent sessions
- Manages session invalidation

### 3. Error Handling
```typescript
// src/components/common/ErrorBoundary.tsx
- Implements secure error handling
- Prevents error information leakage
- Handles authentication errors
```

## Features & Components

### 1. Login Component
```typescript
// src/features/auth/ui/login/LoginForm.tsx
- Implements secure login
- Handles multi-factor authentication
- Manages login errors
```

### 2. Password Recovery
```typescript
// src/features/auth/ui/password-recovery/
- Implements secure password reset
- Handles verification
- Manages reset tokens
```

### 3. Registration
```typescript
// src/features/auth/ui/register/RegisterForm.tsx
- Implements secure registration
- Handles email verification
- Manages user creation
```

## Configuration

### Environment Variables
Required environment variables for security:

```
NEXT_PUBLIC_KEYCLOAK_URL=
NEXT_PUBLIC_KEYCLOAK_REALM=
NEXT_PUBLIC_KEYCLOAK_CLIENT_ID=
NEXT_PUBLIC_API_URL=
```

### Keycloak Configuration
Located in `keycloak-realm/`:
- Realm configuration
- Client settings
- Role mappings

## Maintenance Guidelines

### 1. Token Renewal
- Implement proper token refresh
- Handle token expiration
- Manage refresh token rotation

### 2. Security Updates
- Regular dependency updates
- Security patch application
- Vulnerability scanning

### 3. Access Review
- Regular role review
- Permission audit
- Access log monitoring

## Error Handling

### Authentication Errors
```typescript
// src/features/auth/api/authService.ts
- Handles login failures
- Manages token errors
- Implements retry logic
```

### Authorization Errors
```typescript
// src/components/auth/Unauthorized.tsx
- Handles permission denied
- Manages role conflicts
- Implements error recovery
```
</file>

<file path="wiki/standards/README.md">
# Documentation Standards & Templates

## Project Documentation Structure

### Required Sections
```
wiki/
├── README.md                  # Project overview
├── architecture/             # System architecture
├── security/                # Security implementation
├── development/            # Development guidelines
├── features/               # Feature documentation
├── api/                    # API documentation
├── deployment/            # Deployment guides
├── testing/               # Testing documentation
├── performance/           # Performance guidelines
└── contributing/          # Contributing guidelines
```

### Additional Recommended Sections
```
wiki/
├── decisions/             # Architecture Decision Records (ADRs)
├── patterns/              # Common patterns and solutions
├── troubleshooting/       # Common issues and solutions
├── maintenance/           # Maintenance procedures
└── templates/             # Documentation templates
```

## Documentation Templates

### Feature Documentation Template
```markdown
# Feature Name

## Overview
- Purpose
- Business value
- Key functionalities

## Technical Architecture
- Component structure
- Data flow
- Dependencies

## Implementation Details
- Key components
- State management
- API integration
- Security considerations

## Configuration
- Environment variables
- Feature flags
- Third-party services

## Usage Examples
- Code snippets
- API calls
- Common patterns

## Testing
- Test coverage
- Testing approach
- Test data

## Maintenance
- Monitoring
- Common issues
- Debugging
```

### API Documentation Template
```markdown
# API Name

## Overview
- Purpose
- Authentication requirements
- Rate limits

## Endpoints
### [METHOD] /path
- Request format
- Response format
- Error codes
- Examples

## Integration
- Setup requirements
- Example implementation
- Common patterns

## Error Handling
- Error codes
- Recovery procedures
- Logging
```

### Component Documentation Template
```markdown
# Component Name

## Purpose
- Main functionality
- Use cases
- Limitations

## Props
| Name | Type | Required | Description |
|------|------|----------|-------------|
| prop | type | Yes/No   | Description |

## Usage
\`\`\`typescript
// Usage example
\`\`\`

## Implementation Details
- Key logic
- State management
- Side effects

## Testing
- Test cases
- Mock data
- Integration tests
```

## Documentation Best Practices

### 1. Content Guidelines
- Use clear, concise language
- Include code examples
- Document assumptions
- Link related content
- Keep information current

### 2. Structure Guidelines
- Use consistent formatting
- Maintain clear hierarchy
- Include table of contents
- Add search metadata
- Link between documents

### 3. Code Examples
- Use TypeScript
- Include error handling
- Show complete context
- Add comments
- Test all examples

### 4. Diagrams & Visuals
- Use Mermaid diagrams
- Include architecture diagrams
- Add sequence diagrams
- Document data flows
- Include UI mockups

## Maintenance Procedures

### 1. Regular Updates
- Version documentation
- Track changes
- Review accuracy
- Update examples
- Check links

### 2. Review Process
- Technical review
- Peer review
- User feedback
- Accessibility check
- Format consistency

### 3. Version Control
- Document versions
- Track changes
- Migration guides
- Breaking changes
- Deprecation notices

## Search & Navigation

### 1. Search Metadata
```yaml
---
title: Document Title
description: Brief description
keywords: [keyword1, keyword2]
category: Category
subcategory: Subcategory
version: 1.0.0
lastUpdated: 2024-02-22
---
```

### 2. Navigation Structure
- Logical grouping
- Clear hierarchy
- Related content
- Quick links
- Breadcrumbs
</file>

<file path="wiki/testing/README.md">
# Testing Guide

## Test Utilities

### Custom Render
```typescript
// src/test/utils/test-utils.tsx
import { render } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ThemeProvider } from '@/shared/lib/providers/ThemeProvider';

const createTestQueryClient = () => new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
      cacheTime: 0,
    },
  },
});

export function renderWithProviders(
  ui: React.ReactElement,
  { 
    queryClient = createTestQueryClient(),
    ...renderOptions 
  } = {}
) {
  function Wrapper({ children }: { children: React.ReactNode }) {
    return (
      <QueryClientProvider client={queryClient}>
        <ThemeProvider>
          {children}
        </ThemeProvider>
      </QueryClientProvider>
    );
  }

  return {
    queryClient,
    ...render(ui, { wrapper: Wrapper, ...renderOptions }),
  };
}
```

### Mock Utilities

```typescript
// src/test/utils/mock-data.ts
export const mockExam = {
  id: '1',
  title: 'Mock Exam',
  questions: [
    {
      id: '1',
      text: 'Sample question',
      options: ['A', 'B', 'C', 'D'],
      correctAnswer: 'A'
    }
  ],
  duration: 3600,
  totalMarks: 100
};

export const mockUser = {
  id: '1',
  username: 'testuser',
  role: 'PHARMACIST',
  permissions: ['read:exam', 'write:exam']
};

// src/test/utils/mock-handlers.ts
import { rest } from 'msw';

export const handlers = [
  rest.post('/api/auth/login', (req, res, ctx) => {
    return res(
      ctx.json({
        token: 'mock-token',
        user: mockUser
      })
    );
  }),
  
  rest.get('/api/exam/papers', (req, res, ctx) => {
    return res(
      ctx.json([mockExam])
    );
  })
];
```

## Component Testing Patterns

### Form Testing

```typescript
// src/__tests__/components/forms/RegistrationForm.test.tsx
import { screen, fireEvent, waitFor } from '@testing-library/react';
import { renderWithProviders } from '@/test/utils/test-utils';
import { RegistrationForm } from '@/features/auth/ui/register/RegistrationForm';

describe('RegistrationForm', () => {
  it('should validate required fields', async () => {
    renderWithProviders(<RegistrationForm />);
    
    fireEvent.click(screen.getByRole('button', { name: /register/i }));
    
    await waitFor(() => {
      expect(screen.getByText('Username is required')).toBeInTheDocument();
      expect(screen.getByText('Password is required')).toBeInTheDocument();
    });
  });

  it('should validate password requirements', async () => {
    renderWithProviders(<RegistrationForm />);
    
    fireEvent.change(screen.getByLabelText(/password/i), {
      target: { value: 'weak' }
    });
    
    fireEvent.click(screen.getByRole('button', { name: /register/i }));
    
    await waitFor(() => {
      expect(screen.getByText(/password must be at least 8 characters/i))
        .toBeInTheDocument();
    });
  });
});
```

### Async Component Testing

```typescript
// src/__tests__/components/exam/ExamResults.test.tsx
import { screen, waitFor } from '@testing-library/react';
import { renderWithProviders } from '@/test/utils/test-utils';
import { ExamResults } from '@/features/exam/ui/results/ResultsView';
import { mockExam } from '@/test/utils/mock-data';

describe('ExamResults', () => {
  it('should display loading state', () => {
    renderWithProviders(<ExamResults examId="1" />);
    
    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();
  });

  it('should display exam results', async () => {
    renderWithProviders(<ExamResults examId="1" />);
    
    await waitFor(() => {
      expect(screen.getByText(mockExam.title)).toBeInTheDocument();
      expect(screen.getByText(/total score/i)).toBeInTheDocument();
    });
  });

  it('should handle error state', async () => {
    // Mock API error
    server.use(
      rest.get('/api/exam/1/results', (req, res, ctx) => {
        return res(ctx.status(500));
      })
    );

    renderWithProviders(<ExamResults examId="1" />);
    
    await waitFor(() => {
      expect(screen.getByText(/error loading results/i)).toBeInTheDocument();
    });
  });
});
```

## State Management Testing

### Zustand Store Testing

```typescript
// src/__tests__/store/examStore.test.ts
import { create } from 'zustand';
import { createExamSlice, ExamSlice } from '@/features/exam/model/store';

describe('Exam Store', () => {
  let store: ReturnType<typeof create<ExamSlice>>;

  beforeEach(() => {
    store = create<ExamSlice>((...args) => ({
      ...createExamSlice(...args)
    }));
  });

  it('should update current question', () => {
    store.getState().setCurrentQuestion(2);
    expect(store.getState().currentQuestion).toBe(2);
  });

  it('should track answered questions', () => {
    store.getState().setAnswer(1, 'A');
    expect(store.getState().answers[1]).toBe('A');
    expect(store.getState().isQuestionAnswered(1)).toBe(true);
  });
});
```

### React Query Testing

```typescript
// src/__tests__/features/exam/queries.test.ts
import { renderHook, waitFor } from '@testing-library/react-hooks';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useExamQuery } from '@/features/exam/api/queries';

describe('Exam Queries', () => {
  const queryClient = new QueryClient();
  const wrapper = ({ children }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );

  it('should fetch exam data', async () => {
    const { result } = renderHook(() => useExamQuery('1'), { wrapper });

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    expect(result.current.data).toEqual(mockExam);
  });
});
```

## Test Coverage

### Coverage Configuration

```javascript
// jest.config.js
module.exports = {
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.{js,jsx,ts,tsx}',
    '!src/test/**/*'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};
```

### Coverage Scripts

```json
// package.json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:ci": "jest --ci --coverage --maxWorkers=2"
  }
}
```

## Best Practices

### 1. Testing Guidelines
- Write tests as specifications
- Test behavior, not implementation
- Keep tests focused and isolated
- Use meaningful assertions
- Follow the Arrange-Act-Assert pattern

### 2. Component Testing
- Test user interactions
- Test accessibility
- Test error states
- Test loading states
- Test edge cases

### 3. Integration Testing
- Test feature workflows
- Test data flow
- Test error handling
- Test state management
- Test routing

### 4. Performance Testing
- Test component rendering
- Test data fetching
- Test state updates
- Test memory usage
- Test bundle size

## CI/CD Integration

### GitHub Actions Configuration

```yaml
# .github/workflows/test.yml
name: Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run tests
        run: npm run test:ci
        
      - name: Upload coverage
        uses: actions/upload-artifact@v3
        with:
          name: coverage
          path: coverage/
```

## Testing Policy

### 1. Test Requirements
- Unit tests for all new components
- Integration tests for features
- E2E tests for critical paths
- Maintain minimum coverage thresholds

### 2. Review Process
- Test review in PR process
- Coverage report review
- Performance impact review
- Accessibility testing review

### 3. Documentation
- Test documentation
- Testing patterns
- Mock data documentation
- Testing utilities documentation
</file>

</files>
